{"version":3,"sources":["core.js","array-prototype-for-each.js","css-layout.js","event-listener.js","detect.js","init.js","on-resize.js","update-flex-container-cache.js","update-flex-item-cache.js","update-length-cache.js","walk.js"],"names":["flexibility","Array","prototype","forEach","callback","undefined","this","TypeError","Function","object","Object","scope","arguments","arraylike","String","split","length","Math","max","min","index","call","root","factory","define","amd","exports","module","computeLayout","fillNodes","node","layout","isDirty","width","height","top","left","right","bottom","style","children","measure","Error","isUndefined","value","isRowDirection","flexDirection","CSS_FLEX_DIRECTION_ROW","CSS_FLEX_DIRECTION_ROW_REVERSE","isColumnDirection","CSS_FLEX_DIRECTION_COLUMN","CSS_FLEX_DIRECTION_COLUMN_REVERSE","getLeadingMargin","axis","marginStart","marginLeft","marginRight","marginTop","marginBottom","margin","getTrailingMargin","marginEnd","getLeadingPadding","paddingStart","paddingLeft","paddingRight","paddingTop","paddingBottom","padding","getTrailingPadding","paddingEnd","getLeadingBorder","borderStartWidth","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth","borderWidth","getTrailingBorder","borderEndWidth","getLeadingPaddingAndBorder","getTrailingPaddingAndBorder","getBorderAxis","getMarginAxis","getPaddingAndBorderAxis","getJustifyContent","justifyContent","getAlignContent","alignContent","getAlignItem","child","alignSelf","alignItems","resolveAxis","direction","CSS_DIRECTION_RTL","resolveDirection","parentDirection","CSS_DIRECTION_INHERIT","CSS_DIRECTION_LTR","getFlexDirection","getCrossFlexDirection","getPositionType","position","isFlex","CSS_POSITION_RELATIVE","flex","isFlexWrap","flexWrap","getDimWithMargin","dim","isDimDefined","isPosDefined","pos","isMeasureDefined","getPosition","boundAxis","row","minWidth","row-reverse","column","minHeight","column-reverse","maxWidth","maxHeight","boundValue","fmaxf","a","b","setDimensionFromStyle","setTrailingPosition","trailing","getRelativePosition","leading","layoutNodeImpl","parentMaxWidth","parentMaxHeight","mainAxis","crossAxis","resolvedRowAxis","childCount","paddingAndBorderAxisResolvedRow","paddingAndBorderAxisColumn","isResolvedRowDimDefined","CSS_UNDEFINED","isRowUndefined","isColumnUndefined","measureDim","i","ii","isNodeFlexWrap","leadingPaddingAndBorderMain","leadingPaddingAndBorderCross","paddingAndBorderAxisMain","paddingAndBorderAxisCross","isMainDimDefined","isCrossDimDefined","isMainRowDirection","firstAbsoluteChild","currentAbsoluteChild","definedMainDim","startLine","endLine","alreadyComputedNextLayout","linesCrossDim","linesMainDim","linesCount","mainContentDim","flexibleChildrenCount","totalFlexible","nonFlexibleChildrenCount","isSimpleStackMain","CSS_JUSTIFY_FLEX_START","CSS_JUSTIFY_CENTER","firstComplexMain","isSimpleStackCross","firstComplexCross","firstFlexChild","currentFlexChild","mainDim","crossDim","lineIndex","nextAbsoluteChild","nextFlexChild","alignItem","CSS_ALIGN_STRETCH","CSS_POSITION_ABSOLUTE","nextContentDim","layoutNode","CSS_ALIGN_FLEX_START","leadingMainDim","betweenMainDim","remainingMainDim","baseMainDim","boundMainDim","flexibleMainDim","CSS_JUSTIFY_FLEX_END","CSS_JUSTIFY_SPACE_BETWEEN","CSS_JUSTIFY_SPACE_AROUND","containerCrossAxis","leadingCrossDim","remainingCrossDim","CSS_ALIGN_CENTER","nodeCrossAxisInnerSize","remainingAlignContentDim","crossDimLead","currentLead","CSS_ALIGN_FLEX_END","endIndex","startIndex","lineHeight","alignContentAlignItem","childHeight","needsMainTrailingPos","needsCrossTrailingPos","shouldUpdate","skipLayout","lastLayout","requestedHeight","requestedWidth","window","addEventListener","attachEvent","Window","HTMLDocument","Element","type","listener","removeEventListener","detachEvent","detect","document","createElement","display","error","documentElement","currentStyle","onresize","target","init","details","onlayoutcomplete","SECOND","FRAMES_PER_SECOND","event","nodeType","walk","offsetWidth","setTimeout","CSS_FLEX_CONTAINER_PROPERTIES","initial","valid","boxSizing","updateFlexContainerCache","getCSS","key","kabobKey","replace","toLowerCase","keyValue","cssValue","test","CSS_FLEX_ITEM_PROPERTIES","flexBasis","flexGrow","flexShrink","order","updateFlexItemCache","CSS_RESET_TEXT","CSS_BORDER_WIDTHS","medium","none","thick","thin","CSS_LENGTHS","updateLengthCache","parentNode","clonex","setCSS","runtimeStyle","cssText","fontSize","insertBefore","nextSibling","removeChild","borderTopStyle","borderRightStyle","borderBottomStyle","borderLeftStyle","originalWidth","originalHeight","offsetHeight","CSS_OVERFLOW_BUFFER","match","childNodes","childNode","childNodeIndex","childDetails","childStyle","push","sort","childA","childB","reverse","maxLength","maxIndex","angle"],"mappings":"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","file":"flexibility.js","sourcesContent":["/*! flexibility v1.0.0 | MIT Licensed | github.com/10up/flexibility */\n\nflexibility = {};\n","if (!Array.prototype.forEach) {\n\tArray.prototype.forEach = function forEach(callback) {\n\t\tif (this === undefined || this === null) {\n\t\t\tthrow new TypeError(this + 'is not an object');\n\t\t}\n\n\t\tif (!(callback instanceof Function)) {\n\t\t\tthrow new TypeError(callback + ' is not a function');\n\t\t}\n\n\t\tvar object = Object(this);\n\t\tvar scope = arguments[1];\n\t\tvar arraylike = object instanceof String ? object.split('') : object;\n\t\tvar length = Math.max(Math.min(arraylike.length, 9007199254740991), 0) || 0;\n\t\tvar index = -1;\n\n\t\twhile (++index < length) {\n\t\t\tif (index in arraylike) {\n\t\t\t\tcallback.call(scope, arraylike[index], index, object);\n\t\t\t}\n\t\t}\n\t};\n}\n","// UMD (Universal Module Definition)\n// See https://github.com/umdjs/umd for reference\n//\n// This file uses the following specific UMD implementation:\n// https://github.com/umdjs/umd/blob/master/returnExports.js\n(function(root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t} else if (typeof exports === 'object') {\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t} else {\n\t\t// Browser globals (root is window)\n\t\troot.computeLayout = factory();\n\t}\n}(flexibility, function() {\n\t/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar computeLayout = (function() {\n\n\tvar CSS_UNDEFINED;\n\n\tvar CSS_DIRECTION_INHERIT = 'inherit';\n\tvar CSS_DIRECTION_LTR = 'ltr';\n\tvar CSS_DIRECTION_RTL = 'rtl';\n\n\tvar CSS_FLEX_DIRECTION_ROW = 'row';\n\tvar CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';\n\tvar CSS_FLEX_DIRECTION_COLUMN = 'column';\n\tvar CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';\n\n\tvar CSS_JUSTIFY_FLEX_START = 'flex-start';\n\tvar CSS_JUSTIFY_CENTER = 'center';\n\tvar CSS_JUSTIFY_FLEX_END = 'flex-end';\n\tvar CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n\tvar CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n\tvar CSS_ALIGN_FLEX_START = 'flex-start';\n\tvar CSS_ALIGN_CENTER = 'center';\n\tvar CSS_ALIGN_FLEX_END = 'flex-end';\n\tvar CSS_ALIGN_STRETCH = 'stretch';\n\n\tvar CSS_POSITION_RELATIVE = 'relative';\n\tvar CSS_POSITION_ABSOLUTE = 'absolute';\n\n\tvar leading = {\n\t\t'row': 'left',\n\t\t'row-reverse': 'right',\n\t\t'column': 'top',\n\t\t'column-reverse': 'bottom'\n\t};\n\tvar trailing = {\n\t\t'row': 'right',\n\t\t'row-reverse': 'left',\n\t\t'column': 'bottom',\n\t\t'column-reverse': 'top'\n\t};\n\tvar pos = {\n\t\t'row': 'left',\n\t\t'row-reverse': 'right',\n\t\t'column': 'top',\n\t\t'column-reverse': 'bottom'\n\t};\n\tvar dim = {\n\t\t'row': 'width',\n\t\t'row-reverse': 'width',\n\t\t'column': 'height',\n\t\t'column-reverse': 'height'\n\t};\n\n\t// When transpiled to Java / C the node type has layout, children and style\n\t// properties. For the JavaScript version this function adds these properties\n\t// if they don't already exist.\n\tfunction fillNodes(node) {\n\t\tif (!node.layout || node.isDirty) {\n\t\t\tnode.layout = {\n\t\t\t\twidth: undefined,\n\t\t\t\theight: undefined,\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\tbottom: 0\n\t\t\t};\n\t\t}\n\n\t\tif (!node.style) {\n\t\t\tnode.style = {};\n\t\t}\n\n\t\tif (!node.children) {\n\t\t\tnode.children = [];\n\t\t}\n\n\t\tif (node.style.measure && node.children && node.children.length) {\n\t\t\tthrow new Error('Using custom measure function is supported only for leaf nodes.');\n\t\t}\n\n\t\tnode.children.forEach(fillNodes);\n\t\treturn node;\n\t}\n\n\tfunction isUndefined(value) {\n\t\treturn value === undefined;\n\t}\n\n\tfunction isRowDirection(flexDirection) {\n\t\treturn flexDirection === CSS_FLEX_DIRECTION_ROW ||\n\t\t\t\t\t flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;\n\t}\n\n\tfunction isColumnDirection(flexDirection) {\n\t\treturn flexDirection === CSS_FLEX_DIRECTION_COLUMN ||\n\t\t\t\t\t flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;\n\t}\n\n\tfunction getLeadingMargin(node, axis) {\n\t\tif (node.style.marginStart !== undefined && isRowDirection(axis)) {\n\t\t\treturn node.style.marginStart;\n\t\t}\n\n\t\tvar value = null;\n\t\tswitch (axis) {\n\t\t\tcase 'row':            value = node.style.marginLeft;   break;\n\t\t\tcase 'row-reverse':    value = node.style.marginRight;  break;\n\t\t\tcase 'column':         value = node.style.marginTop;    break;\n\t\t\tcase 'column-reverse': value = node.style.marginBottom; break;\n\t\t}\n\n\t\tif (value !== undefined) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (node.style.margin !== undefined) {\n\t\t\treturn node.style.margin;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getTrailingMargin(node, axis) {\n\t\tif (node.style.marginEnd !== undefined && isRowDirection(axis)) {\n\t\t\treturn node.style.marginEnd;\n\t\t}\n\n\t\tvar value = null;\n\t\tswitch (axis) {\n\t\t\tcase 'row':            value = node.style.marginRight;  break;\n\t\t\tcase 'row-reverse':    value = node.style.marginLeft;   break;\n\t\t\tcase 'column':         value = node.style.marginBottom; break;\n\t\t\tcase 'column-reverse': value = node.style.marginTop;    break;\n\t\t}\n\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (node.style.margin !== undefined) {\n\t\t\treturn node.style.margin;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getLeadingPadding(node, axis) {\n\t\tif (node.style.paddingStart !== undefined && node.style.paddingStart >= 0\n\t\t\t\t&& isRowDirection(axis)) {\n\t\t\treturn node.style.paddingStart;\n\t\t}\n\n\t\tvar value = null;\n\t\tswitch (axis) {\n\t\t\tcase 'row':            value = node.style.paddingLeft;   break;\n\t\t\tcase 'row-reverse':    value = node.style.paddingRight;  break;\n\t\t\tcase 'column':         value = node.style.paddingTop;    break;\n\t\t\tcase 'column-reverse': value = node.style.paddingBottom; break;\n\t\t}\n\n\t\tif (value != null && value >= 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (node.style.padding !== undefined && node.style.padding >= 0) {\n\t\t\treturn node.style.padding;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getTrailingPadding(node, axis) {\n\t\tif (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0\n\t\t\t\t&& isRowDirection(axis)) {\n\t\t\treturn node.style.paddingEnd;\n\t\t}\n\n\t\tvar value = null;\n\t\tswitch (axis) {\n\t\t\tcase 'row':            value = node.style.paddingRight;  break;\n\t\t\tcase 'row-reverse':    value = node.style.paddingLeft;   break;\n\t\t\tcase 'column':         value = node.style.paddingBottom; break;\n\t\t\tcase 'column-reverse': value = node.style.paddingTop;    break;\n\t\t}\n\n\t\tif (value != null && value >= 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (node.style.padding !== undefined && node.style.padding >= 0) {\n\t\t\treturn node.style.padding;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getLeadingBorder(node, axis) {\n\t\tif (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0\n\t\t\t\t&& isRowDirection(axis)) {\n\t\t\treturn node.style.borderStartWidth;\n\t\t}\n\n\t\tvar value = null;\n\t\tswitch (axis) {\n\t\t\tcase 'row':            value = node.style.borderLeftWidth;   break;\n\t\t\tcase 'row-reverse':    value = node.style.borderRightWidth;  break;\n\t\t\tcase 'column':         value = node.style.borderTopWidth;    break;\n\t\t\tcase 'column-reverse': value = node.style.borderBottomWidth; break;\n\t\t}\n\n\t\tif (value != null && value >= 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n\t\t\treturn node.style.borderWidth;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getTrailingBorder(node, axis) {\n\t\tif (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0\n\t\t\t\t&& isRowDirection(axis)) {\n\t\t\treturn node.style.borderEndWidth;\n\t\t}\n\n\t\tvar value = null;\n\t\tswitch (axis) {\n\t\t\tcase 'row':            value = node.style.borderRightWidth;  break;\n\t\t\tcase 'row-reverse':    value = node.style.borderLeftWidth;   break;\n\t\t\tcase 'column':         value = node.style.borderBottomWidth; break;\n\t\t\tcase 'column-reverse': value = node.style.borderTopWidth;    break;\n\t\t}\n\n\t\tif (value != null && value >= 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n\t\t\treturn node.style.borderWidth;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getLeadingPaddingAndBorder(node, axis) {\n\t\treturn getLeadingPadding(node, axis) + getLeadingBorder(node, axis);\n\t}\n\n\tfunction getTrailingPaddingAndBorder(node, axis) {\n\t\treturn getTrailingPadding(node, axis) + getTrailingBorder(node, axis);\n\t}\n\n\tfunction getBorderAxis(node, axis) {\n\t\treturn getLeadingBorder(node, axis) + getTrailingBorder(node, axis);\n\t}\n\n\tfunction getMarginAxis(node, axis) {\n\t\treturn getLeadingMargin(node, axis) + getTrailingMargin(node, axis);\n\t}\n\n\tfunction getPaddingAndBorderAxis(node, axis) {\n\t\treturn getLeadingPaddingAndBorder(node, axis) +\n\t\t\t\tgetTrailingPaddingAndBorder(node, axis);\n\t}\n\n\tfunction getJustifyContent(node) {\n\t\tif (node.style.justifyContent) {\n\t\t\treturn node.style.justifyContent;\n\t\t}\n\t\treturn 'flex-start';\n\t}\n\n\tfunction getAlignContent(node) {\n\t\tif (node.style.alignContent) {\n\t\t\treturn node.style.alignContent;\n\t\t}\n\t\treturn 'flex-start';\n\t}\n\n\tfunction getAlignItem(node, child) {\n\t\tif (child.style.alignSelf) {\n\t\t\treturn child.style.alignSelf;\n\t\t}\n\t\tif (node.style.alignItems) {\n\t\t\treturn node.style.alignItems;\n\t\t}\n\t\treturn 'stretch';\n\t}\n\n\tfunction resolveAxis(axis, direction) {\n\t\tif (direction === CSS_DIRECTION_RTL) {\n\t\t\tif (axis === CSS_FLEX_DIRECTION_ROW) {\n\t\t\t\treturn CSS_FLEX_DIRECTION_ROW_REVERSE;\n\t\t\t} else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {\n\t\t\t\treturn CSS_FLEX_DIRECTION_ROW;\n\t\t\t}\n\t\t}\n\n\t\treturn axis;\n\t}\n\n\tfunction resolveDirection(node, parentDirection) {\n\t\tvar direction;\n\t\tif (node.style.direction) {\n\t\t\tdirection = node.style.direction;\n\t\t} else {\n\t\t\tdirection = CSS_DIRECTION_INHERIT;\n\t\t}\n\n\t\tif (direction === CSS_DIRECTION_INHERIT) {\n\t\t\tdirection = (parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection);\n\t\t}\n\n\t\treturn direction;\n\t}\n\n\tfunction getFlexDirection(node) {\n\t\tif (node.style.flexDirection) {\n\t\t\treturn node.style.flexDirection;\n\t\t}\n\t\treturn CSS_FLEX_DIRECTION_COLUMN;\n\t}\n\n\tfunction getCrossFlexDirection(flexDirection, direction) {\n\t\tif (isColumnDirection(flexDirection)) {\n\t\t\treturn resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n\t\t} else {\n\t\t\treturn CSS_FLEX_DIRECTION_COLUMN;\n\t\t}\n\t}\n\n\tfunction getPositionType(node) {\n\t\tif (node.style.position) {\n\t\t\treturn node.style.position;\n\t\t}\n\t\treturn 'relative';\n\t}\n\n\tfunction isFlex(node) {\n\t\treturn (\n\t\t\tgetPositionType(node) === CSS_POSITION_RELATIVE &&\n\t\t\tnode.style.flex > 0\n\t\t);\n\t}\n\n\tfunction isFlexWrap(node) {\n\t\treturn node.style.flexWrap === 'wrap';\n\t}\n\n\tfunction getDimWithMargin(node, axis) {\n\t\treturn node.layout[dim[axis]] + getMarginAxis(node, axis);\n\t}\n\n\tfunction isDimDefined(node, axis) {\n\t\treturn node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;\n\t}\n\n\tfunction isPosDefined(node, pos) {\n\t\treturn node.style[pos] !== undefined;\n\t}\n\n\tfunction isMeasureDefined(node) {\n\t\treturn node.style.measure !== undefined;\n\t}\n\n\tfunction getPosition(node, pos) {\n\t\tif (node.style[pos] !== undefined) {\n\t\t\treturn node.style[pos];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction boundAxis(node, axis, value) {\n\t\tvar min = {\n\t\t\t'row': node.style.minWidth,\n\t\t\t'row-reverse': node.style.minWidth,\n\t\t\t'column': node.style.minHeight,\n\t\t\t'column-reverse': node.style.minHeight\n\t\t}[axis];\n\n\t\tvar max = {\n\t\t\t'row': node.style.maxWidth,\n\t\t\t'row-reverse': node.style.maxWidth,\n\t\t\t'column': node.style.maxHeight,\n\t\t\t'column-reverse': node.style.maxHeight\n\t\t}[axis];\n\n\t\tvar boundValue = value;\n\t\tif (max !== undefined && max >= 0 && boundValue > max) {\n\t\t\tboundValue = max;\n\t\t}\n\t\tif (min !== undefined && min >= 0 && boundValue < min) {\n\t\t\tboundValue = min;\n\t\t}\n\t\treturn boundValue;\n\t}\n\n\tfunction fmaxf(a, b) {\n\t\tif (a > b) {\n\t\t\treturn a;\n\t\t}\n\t\treturn b;\n\t}\n\n\t// When the user specifically sets a value for width or height\n\tfunction setDimensionFromStyle(node, axis) {\n\t\t// The parent already computed us a width or height. We just skip it\n\t\tif (node.layout[dim[axis]] !== undefined) {\n\t\t\treturn;\n\t\t}\n\t\t// We only run if there's a width or height defined\n\t\tif (!isDimDefined(node, axis)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The dimensions can never be smaller than the padding and border\n\t\tnode.layout[dim[axis]] = fmaxf(\n\t\t\tboundAxis(node, axis, node.style[dim[axis]]),\n\t\t\tgetPaddingAndBorderAxis(node, axis)\n\t\t);\n\t}\n\n\tfunction setTrailingPosition(node, child, axis) {\n\t\tchild.layout[trailing[axis]] = node.layout[dim[axis]] -\n\t\t\t\tchild.layout[dim[axis]] - child.layout[pos[axis]];\n\t}\n\n\t// If both left and right are defined, then use left. Otherwise return\n\t// +left or -right depending on which is defined.\n\tfunction getRelativePosition(node, axis) {\n\t\tif (node.style[leading[axis]] !== undefined) {\n\t\t\treturn getPosition(node, leading[axis]);\n\t\t}\n\t\treturn -getPosition(node, trailing[axis]);\n\t}\n\n\tfunction layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, /*css_direction_t*/parentDirection) {\n\t\tvar/*css_direction_t*/ direction = resolveDirection(node, parentDirection);\n\t\tvar/*(c)!css_flex_direction_t*//*(java)!int*/ mainAxis = resolveAxis(getFlexDirection(node), direction);\n\t\tvar/*(c)!css_flex_direction_t*//*(java)!int*/ crossAxis = getCrossFlexDirection(mainAxis, direction);\n\t\tvar/*(c)!css_flex_direction_t*//*(java)!int*/ resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n\n\t\t// Handle width and height style attributes\n\t\tsetDimensionFromStyle(node, mainAxis);\n\t\tsetDimensionFromStyle(node, crossAxis);\n\n\t\t// Set the resolved resolution in the node's layout\n\t\tnode.layout.direction = direction;\n\n\t\t// The position is set by the parent, but we need to complete it with a\n\t\t// delta composed of the margin and left/top/right/bottom\n\t\tnode.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) +\n\t\t\tgetRelativePosition(node, mainAxis);\n\t\tnode.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) +\n\t\t\tgetRelativePosition(node, mainAxis);\n\t\tnode.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) +\n\t\t\tgetRelativePosition(node, crossAxis);\n\t\tnode.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) +\n\t\t\tgetRelativePosition(node, crossAxis);\n\n\t\t// Inline immutable values from the target node to avoid excessive method\n\t\t// invocations during the layout calculation.\n\t\tvar/*int*/ childCount = node.children.length;\n\t\tvar/*float*/ paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);\n\t\tvar/*float*/ paddingAndBorderAxisColumn = getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n\n\t\tif (isMeasureDefined(node)) {\n\t\t\tvar/*bool*/ isResolvedRowDimDefined = !isUndefined(node.layout[dim[resolvedRowAxis]]);\n\n\t\t\tvar/*float*/ width = CSS_UNDEFINED;\n\t\t\tif (isDimDefined(node, resolvedRowAxis)) {\n\t\t\t\twidth = node.style.width;\n\t\t\t} else if (isResolvedRowDimDefined) {\n\t\t\t\twidth = node.layout[dim[resolvedRowAxis]];\n\t\t\t} else {\n\t\t\t\twidth = parentMaxWidth -\n\t\t\t\t\tgetMarginAxis(node, resolvedRowAxis);\n\t\t\t}\n\t\t\twidth -= paddingAndBorderAxisResolvedRow;\n\n\t\t\tvar/*float*/ height = CSS_UNDEFINED;\n\t\t\tif (isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n\t\t\t\theight = node.style.height;\n\t\t\t} else if (!isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]])) {\n\t\t\t\theight = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]];\n\t\t\t} else {\n\t\t\t\theight = parentMaxHeight -\n\t\t\t\t\tgetMarginAxis(node, resolvedRowAxis);\n\t\t\t}\n\t\t\theight -= getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n\n\t\t\t// We only need to give a dimension for the text if we haven't got any\n\t\t\t// for it computed yet. It can either be from the style attribute or because\n\t\t\t// the element is flexible.\n\t\t\tvar/*bool*/ isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;\n\t\t\tvar/*bool*/ isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\n\t\t\t\tisUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\n\n\t\t\t// Let's not measure the text if we already know both dimensions\n\t\t\tif (isRowUndefined || isColumnUndefined) {\n\t\t\t\tvar/*css_dim_t*/ measureDim = node.style.measure(\n\t\t\t\t\t/*(c)!node->context,*/\n\t\t\t\t\t/*(java)!layoutContext.measureOutput,*/\n\t\t\t\t\twidth,\n\t\t\t\t\theight\n\t\t\t\t);\n\t\t\t\tif (isRowUndefined) {\n\t\t\t\t\tnode.layout.width = measureDim.width +\n\t\t\t\t\t\tpaddingAndBorderAxisResolvedRow;\n\t\t\t\t}\n\t\t\t\tif (isColumnUndefined) {\n\t\t\t\t\tnode.layout.height = measureDim.height +\n\t\t\t\t\t\tpaddingAndBorderAxisColumn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (childCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tvar/*bool*/ isNodeFlexWrap = isFlexWrap(node);\n\n\t\tvar/*css_justify_t*/ justifyContent = getJustifyContent(node);\n\n\t\tvar/*float*/ leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);\n\t\tvar/*float*/ leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);\n\t\tvar/*float*/ paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);\n\t\tvar/*float*/ paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);\n\n\t\tvar/*bool*/ isMainDimDefined = !isUndefined(node.layout[dim[mainAxis]]);\n\t\tvar/*bool*/ isCrossDimDefined = !isUndefined(node.layout[dim[crossAxis]]);\n\t\tvar/*bool*/ isMainRowDirection = isRowDirection(mainAxis);\n\n\t\tvar/*int*/ i;\n\t\tvar/*int*/ ii;\n\t\tvar/*css_node_t**/ child;\n\t\tvar/*(c)!css_flex_direction_t*//*(java)!int*/ axis;\n\n\t\tvar/*css_node_t**/ firstAbsoluteChild = null;\n\t\tvar/*css_node_t**/ currentAbsoluteChild = null;\n\n\t\tvar/*float*/ definedMainDim = CSS_UNDEFINED;\n\t\tif (isMainDimDefined) {\n\t\t\tdefinedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;\n\t\t}\n\n\t\t// We want to execute the next two loops one per line with flex-wrap\n\t\tvar/*int*/ startLine = 0;\n\t\tvar/*int*/ endLine = 0;\n\t\t// var/*int*/ nextOffset = 0;\n\t\tvar/*int*/ alreadyComputedNextLayout = 0;\n\t\t// We aggregate the total dimensions of the container in those two variables\n\t\tvar/*float*/ linesCrossDim = 0;\n\t\tvar/*float*/ linesMainDim = 0;\n\t\tvar/*int*/ linesCount = 0;\n\t\twhile (endLine < childCount) {\n\t\t\t// <Loop A> Layout non flexible children and count children by type\n\n\t\t\t// mainContentDim is accumulation of the dimensions and margin of all the\n\t\t\t// non flexible children. This will be used in order to either set the\n\t\t\t// dimensions of the node if none already exist, or to compute the\n\t\t\t// remaining space left for the flexible children.\n\t\t\tvar/*float*/ mainContentDim = 0;\n\n\t\t\t// There are three kind of children, non flexible, flexible and absolute.\n\t\t\t// We need to know how many there are in order to distribute the space.\n\t\t\tvar/*int*/ flexibleChildrenCount = 0;\n\t\t\tvar/*float*/ totalFlexible = 0;\n\t\t\tvar/*int*/ nonFlexibleChildrenCount = 0;\n\n\t\t\t// Use the line loop to position children in the main axis for as long\n\t\t\t// as they are using a simple stacking behaviour. Children that are\n\t\t\t// immediately stacked in the initial loop will not be touched again\n\t\t\t// in <Loop C>.\n\t\t\tvar/*bool*/ isSimpleStackMain =\n\t\t\t\t\t(isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START) ||\n\t\t\t\t\t(!isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER);\n\t\t\tvar/*int*/ firstComplexMain = (isSimpleStackMain ? childCount : startLine);\n\n\t\t\t// Use the initial line loop to position children in the cross axis for\n\t\t\t// as long as they are relatively positioned with alignment STRETCH or\n\t\t\t// FLEX_START. Children that are immediately stacked in the initial loop\n\t\t\t// will not be touched again in <Loop D>.\n\t\t\tvar/*bool*/ isSimpleStackCross = true;\n\t\t\tvar/*int*/ firstComplexCross = childCount;\n\n\t\t\tvar/*css_node_t**/ firstFlexChild = null;\n\t\t\tvar/*css_node_t**/ currentFlexChild = null;\n\n\t\t\tvar/*float*/ mainDim = leadingPaddingAndBorderMain;\n\t\t\tvar/*float*/ crossDim = 0;\n\n\t\t\tvar/*float*/ maxWidth;\n\t\t\tvar/*float*/ maxHeight;\n\t\t\tfor (i = startLine; i < childCount; ++i) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tchild.lineIndex = linesCount;\n\n\t\t\t\tchild.nextAbsoluteChild = null;\n\t\t\t\tchild.nextFlexChild = null;\n\n\t\t\t\tvar/*css_align_t*/ alignItem = getAlignItem(node, child);\n\n\t\t\t\t// Pre-fill cross axis dimensions when the child is using stretch before\n\t\t\t\t// we call the recursive layout pass\n\t\t\t\tif (alignItem === CSS_ALIGN_STRETCH &&\n\t\t\t\t\t\tgetPositionType(child) === CSS_POSITION_RELATIVE &&\n\t\t\t\t\t\tisCrossDimDefined &&\n\t\t\t\t\t\t!isDimDefined(child, crossAxis)) {\n\t\t\t\t\tchild.layout[dim[crossAxis]] = fmaxf(\n\t\t\t\t\t\tboundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\n\t\t\t\t\t\t\tpaddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n\t\t\t\t\t\t// You never want to go smaller than padding\n\t\t\t\t\t\tgetPaddingAndBorderAxis(child, crossAxis)\n\t\t\t\t\t);\n\t\t\t\t} else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n\t\t\t\t\t// Store a private linked list of absolutely positioned children\n\t\t\t\t\t// so that we can efficiently traverse them later.\n\t\t\t\t\tif (firstAbsoluteChild === null) {\n\t\t\t\t\t\tfirstAbsoluteChild = child;\n\t\t\t\t\t}\n\t\t\t\t\tif (currentAbsoluteChild !== null) {\n\t\t\t\t\t\tcurrentAbsoluteChild.nextAbsoluteChild = child;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentAbsoluteChild = child;\n\n\t\t\t\t\t// Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n\t\t\t\t\t// left and right or top and bottom).\n\t\t\t\t\tfor (ii = 0; ii < 2; ii++) {\n\t\t\t\t\t\taxis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\t\t\t\t\t\tif (!isUndefined(node.layout[dim[axis]]) &&\n\t\t\t\t\t\t\t\t!isDimDefined(child, axis) &&\n\t\t\t\t\t\t\t\tisPosDefined(child, leading[axis]) &&\n\t\t\t\t\t\t\t\tisPosDefined(child, trailing[axis])) {\n\t\t\t\t\t\t\tchild.layout[dim[axis]] = fmaxf(\n\t\t\t\t\t\t\t\tboundAxis(child, axis, node.layout[dim[axis]] -\n\t\t\t\t\t\t\t\t\tgetPaddingAndBorderAxis(node, axis) -\n\t\t\t\t\t\t\t\t\tgetMarginAxis(child, axis) -\n\t\t\t\t\t\t\t\t\tgetPosition(child, leading[axis]) -\n\t\t\t\t\t\t\t\t\tgetPosition(child, trailing[axis])),\n\t\t\t\t\t\t\t\t// You never want to go smaller than padding\n\t\t\t\t\t\t\t\tgetPaddingAndBorderAxis(child, axis)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar/*float*/ nextContentDim = 0;\n\n\t\t\t\t// It only makes sense to consider a child flexible if we have a computed\n\t\t\t\t// dimension for the node.\n\t\t\t\tif (isMainDimDefined && isFlex(child)) {\n\t\t\t\t\tflexibleChildrenCount++;\n\t\t\t\t\ttotalFlexible += child.style.flex;\n\n\t\t\t\t\t// Store a private linked list of flexible children so that we can\n\t\t\t\t\t// efficiently traverse them later.\n\t\t\t\t\tif (firstFlexChild === null) {\n\t\t\t\t\t\tfirstFlexChild = child;\n\t\t\t\t\t}\n\t\t\t\t\tif (currentFlexChild !== null) {\n\t\t\t\t\t\tcurrentFlexChild.nextFlexChild = child;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentFlexChild = child;\n\n\t\t\t\t\t// Even if we don't know its exact size yet, we already know the padding,\n\t\t\t\t\t// border and margin. We'll use this partial information, which represents\n\t\t\t\t\t// the smallest possible size for the child, to compute the remaining\n\t\t\t\t\t// available space.\n\t\t\t\t\tnextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\n\t\t\t\t\t\tgetMarginAxis(child, mainAxis);\n\n\t\t\t\t} else {\n\t\t\t\t\tmaxWidth = CSS_UNDEFINED;\n\t\t\t\t\tmaxHeight = CSS_UNDEFINED;\n\n\t\t\t\t\tif (!isMainRowDirection) {\n\t\t\t\t\t\tif (isDimDefined(node, resolvedRowAxis)) {\n\t\t\t\t\t\t\tmaxWidth = node.layout[dim[resolvedRowAxis]] -\n\t\t\t\t\t\t\t\tpaddingAndBorderAxisResolvedRow;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxWidth = parentMaxWidth -\n\t\t\t\t\t\t\t\tgetMarginAxis(node, resolvedRowAxis) -\n\t\t\t\t\t\t\t\tpaddingAndBorderAxisResolvedRow;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n\t\t\t\t\t\t\tmaxHeight = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n\t\t\t\t\t\t\t\t\tpaddingAndBorderAxisColumn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxHeight = parentMaxHeight -\n\t\t\t\t\t\t\t\tgetMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -\n\t\t\t\t\t\t\t\tpaddingAndBorderAxisColumn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// This is the main recursive call. We layout non flexible children.\n\t\t\t\t\tif (alreadyComputedNextLayout === 0) {\n\t\t\t\t\t\tlayoutNode(/*(java)!layoutContext, */child, maxWidth, maxHeight, direction);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Absolute positioned elements do not take part of the layout, so we\n\t\t\t\t\t// don't use them to compute mainContentDim\n\t\t\t\t\tif (getPositionType(child) === CSS_POSITION_RELATIVE) {\n\t\t\t\t\t\tnonFlexibleChildrenCount++;\n\t\t\t\t\t\t// At this point we know the final size and margin of the element.\n\t\t\t\t\t\tnextContentDim = getDimWithMargin(child, mainAxis);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// The element we are about to add would make us go to the next line\n\t\t\t\tif (isNodeFlexWrap &&\n\t\t\t\t\t\tisMainDimDefined &&\n\t\t\t\t\t\tmainContentDim + nextContentDim > definedMainDim &&\n\t\t\t\t\t\t// If there's only one element, then it's bigger than the content\n\t\t\t\t\t\t// and needs its own line\n\t\t\t\t\t\ti !== startLine) {\n\t\t\t\t\tnonFlexibleChildrenCount--;\n\t\t\t\t\talreadyComputedNextLayout = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Disable simple stacking in the main axis for the current line as\n\t\t\t\t// we found a non-trivial child. The remaining children will be laid out\n\t\t\t\t// in <Loop C>.\n\t\t\t\tif (isSimpleStackMain &&\n\t\t\t\t\t\t(getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {\n\t\t\t\t\tisSimpleStackMain = false;\n\t\t\t\t\tfirstComplexMain = i;\n\t\t\t\t}\n\n\t\t\t\t// Disable simple stacking in the cross axis for the current line as\n\t\t\t\t// we found a non-trivial child. The remaining children will be laid out\n\t\t\t\t// in <Loop D>.\n\t\t\t\tif (isSimpleStackCross &&\n\t\t\t\t\t\t(getPositionType(child) !== CSS_POSITION_RELATIVE ||\n\t\t\t\t\t\t\t\t(alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START) ||\n\t\t\t\t\t\t\t\tisUndefined(child.layout[dim[crossAxis]]))) {\n\t\t\t\t\tisSimpleStackCross = false;\n\t\t\t\t\tfirstComplexCross = i;\n\t\t\t\t}\n\n\t\t\t\tif (isSimpleStackMain) {\n\t\t\t\t\tchild.layout[pos[mainAxis]] += mainDim;\n\t\t\t\t\tif (isMainDimDefined) {\n\t\t\t\t\t\tsetTrailingPosition(node, child, mainAxis);\n\t\t\t\t\t}\n\n\t\t\t\t\tmainDim += getDimWithMargin(child, mainAxis);\n\t\t\t\t\tcrossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n\t\t\t\t}\n\n\t\t\t\tif (isSimpleStackCross) {\n\t\t\t\t\tchild.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;\n\t\t\t\t\tif (isCrossDimDefined) {\n\t\t\t\t\t\tsetTrailingPosition(node, child, crossAxis);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\talreadyComputedNextLayout = 0;\n\t\t\t\tmainContentDim += nextContentDim;\n\t\t\t\tendLine = i + 1;\n\t\t\t}\n\n\t\t\t// <Loop B> Layout flexible children and allocate empty space\n\n\t\t\t// In order to position the elements in the main axis, we have two\n\t\t\t// controls. The space between the beginning and the first element\n\t\t\t// and the space between each two elements.\n\t\t\tvar/*float*/ leadingMainDim = 0;\n\t\t\tvar/*float*/ betweenMainDim = 0;\n\n\t\t\t// The remaining available space that needs to be allocated\n\t\t\tvar/*float*/ remainingMainDim = 0;\n\t\t\tif (isMainDimDefined) {\n\t\t\t\tremainingMainDim = definedMainDim - mainContentDim;\n\t\t\t} else {\n\t\t\t\tremainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n\t\t\t}\n\n\t\t\t// If there are flexible children in the mix, they are going to fill the\n\t\t\t// remaining space\n\t\t\tif (flexibleChildrenCount !== 0) {\n\t\t\t\tvar/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\n\t\t\t\tvar/*float*/ baseMainDim;\n\t\t\t\tvar/*float*/ boundMainDim;\n\n\t\t\t\t// If the flex share of remaining space doesn't meet min/max bounds,\n\t\t\t\t// remove this child from flex calculations.\n\t\t\t\tcurrentFlexChild = firstFlexChild;\n\t\t\t\twhile (currentFlexChild !== null) {\n\t\t\t\t\tbaseMainDim = flexibleMainDim * currentFlexChild.style.flex +\n\t\t\t\t\t\t\tgetPaddingAndBorderAxis(currentFlexChild, mainAxis);\n\t\t\t\t\tboundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);\n\n\t\t\t\t\tif (baseMainDim !== boundMainDim) {\n\t\t\t\t\t\tremainingMainDim -= boundMainDim;\n\t\t\t\t\t\ttotalFlexible -= currentFlexChild.style.flex;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentFlexChild = currentFlexChild.nextFlexChild;\n\t\t\t\t}\n\t\t\t\tflexibleMainDim = remainingMainDim / totalFlexible;\n\n\t\t\t\t// The non flexible children can overflow the container, in this case\n\t\t\t\t// we should just assume that there is no space available.\n\t\t\t\tif (flexibleMainDim < 0) {\n\t\t\t\t\tflexibleMainDim = 0;\n\t\t\t\t}\n\n\t\t\t\tcurrentFlexChild = firstFlexChild;\n\t\t\t\twhile (currentFlexChild !== null) {\n\t\t\t\t\t// At this point we know the final size of the element in the main\n\t\t\t\t\t// dimension\n\t\t\t\t\tcurrentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,\n\t\t\t\t\t\tflexibleMainDim * currentFlexChild.style.flex +\n\t\t\t\t\t\t\t\tgetPaddingAndBorderAxis(currentFlexChild, mainAxis)\n\t\t\t\t\t);\n\n\t\t\t\t\tmaxWidth = CSS_UNDEFINED;\n\t\t\t\t\tif (isDimDefined(node, resolvedRowAxis)) {\n\t\t\t\t\t\tmaxWidth = node.layout[dim[resolvedRowAxis]] -\n\t\t\t\t\t\t\tpaddingAndBorderAxisResolvedRow;\n\t\t\t\t\t} else if (!isMainRowDirection) {\n\t\t\t\t\t\tmaxWidth = parentMaxWidth -\n\t\t\t\t\t\t\tgetMarginAxis(node, resolvedRowAxis) -\n\t\t\t\t\t\t\tpaddingAndBorderAxisResolvedRow;\n\t\t\t\t\t}\n\t\t\t\t\tmaxHeight = CSS_UNDEFINED;\n\t\t\t\t\tif (isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n\t\t\t\t\t\tmaxHeight = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n\t\t\t\t\t\t\tpaddingAndBorderAxisColumn;\n\t\t\t\t\t} else if (isMainRowDirection) {\n\t\t\t\t\t\tmaxHeight = parentMaxHeight -\n\t\t\t\t\t\t\tgetMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -\n\t\t\t\t\t\t\tpaddingAndBorderAxisColumn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// And we recursively call the layout algorithm for this child\n\t\t\t\t\tlayoutNode(/*(java)!layoutContext, */currentFlexChild, maxWidth, maxHeight, direction);\n\n\t\t\t\t\tchild = currentFlexChild;\n\t\t\t\t\tcurrentFlexChild = currentFlexChild.nextFlexChild;\n\t\t\t\t\tchild.nextFlexChild = null;\n\t\t\t\t}\n\n\t\t\t// We use justifyContent to figure out how to allocate the remaining\n\t\t\t// space available\n\t\t\t} else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {\n\t\t\t\tif (justifyContent === CSS_JUSTIFY_CENTER) {\n\t\t\t\t\tleadingMainDim = remainingMainDim / 2;\n\t\t\t\t} else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n\t\t\t\t\tleadingMainDim = remainingMainDim;\n\t\t\t\t} else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n\t\t\t\t\tremainingMainDim = fmaxf(remainingMainDim, 0);\n\t\t\t\t\tif (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n\t\t\t\t\t\tbetweenMainDim = remainingMainDim /\n\t\t\t\t\t\t\t(flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbetweenMainDim = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n\t\t\t\t\t// Space on the edges is half of the space between elements\n\t\t\t\t\tbetweenMainDim = remainingMainDim /\n\t\t\t\t\t\t(flexibleChildrenCount + nonFlexibleChildrenCount);\n\t\t\t\t\tleadingMainDim = betweenMainDim / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// <Loop C> Position elements in the main axis and compute dimensions\n\n\t\t\t// At this point, all the children have their dimensions set. We need to\n\t\t\t// find their position. In order to do that, we accumulate data in\n\t\t\t// variables that are also useful to compute the total dimensions of the\n\t\t\t// container!\n\t\t\tmainDim += leadingMainDim;\n\n\t\t\tfor (i = firstComplexMain; i < endLine; ++i) {\n\t\t\t\tchild = node.children[i];\n\n\t\t\t\tif (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n\t\t\t\t\t\tisPosDefined(child, leading[mainAxis])) {\n\t\t\t\t\t// In case the child is position absolute and has left/top being\n\t\t\t\t\t// defined, we override the position to whatever the user said\n\t\t\t\t\t// (and margin/border).\n\t\t\t\t\tchild.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\n\t\t\t\t\t\tgetLeadingBorder(node, mainAxis) +\n\t\t\t\t\t\tgetLeadingMargin(child, mainAxis);\n\t\t\t\t} else {\n\t\t\t\t\t// If the child is position absolute (without top/left) or relative,\n\t\t\t\t\t// we put it at the current accumulated offset.\n\t\t\t\t\tchild.layout[pos[mainAxis]] += mainDim;\n\n\t\t\t\t\t// Define the trailing position accordingly.\n\t\t\t\t\tif (isMainDimDefined) {\n\t\t\t\t\t\tsetTrailingPosition(node, child, mainAxis);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now that we placed the element, we need to update the variables\n\t\t\t\t\t// We only need to do that for relative elements. Absolute elements\n\t\t\t\t\t// do not take part in that phase.\n\t\t\t\t\tif (getPositionType(child) === CSS_POSITION_RELATIVE) {\n\t\t\t\t\t\t// The main dimension is the sum of all the elements dimension plus\n\t\t\t\t\t\t// the spacing.\n\t\t\t\t\t\tmainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n\t\t\t\t\t\t// The cross dimension is the max of the elements dimension since there\n\t\t\t\t\t\t// can only be one element in that cross dimension.\n\t\t\t\t\t\tcrossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\n\t\t\tif (!isCrossDimDefined) {\n\t\t\t\tcontainerCrossAxis = fmaxf(\n\t\t\t\t\t// For the cross dim, we add both sides at the end because the value\n\t\t\t\t\t// is aggregate via a max function. Intermediate negative values\n\t\t\t\t\t// can mess this computation otherwise\n\t\t\t\t\tboundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),\n\t\t\t\t\tpaddingAndBorderAxisCross\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// <Loop D> Position elements in the cross axis\n\t\t\tfor (i = firstComplexCross; i < endLine; ++i) {\n\t\t\t\tchild = node.children[i];\n\n\t\t\t\tif (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n\t\t\t\t\t\tisPosDefined(child, leading[crossAxis])) {\n\t\t\t\t\t// In case the child is absolutely positionned and has a\n\t\t\t\t\t// top/left/bottom/right being set, we override all the previously\n\t\t\t\t\t// computed positions to set it correctly.\n\t\t\t\t\tchild.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\n\t\t\t\t\t\tgetLeadingBorder(node, crossAxis) +\n\t\t\t\t\t\tgetLeadingMargin(child, crossAxis);\n\n\t\t\t\t} else {\n\t\t\t\t\tvar/*float*/ leadingCrossDim = leadingPaddingAndBorderCross;\n\n\t\t\t\t\t// For a relative children, we're either using alignItems (parent) or\n\t\t\t\t\t// alignSelf (child) in order to determine the position in the cross axis\n\t\t\t\t\tif (getPositionType(child) === CSS_POSITION_RELATIVE) {\n\t\t\t\t\t\t/*eslint-disable */\n\t\t\t\t\t\t// This variable is intentionally re-defined as the code is transpiled to a block scope language\n\t\t\t\t\t\tvar/*css_align_t*/ alignItem = getAlignItem(node, child);\n\t\t\t\t\t\t/*eslint-enable */\n\t\t\t\t\t\tif (alignItem === CSS_ALIGN_STRETCH) {\n\t\t\t\t\t\t\t// You can only stretch if the dimension has not already been set\n\t\t\t\t\t\t\t// previously.\n\t\t\t\t\t\t\tif (isUndefined(child.layout[dim[crossAxis]])) {\n\t\t\t\t\t\t\t\tchild.layout[dim[crossAxis]] = fmaxf(\n\t\t\t\t\t\t\t\t\tboundAxis(child, crossAxis, containerCrossAxis -\n\t\t\t\t\t\t\t\t\t\tpaddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n\t\t\t\t\t\t\t\t\t// You never want to go smaller than padding\n\t\t\t\t\t\t\t\t\tgetPaddingAndBorderAxis(child, crossAxis)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (alignItem !== CSS_ALIGN_FLEX_START) {\n\t\t\t\t\t\t\t// The remaining space between the parent dimensions+padding and child\n\t\t\t\t\t\t\t// dimensions+margin.\n\t\t\t\t\t\t\tvar/*float*/ remainingCrossDim = containerCrossAxis -\n\t\t\t\t\t\t\t\tpaddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);\n\n\t\t\t\t\t\t\tif (alignItem === CSS_ALIGN_CENTER) {\n\t\t\t\t\t\t\t\tleadingCrossDim += remainingCrossDim / 2;\n\t\t\t\t\t\t\t} else { // CSS_ALIGN_FLEX_END\n\t\t\t\t\t\t\t\tleadingCrossDim += remainingCrossDim;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// And we apply the position\n\t\t\t\t\tchild.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n\n\t\t\t\t\t// Define the trailing position accordingly.\n\t\t\t\t\tif (isCrossDimDefined) {\n\t\t\t\t\t\tsetTrailingPosition(node, child, crossAxis);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlinesCrossDim += crossDim;\n\t\t\tlinesMainDim = fmaxf(linesMainDim, mainDim);\n\t\t\tlinesCount += 1;\n\t\t\tstartLine = endLine;\n\t\t}\n\n\t\t// <Loop E>\n\t\t//\n\t\t// Note(prenaux): More than one line, we need to layout the crossAxis\n\t\t// according to alignContent.\n\t\t//\n\t\t// Note that we could probably remove <Loop D> and handle the one line case\n\t\t// here too, but for the moment this is safer since it won't interfere with\n\t\t// previously working code.\n\t\t//\n\t\t// See specs:\n\t\t// http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm\n\t\t// section 9.4\n\t\t//\n\t\tif (linesCount > 1 && isCrossDimDefined) {\n\t\t\tvar/*float*/ nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] -\n\t\t\t\t\tpaddingAndBorderAxisCross;\n\t\t\tvar/*float*/ remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;\n\n\t\t\tvar/*float*/ crossDimLead = 0;\n\t\t\tvar/*float*/ currentLead = leadingPaddingAndBorderCross;\n\n\t\t\tvar/*css_align_t*/ alignContent = getAlignContent(node);\n\t\t\tif (alignContent === CSS_ALIGN_FLEX_END) {\n\t\t\t\tcurrentLead += remainingAlignContentDim;\n\t\t\t} else if (alignContent === CSS_ALIGN_CENTER) {\n\t\t\t\tcurrentLead += remainingAlignContentDim / 2;\n\t\t\t} else if (alignContent === CSS_ALIGN_STRETCH) {\n\t\t\t\tif (nodeCrossAxisInnerSize > linesCrossDim) {\n\t\t\t\t\tcrossDimLead = (remainingAlignContentDim / linesCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar/*int*/ endIndex = 0;\n\t\t\tfor (i = 0; i < linesCount; ++i) {\n\t\t\t\tvar/*int*/ startIndex = endIndex;\n\n\t\t\t\t// compute the line's height and find the endIndex\n\t\t\t\tvar/*float*/ lineHeight = 0;\n\t\t\t\tfor (ii = startIndex; ii < childCount; ++ii) {\n\t\t\t\t\tchild = node.children[ii];\n\t\t\t\t\tif (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (child.lineIndex !== i) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isUndefined(child.layout[dim[crossAxis]])) {\n\t\t\t\t\t\tlineHeight = fmaxf(\n\t\t\t\t\t\t\tlineHeight,\n\t\t\t\t\t\t\tchild.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tendIndex = ii;\n\t\t\t\tlineHeight += crossDimLead;\n\n\t\t\t\tfor (ii = startIndex; ii < endIndex; ++ii) {\n\t\t\t\t\tchild = node.children[ii];\n\t\t\t\t\tif (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar/*css_align_t*/ alignContentAlignItem = getAlignItem(node, child);\n\t\t\t\t\tif (alignContentAlignItem === CSS_ALIGN_FLEX_START) {\n\t\t\t\t\t\tchild.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n\t\t\t\t\t} else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {\n\t\t\t\t\t\tchild.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];\n\t\t\t\t\t} else if (alignContentAlignItem === CSS_ALIGN_CENTER) {\n\t\t\t\t\t\tvar/*float*/ childHeight = child.layout[dim[crossAxis]];\n\t\t\t\t\t\tchild.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n\t\t\t\t\t} else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {\n\t\t\t\t\t\tchild.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n\t\t\t\t\t\t// TODO(prenaux): Correctly set the height of items with undefined\n\t\t\t\t\t\t//                (auto) crossAxis dimension.\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentLead += lineHeight;\n\t\t\t}\n\t\t}\n\n\t\tvar/*bool*/ needsMainTrailingPos = false;\n\t\tvar/*bool*/ needsCrossTrailingPos = false;\n\n\t\t// If the user didn't specify a width or height, and it has not been set\n\t\t// by the container, then we set it via the children.\n\t\tif (!isMainDimDefined) {\n\t\t\tnode.layout[dim[mainAxis]] = fmaxf(\n\t\t\t\t// We're missing the last padding at this point to get the final\n\t\t\t\t// dimension\n\t\t\t\tboundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n\t\t\t\t// We can never assign a width smaller than the padding and borders\n\t\t\t\tpaddingAndBorderAxisMain\n\t\t\t);\n\n\t\t\tif (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n\t\t\t\t\tmainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n\t\t\t\tneedsMainTrailingPos = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!isCrossDimDefined) {\n\t\t\tnode.layout[dim[crossAxis]] = fmaxf(\n\t\t\t\t// For the cross dim, we add both sides at the end because the value\n\t\t\t\t// is aggregate via a max function. Intermediate negative values\n\t\t\t\t// can mess this computation otherwise\n\t\t\t\tboundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n\t\t\t\tpaddingAndBorderAxisCross\n\t\t\t);\n\n\t\t\tif (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n\t\t\t\t\tcrossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n\t\t\t\tneedsCrossTrailingPos = true;\n\t\t\t}\n\t\t}\n\n\t\t// <Loop F> Set trailing position if necessary\n\t\tif (needsMainTrailingPos || needsCrossTrailingPos) {\n\t\t\tfor (i = 0; i < childCount; ++i) {\n\t\t\t\tchild = node.children[i];\n\n\t\t\t\tif (needsMainTrailingPos) {\n\t\t\t\t\tsetTrailingPosition(node, child, mainAxis);\n\t\t\t\t}\n\n\t\t\t\tif (needsCrossTrailingPos) {\n\t\t\t\t\tsetTrailingPosition(node, child, crossAxis);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// <Loop G> Calculate dimensions for absolutely positioned elements\n\t\tcurrentAbsoluteChild = firstAbsoluteChild;\n\t\twhile (currentAbsoluteChild !== null) {\n\t\t\t// Pre-fill dimensions when using absolute position and both offsets for\n\t\t\t// the axis are defined (either both left and right or top and bottom).\n\t\t\tfor (ii = 0; ii < 2; ii++) {\n\t\t\t\taxis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\n\t\t\t\tif (!isUndefined(node.layout[dim[axis]]) &&\n\t\t\t\t\t\t!isDimDefined(currentAbsoluteChild, axis) &&\n\t\t\t\t\t\tisPosDefined(currentAbsoluteChild, leading[axis]) &&\n\t\t\t\t\t\tisPosDefined(currentAbsoluteChild, trailing[axis])) {\n\t\t\t\t\tcurrentAbsoluteChild.layout[dim[axis]] = fmaxf(\n\t\t\t\t\t\tboundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] -\n\t\t\t\t\t\t\tgetBorderAxis(node, axis) -\n\t\t\t\t\t\t\tgetMarginAxis(currentAbsoluteChild, axis) -\n\t\t\t\t\t\t\tgetPosition(currentAbsoluteChild, leading[axis]) -\n\t\t\t\t\t\t\tgetPosition(currentAbsoluteChild, trailing[axis])\n\t\t\t\t\t\t),\n\t\t\t\t\t\t// You never want to go smaller than padding\n\t\t\t\t\t\tgetPaddingAndBorderAxis(currentAbsoluteChild, axis)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n\t\t\t\t\t\t!isPosDefined(currentAbsoluteChild, leading[axis])) {\n\t\t\t\t\tcurrentAbsoluteChild.layout[leading[axis]] =\n\t\t\t\t\t\tnode.layout[dim[axis]] -\n\t\t\t\t\t\tcurrentAbsoluteChild.layout[dim[axis]] -\n\t\t\t\t\t\tgetPosition(currentAbsoluteChild, trailing[axis]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchild = currentAbsoluteChild;\n\t\t\tcurrentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;\n\t\t\tchild.nextAbsoluteChild = null;\n\t\t}\n\t}\n\n\tfunction layoutNode(node, parentMaxWidth, parentMaxHeight, parentDirection) {\n\t\tnode.shouldUpdate = true;\n\n\t\tvar direction = node.style.direction || CSS_DIRECTION_LTR;\n\t\tvar skipLayout =\n\t\t\t!node.isDirty &&\n\t\t\tnode.lastLayout &&\n\t\t\tnode.lastLayout.requestedHeight === node.layout.height &&\n\t\t\tnode.lastLayout.requestedWidth === node.layout.width &&\n\t\t\tnode.lastLayout.parentMaxWidth === parentMaxWidth &&\n\t\t\tnode.lastLayout.parentMaxHeight === parentMaxHeight &&\n\t\t\tnode.lastLayout.direction === direction;\n\n\t\tif (skipLayout) {\n\t\t\tnode.layout.width = node.lastLayout.width;\n\t\t\tnode.layout.height = node.lastLayout.height;\n\t\t\tnode.layout.top = node.lastLayout.top;\n\t\t\tnode.layout.left = node.lastLayout.left;\n\t\t} else {\n\t\t\tif (!node.lastLayout) {\n\t\t\t\tnode.lastLayout = {};\n\t\t\t}\n\n\t\t\tnode.lastLayout.requestedWidth = node.layout.width;\n\t\t\tnode.lastLayout.requestedHeight = node.layout.height;\n\t\t\tnode.lastLayout.parentMaxWidth = parentMaxWidth;\n\t\t\tnode.lastLayout.parentMaxHeight = parentMaxHeight;\n\t\t\tnode.lastLayout.direction = direction;\n\n\t\t\t// Reset child layouts\n\t\t\tnode.children.forEach(function(child) {\n\t\t\t\tchild.layout.width = undefined;\n\t\t\t\tchild.layout.height = undefined;\n\t\t\t\tchild.layout.top = 0;\n\t\t\t\tchild.layout.left = 0;\n\t\t\t});\n\n\t\t\tlayoutNodeImpl(node, parentMaxWidth, parentMaxHeight, parentDirection);\n\n\t\t\tnode.lastLayout.width = node.layout.width;\n\t\t\tnode.lastLayout.height = node.layout.height;\n\t\t\tnode.lastLayout.top = node.layout.top;\n\t\t\tnode.lastLayout.left = node.layout.left;\n\t\t}\n\t}\n\n\treturn {\n\t\tlayoutNodeImpl: layoutNodeImpl,\n\t\tcomputeLayout: layoutNode,\n\t\tfillNodes: fillNodes\n\t};\n})();\n\n// This module export is only used for the purposes of unit testing this file. When\n// the library is packaged this file is included within css-layout.js which forms\n// the public API.\nif (typeof exports === 'object') {\n\tmodule.exports = computeLayout;\n}\n\n\n\treturn function(node) {\n\t\t/*eslint-disable */\n\t\t// disabling ESLint because this code relies on the above include\n\t\tcomputeLayout.fillNodes(node);\n\t\tcomputeLayout.computeLayout(node);\n\t\t/*eslint-enable */\n\t};\n}));\n","!window.addEventListener && window.attachEvent && (function () {\n\tWindow.prototype.addEventListener = HTMLDocument.prototype.addEventListener = Element.prototype.addEventListener = function addEventListener(type, listener) {\n\t\tthis.attachEvent('on' + type, listener);\n\t};\n\n\tWindow.prototype.removeEventListener = HTMLDocument.prototype.removeEventListener = Element.prototype.removeEventListener = function removeEventListener(type, listener) {\n\t\tthis.detachEvent('on' + type, listener);\n\t};\n})();\n","flexibility.detect = function detect() {\n\tvar node = document.createElement('p');\n\n\ttry {\n\t\tnode.style.display = 'flex';\n\n\t\treturn node.style.display === 'flex';\n\t} catch (error) {\n\t\treturn false;\n\t}\n};\n\nif (!flexibility.detect() && document.attachEvent && document.documentElement.currentStyle) {\n\tdocument.attachEvent('onreadystatechange', function () {\n\t\tflexibility.onresize({\n\t\t\ttarget: document.documentElement\n\t\t});\n\t});\n}\n","flexibility.init = function init(node) {\n\t// get details from node\n\tvar details = node.onlayoutcomplete;\n\n\t// conditionally generate details\n\tif (!details) {\n\t\tdetails = node.onlayoutcomplete = {\n\t\t\tnode:     node,\n\t\t\tstyle:    {},\n\t\t\tchildren: []\n\t\t};\n\t}\n\n\t// store display style in details\n\tdetails.style.display = node.currentStyle['-js-display'] || node.currentStyle.display;\n\n\t// return details\n\treturn details;\n};\n","// define delay\nvar SECOND = 1000;\nvar FRAMES_PER_SECOND = 15;\n\nflexibility.onresize = function resize(event) {\n\t// remove resize listener\n\twindow.removeEventListener('resize', flexibility.onresize);\n\n\t// get resize target\n\tvar target = event.target && event.target.nodeType === 1 ? event.target : document.documentElement;\n\n\t// walk resize target\n\tflexibility.walk(target);\n\n\t// force layout\n\tif (target.offsetWidth || true) {\n\t\t// restore resize listener after a delay\n\t\tsetTimeout(function () {\n\t\t\twindow.addEventListener('resize', flexibility.onresize);\n\t\t}, SECOND / FRAMES_PER_SECOND);\n\t}\n};\n","var CSS_FLEX_CONTAINER_PROPERTIES = {\n\talignContent: {\n\t\tinitial: 'stretch',\n\t\tvalid:   /^(flex-start|flex-end|center|space-between|space-around|stretch)/\n\t},\n\talignItems: {\n\t\tinitial: 'stretch',\n\t\tvalid:   /^(flex-start|flex-end|center|baseline|stretch)$/\n\t},\n\tboxSizing: {\n\t\tinitial: 'content-box',\n\t\tvalid: /^(border-box|content-box)$/\n\t},\n\tflexDirection: {\n\t\tinitial: 'row',\n\t\tvalid:   /^(row|row-reverse|column|column-reverse)$/\n\t},\n\tflexWrap: {\n\t\tinitial: 'nowrap',\n\t\tvalid:   /^(nowrap|wrap|wrap-reverse)$/\n\t},\n\tjustifyContent: {\n\t\tinitial: 'flex-start',\n\t\tvalid:   /^(flex-start|flex-end|center|space-between|space-around)$/\n\t}\n};\n\nflexibility.updateFlexContainerCache = function updateFlexContainerCache(details) {\n\t// get style details\n\tvar style  = details.style;\n\tvar getCSS = details.node.currentStyle;\n\n\t// store each flex container property value\n\tfor (var key in CSS_FLEX_CONTAINER_PROPERTIES) {\n\t\tvar kabobKey = key.replace(/[A-Z]/g, '-$&').toLowerCase();\n\t\tvar keyValue = CSS_FLEX_CONTAINER_PROPERTIES[key];\n\t\tvar cssValue = getCSS[kabobKey];\n\n\t\tstyle[key] = keyValue.valid.test(cssValue) ? cssValue : keyValue.initial;\n\t}\n};\n","var CSS_FLEX_ITEM_PROPERTIES = {\n\talignSelf: {\n\t\tinitial: 'auto',\n\t\tvalid:   /^(auto|flex-start|flex-end|center|baseline|stretch)$/\n\t},\n\tboxSizing: {\n\t\tinitial: 'content-box',\n\t\tvalid: /^(border-box|content-box)$/\n\t},\n\tflexBasis: {\n\t\tinitial: 'auto',\n\t\tvalid:   /^((?:[-+]?0|[-+]?[0-9]*\\.?[0-9]+(?:%|ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmax|vmin|vw))|auto|fill|max-content|min-content|fit-content|content)$/\n\t},\n\tflexGrow: {\n\t\tinitial: 0,\n\t\tvalid:   /^\\+?(0|[1-9][0-9]*)$/\n\t},\n\tflexShrink: {\n\t\tinitial: 0,\n\t\tvalid:   /^\\+?(0|[1-9][0-9]*)$/\n\t},\n\torder: {\n\t\tinitial: 0,\n\t\tvalid:   /^([-+]?[0-9]+)$/\n\t}\n};\n\nflexibility.updateFlexItemCache = function updateFlexItemCache(details) {\n\t// get style details\n\tvar style  = details.style;\n\tvar getCSS = details.node.currentStyle;\n\n\t// store each flex item property value\n\tfor (var key in CSS_FLEX_ITEM_PROPERTIES) {\n\t\tvar kabobKey = key.replace(/[A-Z]/g, '-$&').toLowerCase();\n\t\tvar keyValue = CSS_FLEX_ITEM_PROPERTIES[key];\n\t\tvar cssValue = getCSS[kabobKey];\n\n\t\tstyle[key] = keyValue.valid.test(cssValue) ? cssValue : keyValue.initial;\n\t}\n};\n","var CSS_RESET_TEXT = 'border:0 solid;clip:rect(0 0 0 0);display:inline-block;font:0/0 serif;margin:0;max-height:none;max-width:none;min-height:0;min-width:0;overflow:hidden;padding:0;position:absolute;width:1em;';\n\nvar CSS_BORDER_WIDTHS = {\n\tmedium: 4,\n\tnone:   0,\n\tthick:  6,\n\tthin:   2\n};\n\nvar CSS_LENGTHS = {\n\tborderBottomWidth: 0,\n\tborderLeftWidth: 0,\n\tborderRightWidth: 0,\n\tborderTopWidth: 0,\n\theight: 0,\n\tpaddingBottom: 0,\n\tpaddingLeft: 0,\n\tpaddingRight: 0,\n\tpaddingTop: 0,\n\tmarginBottom: 0,\n\tmarginLeft: 0,\n\tmarginRight: 0,\n\tmarginTop: 0,\n\tmaxHeight: 0,\n\tmaxWidth: 0,\n\tminHeight: 0,\n\tminWidth: 0,\n\twidth: 0\n};\n\nflexibility.updateLengthCache = function updateLengthCache(details) {\n\t// get style details\n\tvar node = details.node;\n\tvar style = details.style;\n\n\t// get node parent\n\tvar parentNode  = node.parentNode;\n\n\t// create clone element\n\tvar clonex = document.createElement('_');\n\n\tvar setCSS = clonex.runtimeStyle;\n\n\tvar getCSS = node.currentStyle;\n\n\tsetCSS.cssText = CSS_RESET_TEXT + 'font-size:' + getCSS.fontSize;\n\n\t// insert clone after node\n\tparentNode.insertBefore(clonex, node.nextSibling);\n\n\tstyle.fontSize = setCSS.width;\n\n\tfor (var key in CSS_LENGTHS) {\n\t\tvar cssValue = getCSS[key];\n\n\t\tif (/^\\d/.test(cssValue)) {\n\t\t\tsetCSS.width = cssValue;\n\n\t\t\tstyle[key] = clonex.offsetWidth;\n\t\t} else {\n\t\t\tstyle[key] = /^border/.test(key) && cssValue in CSS_BORDER_WIDTHS ? CSS_BORDER_WIDTHS[cssValue] : cssValue;\n\t\t}\n\t}\n\n\t// remove clone\n\tparentNode.removeChild(clonex);\n\n\t// redefine borders without style\n\tif (getCSS.borderTopStyle    === 'none') {\n\t\tstyle.borderTopWidth    = 0;\n\t}\n\n\tif (getCSS.borderRightStyle  === 'none') {\n\t\tstyle.borderRightWidth  = 0;\n\t}\n\n\tif (getCSS.borderBottomStyle === 'none') {\n\t\tstyle.borderBottomWidth = 0;\n\t}\n\n\tif (getCSS.borderLeftStyle   === 'none') {\n\t\tstyle.borderLeftWidth   = 0;\n\t}\n\n\t// remove min and max lengths using keywards\n\tif (style.maxHeight === 'none') {\n\t\tdelete style.maxHeight;\n\t}\n\n\tif (style.maxWidth === 'none') {\n\t\tdelete style.maxWidth;\n\t}\n\n\tif (style.minHeight === 'auto') {\n\t\tdelete style.minHeight;\n\t}\n\n\tif (style.minWidth === 'auto') {\n\t\tdelete style.minWidth;\n\t}\n\n\t// save original width and height lengths\n\tstyle.originalWidth = style.width;\n\tstyle.originalHeight = style.height;\n\n\t// provide width and height fallbacks\n\tstyle.width  = /^\\d/.test(style.width)  ? style.width  : node.offsetWidth;\n\tstyle.height = /^\\d/.test(style.height) ? style.height : node.offsetHeight;\n\n\t// conditionally remove flex height\n\tif (style.display === 'flex' && style.originalHeight === 'auto') {\n\t\tdelete style.height;\n\t}\n};\n","var CSS_OVERFLOW_BUFFER = 0;\n\nflexibility.walk = function walk(node) {\n\t// initialize node\n\tvar details = flexibility.init(node);\n\n\t// get display\n\tvar style   = details.style;\n\tvar display = style.display;\n\n\t// skip display:none elements\n\tif (display === 'none') {\n\t\treturn {};\n\t}\n\n\t// detect flex\n\tvar isFlex  = display.match(/^(inline)?flex$/);\n\n\t// conditionally style flex container\n\tif (isFlex) {\n\t\tflexibility.updateFlexContainerCache(details);\n\n\t\tnode.runtimeStyle.cssText = 'display:' + (isFlex[1] ? 'inline-block' : 'block');\n\n\t\tdetails.children = [];\n\t}\n\n\t// walk children of the current node\n\tArray.prototype.forEach.call(node.childNodes, function (childNode, childNodeIndex) {\n\t\t// if the child is an element\n\t\tif (childNode.nodeType === 1) {\n\t\t\t// walk the child element\n\t\t\tvar childDetails = flexibility.walk(childNode);\n\t\t\tvar childStyle   = childDetails.style;\n\n\t\t\tchildDetails.index = childNodeIndex;\n\n\t\t\t// if the parent is a flex container\n\t\t\tif (isFlex) {\n\t\t\t\t// get the flex item styles\n\t\t\t\tflexibility.updateFlexItemCache(childDetails);\n\n\t\t\t\t// inherit self alignment from container item alignment\n\t\t\t\tif (childStyle.alignSelf === 'auto') {\n\t\t\t\t\tchildStyle.alignSelf = style.alignItems;\n\t\t\t\t}\n\n\t\t\t\t// overwrite child runtime style\n\t\t\t\tchildNode.runtimeStyle.cssText = 'display:' + (childStyle.alignSelf === 'stretch' && /^column/.test(style.flexDirection) ? 'block' : 'inline-block');\n\n\t\t\t\t// add item to parent flex\n\t\t\t\tdetails.children.push(childDetails);\n\t\t\t}\n\t\t}\n\t});\n\n\t// if the element is a flex container\n\tif (isFlex) {\n\t\t// calculate each flex item length\n\t\tdetails.children.forEach(function (child) {\n\t\t\tflexibility.updateLengthCache(child);\n\t\t});\n\n\t\t// sort flex items by order or original position\n\t\tdetails.children.sort(function (childA, childB) {\n\t\t\treturn childA.style.order - childB.style.order || childA.index - childB.index;\n\t\t});\n\n\t\t// if the flex container direction is reversed\n\t\tif (/-reverse$/.test(style.flexDirection)) {\n\t\t\t// reverse the flex item order\n\t\t\tdetails.children.reverse();\n\n\t\t\t// remove the flex container reversal\n\t\t\tstyle.flexDirection = style.flexDirection.replace(/-reverse$/, '');\n\n\t\t\t// conditionally flip flex container content justification\n\t\t\tif (style.justifyContent === 'flex-start') {\n\t\t\t\tstyle.justifyContent = 'flex-end';\n\t\t\t} else if (style.justifyContent === 'flex-end') {\n\t\t\t\tstyle.justifyContent = 'flex-start';\n\t\t\t}\n\t\t}\n\n\t\t// update flex container lengths\n\t\tflexibility.updateLengthCache(details);\n\n\t\t// remove old layout results\n\t\tdelete details.lastLayout;\n\t\tdelete details.layout;\n\n\t\t// CSS-LAYOUT PATCH: adjust border widths\n\t\tvar borderTopWidth = style.borderTopWidth;\n\t\tvar borderBottomWidth = style.borderBottomWidth;\n\n\t\tstyle.borderTopWidth = 0;\n\t\tstyle.borderBottomWidth = 0;\n\t\tstyle.borderLeftWidth = 0;\n\n\t\tif (style.flexDirection === 'column') {\n\t\t\tstyle.width -= style.borderRightWidth;\n\t\t}\n\n\t\t// calculate the layout\n\t\tflexibility.computeLayout(details);\n\n\t\t// style the flex container\n\t\tnode.runtimeStyle.cssText = 'box-sizing:border-box;display:block;position:relative;width:' + (details.layout.width + style.borderRightWidth + CSS_OVERFLOW_BUFFER) + 'px;height:' + (details.layout.height + borderTopWidth + borderBottomWidth) + 'px';\n\n\t\t// CSS-LAYOUT PATCH: calculate stretched column width and height\n\t\tvar maxLength = [];\n\t\tvar maxIndex = 1;\n\n\t\tvar angle = style.flexDirection === 'column' ? 'width' : 'height';\n\n\t\tdetails.children.forEach(function (child) {\n\t\t\tmaxLength[child.lineIndex] = Math.max(maxLength[child.lineIndex] || 0, child.layout[angle]);\n\n\t\t\tmaxIndex = Math.max(maxIndex, child.lineIndex + 1);\n\t\t});\n\n\t\t// style each flex item\n\t\tdetails.children.forEach(function (child) {\n\t\t\tvar layout = child.layout;\n\n\t\t\tif (child.style.alignSelf === 'stretch') {\n\t\t\t\tlayout[angle] = maxLength[child.lineIndex];\n\t\t\t}\n\n\t\t\tchild.node.runtimeStyle.cssText = 'box-sizing:border-box;display:block;position:absolute;margin:0;width:' + (layout.width + CSS_OVERFLOW_BUFFER) + 'px;height:' + layout.height + 'px;top:' + layout.top + 'px;left:' + layout.left + 'px';\n\t\t});\n\t}\n\n\treturn details;\n};\n"],"sourceRoot":"/source/"}