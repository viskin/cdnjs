function $StickyStateProvider(){var inactiveStates={},stickyStates={};this.registerStickyState=function(state){stickyStates[state.name]=state},this.$get=["$rootScope","$state","$injector","$log",function($rootScope,$state,$injector,$log){function mapInactives(){var mappedStates={};for(var name in inactiveStates)for(var state=inactiveStates[name],parParents=getStickyStateStack(state),i=0;i<parParents.length;i++){var parent=parParents[i].parent;mappedStates[parent.name]=mappedStates[parent.name]||[],mappedStates[parent.name].push(state)}return mappedStates}function getStickyStateStack(state){var stack=[];if(!state)return stack;do state.sticky&&stack.push(state),state=state.parent;while(state);return stack.reverse(),stack}function getStickyTransitionType(fromPath,toPath,keep){if(fromPath[keep]===toPath[keep])return{from:!1,to:!1};var stickyFromState=keep<fromPath.length&&fromPath[keep].self.sticky,stickyToState=keep<toPath.length&&toPath[keep].self.sticky;return{from:stickyFromState,to:stickyToState}}function getEnterTransition(state,stateParams,ancestorParamsChanged){if(ancestorParamsChanged)return"updateStateParams";var inactiveState=inactiveStates[state.self.name];if(!inactiveState)return"enter";null==inactiveState.locals||null==inactiveState.locals.globals;var paramsMatch=equalForKeys(stateParams,inactiveState.locals.globals.$stateParams,state.ownParams);return paramsMatch?"reactivate":"updateStateParams"}function getInactivatedState(state,stateParams){var inactiveState=inactiveStates[state.name];if(!inactiveState)return null;if(!stateParams)return inactiveState;var paramsMatch=equalForKeys(stateParams,inactiveState.locals.globals.$stateParams,state.ownParams);return paramsMatch?inactiveState:null}function equalForKeys(a,b,keys){if(!keys){keys=[];for(var n in a)keys.push(n)}for(var i=0;i<keys.length;i++){var k=keys[i];if(a[k]!=b[k])return!1}return!0}var stickySupport={getInactiveStates:function(){var states=[];return angular.forEach(inactiveStates,function(state){states.push(state)}),states},getInactiveStatesByParent:function(){return mapInactives()},processTransition:function(transition){for(var result={inactives:[],enter:[],exit:[],keep:0},fromPath=transition.fromState.path,fromParams=transition.fromParams,toPath=transition.toState.path,toParams=transition.toParams,keep=0,state=toPath[keep];state&&state===fromPath[keep]&&equalForKeys(toParams,fromParams,state.ownParams);)state=toPath[++keep],null!=state&&null==state.ownParams;result.keep=keep;var idx,deepestUpdatedParams,deepestReactivate,reactivatedStatesByName={},pType=getStickyTransitionType(fromPath,toPath,keep),ancestorUpdated=!1;for(idx=keep;idx<toPath.length;idx++){var enterTrans=pType.to?getEnterTransition(toPath[idx],transition.toParams,ancestorUpdated):"enter";ancestorUpdated=ancestorUpdated||"updateStateParams"==enterTrans,result.enter[idx]=enterTrans,"reactivate"==enterTrans&&(deepestReactivate=reactivatedStatesByName[toPath[idx].name]=toPath[idx]),"updateStateParams"==enterTrans&&(deepestUpdatedParams=toPath[idx])}deepestReactivate=deepestReactivate?deepestReactivate.self.name+".":"",deepestUpdatedParams=deepestUpdatedParams?deepestUpdatedParams.self.name+".":"";var inactivesByParent=mapInactives();for(idx=0;keep>idx;idx++)for(var inactiveChildren=inactivesByParent[fromPath[idx].self.name],i=0;inactiveChildren&&i<inactiveChildren.length;i++){var child=inactiveChildren[i];reactivatedStatesByName[child.name]||deepestReactivate&&0===child.self.name.indexOf(deepestReactivate)||deepestUpdatedParams&&0===child.self.name.indexOf(deepestUpdatedParams)||result.inactives.push(child)}for(idx=keep;idx<fromPath.length;idx++){var exitTrans="exit";pType.from&&(result.inactives.push(fromPath[idx]),exitTrans="inactivate"),result.exit[idx]=exitTrans}return result},stateInactivated:function(state){inactiveStates[state.self.name]=state,state.self.onInactivate&&$injector.invoke(state.self.onInactivate,state.self,state.locals.globals)},stateReactivated:function(state){inactiveStates[state.self.name]&&delete inactiveStates[state.self.name],null==state.locals||null==state.locals.globals,state.self.onReactivate&&$injector.invoke(state.self.onReactivate,state.self,state.locals.globals)},stateExiting:function(exiting,exitQueue,onExit){var substatePrefix=exiting.self.name+".",exitingNames={};angular.forEach(exitQueue,function(state){exitingNames[state.self.name]=!0});for(var name in inactiveStates)if(!exitingNames[name]&&0===name.indexOf(substatePrefix)){$log.debug("Exiting "+name+" because it's a substate of "+substatePrefix+" and wasn't found in ",exitingNames);var inactiveExiting=inactiveStates[name];inactiveExiting.self.onExit&&$injector.invoke(inactiveExiting.self.onExit,inactiveExiting.self,inactiveExiting.locals.globals),inactiveExiting.locals=null,delete inactiveStates[name]}onExit&&$injector.invoke(onExit,exiting.self,exiting.locals.globals),exiting.locals=null,delete inactiveStates[exiting.self.name]},stateEntering:function(entering,params,onEnter){var inactivatedState=getInactivatedState(entering);if(inactivatedState&&!getInactivatedState(entering,params)){var savedLocals=entering.locals;this.stateExiting(inactivatedState),entering.locals=savedLocals}onEnter&&$injector.invoke(onEnter,entering.self,entering.locals.globals)}};return stickySupport}]}function SurrogateState(type){return{resolve:{},locals:{globals:root&&root.locals&&root.locals.globals},views:{},self:{},ownParams:[],surrogateType:type}}function ngloadStateFactory($q,futureState){var ngloadDeferred=$q.defer();return require(["ngload!"+futureState.src,"ngload","angularAMD"],function(result,ngload,angularAMD){angularAMD.processQueue(),ngloadDeferred.resolve(result.entryState)}),ngloadDeferred.promise}angular.module("ct.ui.router.extras",["ui.router"]);var app=angular.module("ct.ui.router.extras");app.service("$deepStateRedirect",function($rootScope,$state){function computeDeepStateStatus(state){var name=state.name;return deepStateRedirectsByName.hasOwnProperty(name)?deepStateRedirectsByName[name]:void recordDeepStateRedirectStatus(name)}function recordDeepStateRedirectStatus(stateName){var state=$state.get(stateName);state&&state.deepStateRedirect===!0&&(deepStateRedirectsByName[stateName]=REDIRECT,void 0===lastSubstate[stateName]&&(lastSubstate[stateName]=stateName));var lastDot=stateName.lastIndexOf(".");if(-1!=lastDot){var parentStatus=recordDeepStateRedirectStatus(stateName.substr(0,lastDot));parentStatus&&void 0===deepStateRedirectsByName[stateName]&&(deepStateRedirectsByName[stateName]=ANCESTOR_REDIRECT)}return deepStateRedirectsByName[stateName]||!1}var lastSubstate={},lastParams={},deepStateRedirectsByName={},REDIRECT="Redirect",ANCESTOR_REDIRECT="AncestorRedirect";$rootScope.$on("$stateChangeStart",function(event,toState){function shouldRedirect(){var deepStateStatus=computeDeepStateStatus(toState),substate=lastSubstate[toState.name];return deepStateStatus===REDIRECT&&substate&&substate!=toState.name?!0:!1}shouldRedirect()&&(event.preventDefault(),$state.go(lastSubstate[toState.name],lastParams[toState.name]))}),$rootScope.$on("$stateChangeSuccess",function(event,toState,toParams){var deepStateStatus=computeDeepStateStatus(toState);deepStateStatus&&_.each(lastSubstate,function(deepState,redirectState){(toState.name==deepState||-1!=toState.name.indexOf(redirectState+"."))&&(lastSubstate[redirectState]=toState.name,lastParams[redirectState]=angular.copy(toParams))})})}),app.run(function(){}),$StickyStateProvider.$inject=["$stateProvider"],angular.module("ct.ui.router.extras").provider("$stickyState",$StickyStateProvider);var _StickyState,internalStates={},root,pendingTransitions=[],pendingRestore,inactivePseudoState;angular.module("ct.ui.router.extras").run(["$stickyState",function($stickyState){_StickyState=$stickyState}]),angular.module("ct.ui.router.extras").config(["$provide","$stateProvider","$stickyStateProvider",function($provide,$stateProvider,$stickyStateProvider){var pState={self:{name:"__inactives"},onEnter:function(){inactivePseudoState.locals.globals=root.locals.globals}};inactivePseudoState=angular.extend(new SurrogateState("__inactives"),pState),$stateProvider.decorator("parent",function(state,parentFn){return root||(root=parentFn({}),inactivePseudoState.parent=root,inactivePseudoState.locals=root.locals),parentFn(state)}),$stateProvider.decorator("path",function(state,parentFn){internalStates[state.self.name]=state,state.self.sticky===!0&&$stickyStateProvider.registerStickyState(state.self);var realPath=[],temp=parentFn(state);return angular.forEach(temp,function(pathElem){pathElem!==inactivePseudoState&&realPath.push(pathElem)}),[inactivePseudoState].concat(realPath)}),$provide.decorator("$state",["$delegate","$log",function($state,$log){var realTransitionTo=$state.transitionTo;return $state.transitionTo=function(to,toParams,options){function debugTransition(transition){function message(path,index,state){return path[index]?path[index].toUpperCase()+": "+state.self.name:"("+state.self.name+")"}var inactiveLogVar=map(transition.inactives,function(state){return state.self.name}),enterLogVar=map(toState.path,function(state,index){return message(transition.enter,index,state)}),exitLogVar=map(fromState.path,function(state,index){return message(transition.exit,index,state)});$log.debug("exit: ",exitLogVar),$log.debug("enter: ",enterLogVar),$log.debug("After transition, inactives: ",inactiveLogVar)}function stateReactivatedSurrogatePhase1(state){var surrogate=angular.extend(new SurrogateState("reactivate_p1"),{locals:state.locals});return surrogate.self=angular.extend({},state.self),surrogate}function stateReactivatedSurrogatePhase2(state){var surrogate=angular.extend(new SurrogateState("reactivate_p2"),state);return surrogate.self=angular.extend({},state.self),surrogate.self.onEnter=function(){surrogate.locals=state.locals,_StickyState.stateReactivated(state)},surrogate}function stateInactivatedSurrogate(state){var surrogate=new SurrogateState("inactivate");return surrogate.self=angular.extend({},state.self),surrogate.self.onExit=function(){_StickyState.stateInactivated(state)},surrogate}function stateEnteredSurrogate(state,toParams){var oldOnEnter=state.self.onEnter;return state.self.onEnter=function(){_StickyState.stateEntering(state,toParams,oldOnEnter)},restore.addRestoreFunction(function(){state.self.onEnter=oldOnEnter}),state}function stateExitedSurrogate(state){var oldOnExit=state.self.onExit;return state.self=angular.extend({},state.self),state.self.onExit=function(){_StickyState.stateExiting(state,exited,oldOnExit)},restore.addRestoreFunction(function(){state.self.onExit=oldOnExit}),state}var idx=pendingTransitions.length;pendingRestore&&(pendingRestore(),$log.debug("Restored paths from pending transition"));var savedToStatePath,savedFromStatePath,stickyTransitions,terminalReactivatedState,fromState=$state.$current,fromParams=$state.params,rel=options.relative||$state.$current,toStateSelf=$state.get(to,rel),reactivated=[],exited=[],noop=function(){},restore=function(){savedToStatePath&&(toState.path=savedToStatePath,savedToStatePath=null),savedFromStatePath&&(fromState.path=savedFromStatePath,savedFromStatePath=null),angular.forEach(restore.restoreFunctions,function(restoreFunction){restoreFunction()}),restore=noop,pendingRestore=null,pendingTransitions.splice(idx,1)};if(restore.restoreFunctions=[],restore.addRestoreFunction=function(fn){this.restoreFunctions.push(fn)},toStateSelf){var toState=internalStates[toStateSelf.name];if(toState){savedToStatePath=toState.path,savedFromStatePath=fromState.path;var currentTransition={toState:toState,toParams:toParams||{},fromState:fromState,fromParams:fromParams||{}},msg=currentTransition.fromState.self.name+": "+angular.toJson(currentTransition.fromParams)+":  -> "+currentTransition.toState.self.name+": "+angular.toJson(currentTransition.toParams);$log.debug("Current transition: ",msg),pendingTransitions.push(currentTransition),pendingRestore=restore,stickyTransitions=_StickyState.processTransition(currentTransition),debugTransition(stickyTransitions);var surrogateToPath=toState.path.slice(0,stickyTransitions.keep),surrogateFromPath=fromState.path.slice(0,stickyTransitions.keep);for(var name in inactivePseudoState.locals)delete inactivePseudoState.locals[name];for(var i=0;i<stickyTransitions.inactives.length;i++){var iLocals=stickyTransitions.inactives[i].locals;for(name in iLocals)iLocals.hasOwnProperty(name)&&-1!=name.indexOf("@")&&(inactivePseudoState.locals[name]=iLocals[name])}if(angular.forEach(stickyTransitions.enter,function(value,idx){var surrogate;"reactivate"===value?(surrogate=stateReactivatedSurrogatePhase1(toState.path[idx]),surrogateToPath.push(surrogate),surrogateFromPath.push(surrogate),reactivated.push(stateReactivatedSurrogatePhase2(toState.path[idx])),terminalReactivatedState=surrogate):"updateStateParams"===value?(surrogate=stateEnteredSurrogate(toState.path[idx]),surrogateToPath.push(surrogate),terminalReactivatedState=surrogate):"enter"===value&&surrogateToPath.push(stateEnteredSurrogate(toState.path[idx]))}),angular.forEach(stickyTransitions.exit,function(value,idx){var exiting=fromState.path[idx];"inactivate"===value?(surrogateFromPath.push(stateInactivatedSurrogate(exiting)),exited.push(exiting)):"exit"===value&&(surrogateFromPath.push(stateExitedSurrogate(exiting)),exited.push(exiting))}),reactivated.length&&angular.forEach(reactivated,function(surrogate){surrogateToPath.push(surrogate)}),terminalReactivatedState){var prefix=terminalReactivatedState.self.name+".",inactiveStates=_StickyState.getInactiveStates(),inactiveOrphans=[];inactiveStates.forEach(function(exiting){0===exiting.self.name.indexOf(prefix)&&($log.debug("exitable: ",exiting.self.name),inactiveOrphans.push(exiting))}),inactiveOrphans.sort(),inactiveOrphans.reverse(),surrogateFromPath=surrogateFromPath.concat(map(inactiveOrphans,function(exiting){return stateExitedSurrogate(exiting)})),exited=exited.concat(inactiveOrphans)}toState.path=surrogateToPath,fromState.path=surrogateFromPath;var pathMessage=function(state){return(state.surrogateType?state.surrogateType+":":"")+state.self.name};$log.debug("SurrogateFromPath: ",map(surrogateFromPath,pathMessage)),$log.debug("SurrogateToPath: ",map(surrogateToPath,pathMessage))}}var transitionPromise=realTransitionTo.apply($state,arguments);transitionPromise.then(function(state){restore(),$log.debug("Current state: "+state.name+", inactives: ",map(_StickyState.getInactiveStates(),function(s){return s.self.name}))},function(err){"transition prevented"!==err.message&&"transition aborted"!==err.message&&"transition superseded"!==err.message&&($log.debug("transition failed",err),console.log(err.stack)),restore()})},$state}])}]),angular.module("ct.ui.router.extras").provider("$futureState",function($stateProvider,$urlRouterProvider){function findFutureState($state,options){if(options.name)for(var nameComponents=options.name.split(/\./);nameComponents.length;){var stateName=nameComponents.join(".");if($state.get(stateName))return null;if(futureStates[stateName])return futureStates[stateName];nameComponents.pop()}if(options.url)for(var urlComponents=options.url.split(/\//);urlComponents.length;){var urlPrefix=urlComponents.join("/");if(futureUrlPrefixes[urlPrefix])return futureUrlPrefixes[urlPrefix];urlComponents.pop()}}function lazyLoadState($injector,futureState){if(!futureState){var deferred=$q.defer();return deferred.reject("No lazyState passed in "+futureState),deferred.promise}var type=futureState.type,factory=stateFactories[type];if(!factory)throw Error("No state factory for futureState.type: "+(futureState&&futureState.type));return $injector.invoke(factory,factory,{futureState:futureState})}function futureState_otherwise($injector,$location){var resyncing=!1,$log=$injector.get("$log"),otherwiseFunc=function(){$log.debug("Unable to map "+$location.path()),$location.url("/")},lazyLoadMissingState=function($rootScope,$urlRouter,$state){if(!initDone)return initPromise().then(function(){resyncing=!0,$urlRouter.sync(),resyncing=!1}),void(initDone=!0);var futureState=findFutureState($state,{url:$location.path()});return futureState?(transitionPending=!0,void lazyLoadState($injector,futureState).then(function(state){state&&!$state.get(state)&&$stateProvider.state(state),resyncing=!0,$urlRouter.sync(),resyncing=!1,transitionPending=!1},function(){transitionPending=!1,$state.go("top")})):$injector.invoke(otherwiseFunc)};if(!transitionPending){var nextFn=resyncing?otherwiseFunc:lazyLoadMissingState;return $injector.invoke(nextFn)}}var initPromise,stateFactories={},futureStates={},futureUrlPrefixes={},transitionPending=!1,resolveFunctions=[],initDone=!1,provider=this;this.addResolve=function(promiseFn){resolveFunctions.push(promiseFn)},this.stateFactory=function(futureStateType,factory){stateFactories[futureStateType]=factory},this.futureState=function(futureState){futureStates[futureState.stateName]=futureState,futureUrlPrefixes[futureState.urlPrefix]=futureState},this.get=function(){return angular.extend({},futureStates)},$urlRouterProvider.otherwise(futureState_otherwise);var serviceObject={getResolvePromise:function(){return initPromise()}};this.$get=function($injector,$state,$q,$rootScope,$urlRouter,$log){function init(){if($rootScope.$on("$stateNotFound",function(event,unfoundState,fromState,fromParams){if(!transitionPending){$log.debug("event, unfoundState, fromState, fromParams",event,unfoundState,fromState,fromParams);var futureState=findFutureState($state,{name:unfoundState.to});if(null!=futureState){event.preventDefault(),transitionPending=!0;var promise=lazyLoadState($injector,futureState);promise.then(function(state){state&&$stateProvider.state(state),$state.go(unfoundState.to,unfoundState.toParams),transitionPending=!1},function(error){console.log("failed to lazy load state ",error),$state.go(fromState,fromParams),transitionPending=!1})}}}),!initPromise){var promises=[];_.each(resolveFunctions,function(promiseFn){promises.push($injector.invoke(promiseFn))}),initPromise=_.once(function(){var allPromises=$q.all(promises);return allPromises.then(function(data){return _.flatten(data)})})}initPromise().then(function(){$urlRouter.sync()})}return init(),serviceObject.state=$stateProvider.state,serviceObject.futureState=provider.futureState,serviceObject.get=provider.get,serviceObject}}),angular.module("ct.ui.router.extras").run(["$futureState",function(){}]);var forEach=angular.forEach,map=function(collection,callback){var result=[];return angular.forEach(collection,function(item){result.push(callback(item))}),result},iframeStateFactory=function($q,futureState){var state={name:futureState.stateName,template:"<iframe src='"+futureState.src+"'></iframe>",url:futureState.urlPrefix};return $q.when(state)};