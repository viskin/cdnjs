!function(window,undefined){"use strict";function $StickyStateProvider(){var inactiveStates={},stickyStates={};this.registerStickyState=function(state){stickyStates[state.name]=state},this.enableDebug=function(enabled){DEBUG=enabled},this.$get=["$rootScope","$state","$injector","$log",function($rootScope,$state,$injector,$log){function mapInactives(){var mappedStates={};return angular.forEach(inactiveStates,function(state){for(var stickyAncestors=getStickyStateStack(state),i=0;i<stickyAncestors.length;i++){var parent=stickyAncestors[i].parent;mappedStates[parent.name]=mappedStates[parent.name]||[],mappedStates[parent.name].push(state)}mappedStates[""]&&(mappedStates.__inactives=mappedStates[""])}),mappedStates}function getStickyStateStack(state){var stack=[];if(!state)return stack;do state.sticky&&stack.push(state),state=state.parent;while(state);return stack.reverse(),stack}function getStickyTransitionType(fromPath,toPath,keep){if(fromPath[keep]===toPath[keep])return{from:!1,to:!1};var stickyFromState=keep<fromPath.length&&fromPath[keep].self.sticky,stickyToState=keep<toPath.length&&toPath[keep].self.sticky;return{from:stickyFromState,to:stickyToState}}function getEnterTransition(state,stateParams,ancestorParamsChanged){if(ancestorParamsChanged)return"updateStateParams";var inactiveState=inactiveStates[state.self.name];if(!inactiveState)return"enter";var paramsMatch=equalForKeys(stateParams,inactiveState.locals.globals.$stateParams,state.ownParams);return paramsMatch?"reactivate":"updateStateParams"}function getInactivatedState(state,stateParams){var inactiveState=inactiveStates[state.name];if(!inactiveState)return null;if(!stateParams)return inactiveState;var paramsMatch=equalForKeys(stateParams,inactiveState.locals.globals.$stateParams,state.ownParams);return paramsMatch?inactiveState:null}function equalForKeys(a,b,keys){if(!keys){keys=[];for(var n in a)keys.push(n)}for(var i=0;i<keys.length;i++){var k=keys[i];if(a[k]!=b[k])return!1}return!0}var stickySupport={getInactiveStates:function(){var states=[];return angular.forEach(inactiveStates,function(state){states.push(state)}),states},getInactiveStatesByParent:function(){return mapInactives()},processTransition:function(transition){for(var result={inactives:[],enter:[],exit:[],keep:0},fromPath=transition.fromState.path,fromParams=transition.fromParams,toPath=transition.toState.path,toParams=transition.toParams,keep=0,state=toPath[keep];state&&state===fromPath[keep]&&equalForKeys(toParams,fromParams,state.ownParams);)state=toPath[++keep];result.keep=keep;var idx,deepestUpdatedParams,deepestReactivate,reactivatedStatesByName={},pType=getStickyTransitionType(fromPath,toPath,keep),ancestorUpdated=!1;for(idx=keep;idx<toPath.length;idx++){var enterTrans=pType.to?getEnterTransition(toPath[idx],transition.toParams,ancestorUpdated):"enter";ancestorUpdated=ancestorUpdated||"updateStateParams"==enterTrans,result.enter[idx]=enterTrans,"reactivate"==enterTrans&&(deepestReactivate=reactivatedStatesByName[toPath[idx].name]=toPath[idx]),"updateStateParams"==enterTrans&&(deepestUpdatedParams=toPath[idx])}deepestReactivate=deepestReactivate?deepestReactivate.self.name+".":"",deepestUpdatedParams=deepestUpdatedParams?deepestUpdatedParams.self.name+".":"";var inactivesByParent=mapInactives();for(idx=0;keep>idx;idx++)for(var inactiveChildren=inactivesByParent[fromPath[idx].self.name],i=0;inactiveChildren&&i<inactiveChildren.length;i++){var child=inactiveChildren[i];reactivatedStatesByName[child.name]||deepestReactivate&&0===child.self.name.indexOf(deepestReactivate)||deepestUpdatedParams&&0===child.self.name.indexOf(deepestUpdatedParams)||result.inactives.push(child)}for(idx=keep;idx<fromPath.length;idx++){var exitTrans="exit";pType.from&&(result.inactives.push(fromPath[idx]),exitTrans="inactivate"),result.exit[idx]=exitTrans}return result},stateInactivated:function(state){inactiveStates[state.self.name]=state,state.self.status="inactive",state.self.onInactivate&&$injector.invoke(state.self.onInactivate,state.self,state.locals.globals)},stateReactivated:function(state){inactiveStates[state.self.name]&&delete inactiveStates[state.self.name],state.self.status="entered",state.self.onReactivate&&$injector.invoke(state.self.onReactivate,state.self,state.locals.globals)},stateExiting:function(exiting,exitQueue,onExit){var substatePrefix=exiting.self.name+".",exitingNames={};angular.forEach(exitQueue,function(state){exitingNames[state.self.name]=!0}),angular.forEach(inactiveStates,function(inactiveExiting,name){exitingNames[name]||0!==name.indexOf(substatePrefix)||(DEBUG&&$log.debug("Exiting "+name+" because it's a substate of "+substatePrefix+" and wasn't found in ",exitingNames),inactiveExiting.self.onExit&&$injector.invoke(inactiveExiting.self.onExit,inactiveExiting.self,inactiveExiting.locals.globals),inactiveExiting.locals=null,inactiveExiting.self.status="exited",delete inactiveStates[name])}),onExit&&$injector.invoke(onExit,exiting.self,exiting.locals.globals),exiting.locals=null,exiting.self.status="exited",delete inactiveStates[exiting.self.name]},stateEntering:function(entering,params,onEnter){var inactivatedState=getInactivatedState(entering);if(inactivatedState&&!getInactivatedState(entering,params)){var savedLocals=entering.locals;this.stateExiting(inactivatedState),entering.locals=savedLocals}entering.self.status="entered",onEnter&&$injector.invoke(onEnter,entering.self,entering.locals.globals)}};return stickySupport}]}function SurrogateState(type){return{resolve:{},locals:{globals:root&&root.locals&&root.locals.globals},views:{},self:{},params:{},ownParams:[],surrogateType:type}}angular.module("ct.ui.router.extras",["ui.router"]);var forEach=angular.forEach,map=function(collection,callback){var result=[];return forEach(collection,function(item,index){result.push(callback(item,index))}),result},filterObj=function(collection,callback){var result={};return forEach(collection,function(item,index){callback(item,index)&&(result[index]=item)}),result},DEBUG=!1,app=angular.module("ct.ui.router.extras");app.service("$deepStateRedirect",function($rootScope,$state){function computeDeepStateStatus(state){var name=state.name;return deepStateRedirectsByName.hasOwnProperty(name)?deepStateRedirectsByName[name]:void recordDeepStateRedirectStatus(name)}function recordDeepStateRedirectStatus(stateName){var state=$state.get(stateName);state&&state.deepStateRedirect===!0&&(deepStateRedirectsByName[stateName]=REDIRECT,lastSubstate[stateName]===undefined&&(lastSubstate[stateName]=stateName));var lastDot=stateName.lastIndexOf(".");if(-1!=lastDot){var parentStatus=recordDeepStateRedirectStatus(stateName.substr(0,lastDot));parentStatus&&deepStateRedirectsByName[stateName]===undefined&&(deepStateRedirectsByName[stateName]=ANCESTOR_REDIRECT)}return deepStateRedirectsByName[stateName]||!1}var lastSubstate={},lastParams={},deepStateRedirectsByName={},REDIRECT="Redirect",ANCESTOR_REDIRECT="AncestorRedirect";$rootScope.$on("$stateChangeStart",function(event,toState){function shouldRedirect(){var deepStateStatus=computeDeepStateStatus(toState),substate=lastSubstate[toState.name];return deepStateStatus===REDIRECT&&substate&&substate!=toState.name?!0:!1}shouldRedirect()&&(event.preventDefault(),$state.go(lastSubstate[toState.name],lastParams[toState.name]))}),$rootScope.$on("$stateChangeSuccess",function(event,toState,toParams){var deepStateStatus=computeDeepStateStatus(toState);deepStateStatus&&angular.forEach(lastSubstate,function(deepState,redirectState){(toState.name==deepState||-1!=toState.name.indexOf(redirectState+"."))&&(lastSubstate[redirectState]=toState.name,lastParams[redirectState]=angular.copy(toParams))})})}),app.run(["$deepStateRedirect",function(){}]),$StickyStateProvider.$inject=["$stateProvider"],angular.module("ct.ui.router.extras").provider("$stickyState",$StickyStateProvider);var _StickyState,root,pendingRestore,inactivePseudoState,internalStates={},pendingTransitions=[];angular.module("ct.ui.router.extras").run(["$stickyState",function($stickyState){_StickyState=$stickyState}]),angular.module("ct.ui.router.extras").config(["$provide","$stateProvider","$stickyStateProvider",function($provide,$stateProvider,$stickyStateProvider){var pState={self:{name:"__inactives"},onEnter:function(){inactivePseudoState.locals.globals=root.locals.globals}};inactivePseudoState=angular.extend(new SurrogateState("__inactives"),pState),$stateProvider.decorator("parent",function(state,parentFn){return root||(root=parentFn({}),inactivePseudoState.parent=root,inactivePseudoState.locals=root.locals),parentFn(state)}),$stateProvider.decorator("path",function(state,parentFn){internalStates[state.self.name]=state,state.self.$$state=function(){return internalStates[state.self.name]},state.self.sticky===!0&&$stickyStateProvider.registerStickyState(state.self);var realPath=[],temp=parentFn(state);return angular.forEach(temp,function(pathElem){pathElem!==inactivePseudoState&&realPath.push(pathElem)}),[inactivePseudoState].concat(realPath)}),$provide.decorator("$state",["$delegate","$log",function($state,$log){var realTransitionTo=$state.transitionTo;return $state.transitionTo=function(to,toParams,options){function debugTransition(currentTransition,stickyTransition){function message(path,index,state){return path[index]?path[index].toUpperCase()+": "+state.self.name:"("+state.self.name+")"}var inactiveLogVar=map(stickyTransition.inactives,function(state){return state.self.name}),enterLogVar=map(toState.path,function(state,index){return message(stickyTransition.enter,index,state)}),exitLogVar=map(fromState.path,function(state,index){return message(stickyTransition.exit,index,state)}),transitionMessage=currentTransition.fromState.self.name+": "+angular.toJson(currentTransition.fromParams)+":  -> "+currentTransition.toState.self.name+": "+angular.toJson(currentTransition.toParams);$log.debug("   Current transition: ",transitionMessage),$log.debug("Before transition, inactives are:   : ",map(_StickyState.getInactiveStates(),function(s){return s.self.name})),$log.debug("After transition,  inactives will be: ",inactiveLogVar),$log.debug("Transition will exit:  ",exitLogVar),$log.debug("Transition will enter: ",enterLogVar)}function stateReactivatedSurrogatePhase1(state){var surrogate=angular.extend(new SurrogateState("reactivate_p1"),{locals:state.locals});return surrogate.self=angular.extend({},state.self),surrogate}function stateReactivatedSurrogatePhase2(state){var surrogate=angular.extend(new SurrogateState("reactivate_p2"),state),oldOnEnter=surrogate.self.onEnter;return surrogate.self.onEnter=function(){surrogate.locals=state.locals,_StickyState.stateReactivated(state)},restore.addRestoreFunction(function(){state.self.onEnter=oldOnEnter}),surrogate}function stateInactivatedSurrogate(state){var surrogate=new SurrogateState("inactivate");surrogate.self=state.self;var oldOnExit=state.self.onExit;return surrogate.self.onExit=function(){_StickyState.stateInactivated(state)},restore.addRestoreFunction(function(){state.self.onExit=oldOnExit}),surrogate}function stateEnteredSurrogate(state,toParams){var oldOnEnter=state.self.onEnter;return state.self.onEnter=function(){_StickyState.stateEntering(state,toParams,oldOnEnter)},restore.addRestoreFunction(function(){state.self.onEnter=oldOnEnter}),state}function stateExitedSurrogate(state){var oldOnExit=state.self.onExit;return state.self.onExit=function(){_StickyState.stateExiting(state,exited,oldOnExit)},restore.addRestoreFunction(function(){state.self.onExit=oldOnExit}),state}var idx=pendingTransitions.length;pendingRestore&&(pendingRestore(),DEBUG&&$log.debug("Restored paths from pending transition"));var savedToStatePath,savedFromStatePath,stickyTransitions,terminalReactivatedState,fromState=$state.$current,fromParams=$state.params,rel=options.relative||$state.$current,toStateSelf=$state.get(to,rel),reactivated=[],exited=[],noop=function(){},restore=function(){savedToStatePath&&(toState.path=savedToStatePath,savedToStatePath=null),savedFromStatePath&&(fromState.path=savedFromStatePath,savedFromStatePath=null),angular.forEach(restore.restoreFunctions,function(restoreFunction){restoreFunction()}),restore=noop,pendingRestore=null,pendingTransitions.splice(idx,1)};if(restore.restoreFunctions=[],restore.addRestoreFunction=function(fn){this.restoreFunctions.push(fn)},toStateSelf){var toState=internalStates[toStateSelf.name];if(toState){savedToStatePath=toState.path,savedFromStatePath=fromState.path;var currentTransition={toState:toState,toParams:toParams||{},fromState:fromState,fromParams:fromParams||{}};pendingTransitions.push(currentTransition),pendingRestore=restore,stickyTransitions=_StickyState.processTransition(currentTransition),DEBUG&&debugTransition(currentTransition,stickyTransitions);var surrogateToPath=toState.path.slice(0,stickyTransitions.keep),surrogateFromPath=fromState.path.slice(0,stickyTransitions.keep);angular.forEach(inactivePseudoState.locals,function(local,name){delete inactivePseudoState.locals[name]});for(var i=0;i<stickyTransitions.inactives.length;i++){var iLocals=stickyTransitions.inactives[i].locals;angular.forEach(iLocals,function(view,name){iLocals.hasOwnProperty(name)&&-1!=name.indexOf("@")&&(inactivePseudoState.locals[name]=view)})}if(angular.forEach(stickyTransitions.enter,function(value,idx){var surrogate;"reactivate"===value?(surrogate=stateReactivatedSurrogatePhase1(toState.path[idx]),surrogateToPath.push(surrogate),surrogateFromPath.push(surrogate),reactivated.push(stateReactivatedSurrogatePhase2(toState.path[idx])),terminalReactivatedState=surrogate):"updateStateParams"===value?(surrogate=stateEnteredSurrogate(toState.path[idx]),surrogateToPath.push(surrogate),terminalReactivatedState=surrogate):"enter"===value&&surrogateToPath.push(stateEnteredSurrogate(toState.path[idx]))}),angular.forEach(stickyTransitions.exit,function(value,idx){var exiting=fromState.path[idx];"inactivate"===value?(surrogateFromPath.push(stateInactivatedSurrogate(exiting)),exited.push(exiting)):"exit"===value&&(surrogateFromPath.push(stateExitedSurrogate(exiting)),exited.push(exiting))}),reactivated.length&&angular.forEach(reactivated,function(surrogate){surrogateToPath.push(surrogate)}),terminalReactivatedState){var prefix=terminalReactivatedState.self.name+".",inactiveStates=_StickyState.getInactiveStates(),inactiveOrphans=[];inactiveStates.forEach(function(exiting){0===exiting.self.name.indexOf(prefix)&&inactiveOrphans.push(exiting)}),inactiveOrphans.sort(),inactiveOrphans.reverse(),surrogateFromPath=surrogateFromPath.concat(map(inactiveOrphans,function(exiting){return stateExitedSurrogate(exiting)})),exited=exited.concat(inactiveOrphans)}toState.path=surrogateToPath,fromState.path=surrogateFromPath;var pathMessage=function(state){return(state.surrogateType?state.surrogateType+":":"")+state.self.name};DEBUG&&$log.debug("SurrogateFromPath: ",map(surrogateFromPath,pathMessage)),DEBUG&&$log.debug("SurrogateToPath:   ",map(surrogateToPath,pathMessage))}}var transitionPromise=realTransitionTo.apply($state,arguments);transitionPromise.then(function(state){if(restore(),state.status="active",DEBUG){var currentState=internalStates[state.name];$log.debug("Current state: "+currentState.self.name+", inactive states: ",map(_StickyState.getInactiveStates(),function(s){return s.self.name}));for(var viewMsg=function(local,name){return"'"+name+"' ("+local.$$state.name+")"},statesOnly=function(local,name){return"globals"!=name&&"resolve"!=name},viewsForState=function(state){var views=map(filterObj(state.locals,statesOnly),viewMsg).join(", ");return"("+(state.self.name?state.self.name:"root")+".locals"+(views.length?": "+views:"")+")"},message=viewsForState(currentState),parent=currentState.parent;parent&&parent!==currentState;)""===parent.self.name&&(message=viewsForState($state.$current.path[0])+" / "+message),message=viewsForState(parent)+" / "+message,currentState=parent,parent=currentState.parent;$log.debug("Views: "+message)}},function(err){"transition prevented"!==err.message&&"transition aborted"!==err.message&&"transition superseded"!==err.message&&(DEBUG&&$log.debug("transition failed",err),DEBUG&&console.log(err.stack)),restore()})},$state}])}]),angular.module("ct.ui.router.extras").provider("$futureState",function($stateProvider,$urlRouterProvider){function findFutureState($state,options){if(options.name)for(var nameComponents=options.name.split(/\./);nameComponents.length;){var stateName=nameComponents.join(".");if($state.get(stateName))return null;if(futureStates[stateName])return futureStates[stateName];nameComponents.pop()}if(options.url)for(var urlComponents=options.url.split(/\//);urlComponents.length;){var urlPrefix=urlComponents.join("/");if(futureUrlPrefixes[urlPrefix])return futureUrlPrefixes[urlPrefix];urlComponents.pop()}}function lazyLoadState($injector,futureState){if(!futureState){var deferred=$q.defer();return deferred.reject("No lazyState passed in "+futureState),deferred.promise}var type=futureState.type,factory=stateFactories[type];if(!factory)throw Error("No state factory for futureState.type: "+(futureState&&futureState.type));return $injector.invoke(factory,factory,{futureState:futureState})}function futureState_otherwise($injector,$location){var resyncing=!1,$log=$injector.get("$log"),otherwiseFunc=function(){$log.debug("Unable to map "+$location.path()),$location.url("/")},lazyLoadMissingState=function($rootScope,$urlRouter,$state){if(!initDone)return initPromise().then(function(){resyncing=!0,$urlRouter.sync(),resyncing=!1}),void(initDone=!0);var futureState=findFutureState($state,{url:$location.path()});return futureState?(transitionPending=!0,void lazyLoadState($injector,futureState).then(function(state){state&&!$state.get(state)&&$stateProvider.state(state),resyncing=!0,$urlRouter.sync(),resyncing=!1,transitionPending=!1},function(){transitionPending=!1,$state.go("top")})):$injector.invoke(otherwiseFunc)};if(!transitionPending){var nextFn=resyncing?otherwiseFunc:lazyLoadMissingState;return $injector.invoke(nextFn)}}var initPromise,stateFactories={},futureStates={},futureUrlPrefixes={},transitionPending=!1,resolveFunctions=[],initDone=!1,provider=this;this.addResolve=function(promiseFn){resolveFunctions.push(promiseFn)},this.stateFactory=function(futureStateType,factory){stateFactories[futureStateType]=factory},this.futureState=function(futureState){futureStates[futureState.stateName]=futureState,futureUrlPrefixes[futureState.urlPrefix]=futureState},this.get=function(){return angular.extend({},futureStates)},$urlRouterProvider.otherwise(futureState_otherwise);var serviceObject={getResolvePromise:function(){return initPromise()}};this.$get=function($injector,$state,$q,$rootScope,$urlRouter,$log){function init(){if($rootScope.$on("$stateNotFound",function(event,unfoundState,fromState,fromParams){if(!transitionPending){$log.debug("event, unfoundState, fromState, fromParams",event,unfoundState,fromState,fromParams);var futureState=findFutureState($state,{name:unfoundState.to});if(futureState){event.preventDefault(),transitionPending=!0;var promise=lazyLoadState($injector,futureState);promise.then(function(state){state&&$stateProvider.state(state),$state.go(unfoundState.to,unfoundState.toParams),transitionPending=!1},function(error){console.log("failed to lazy load state ",error),$state.go(fromState,fromParams),transitionPending=!1})}}}),!initPromise){var promises=[];angular.forEach(resolveFunctions,function(promiseFn){promises.push($injector.invoke(promiseFn))}),initPromise=function(){return $q.all(promises)}}initPromise().then(function(){$urlRouter.sync()})}return init(),serviceObject.state=$stateProvider.state,serviceObject.futureState=provider.futureState,serviceObject.get=provider.get,serviceObject}}),angular.module("ct.ui.router.extras").run(["$futureState",function(){}]),angular.module("ct.ui.router.extras").service("$previousState",["$rootScope","$state",function($rootScope,$state){var previous=null,memos={},lastPrevious=null;$rootScope.$on("$stateChangeStart",function(evt,toState,toStateParams,fromState,fromStateParams){lastPrevious=previous,previous={state:fromState,params:fromStateParams}}),$rootScope.$on("$stateChangeError",function(){previous=lastPrevious,lastPrevious=null}),$rootScope.$on("$stateChangeSuccess",function(){lastPrevious=null});var $previousState={get:function(memoName){return memoName?memos[memoName]:previous},go:function(memoName){var to=$previousState.get(memoName);return $state.go(to.state,to.params)},memo:function(memoName){memos[memoName]=previous},forget:function(memoName){delete memos[memoName]}};return $previousState}]),angular.module("ct.ui.router.extras").run(["$previousState",function(){}])}(window);