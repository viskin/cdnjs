/**
 * angular-permission
 * Fully featured role and permission based access control for your angular applications
 * @version v3.0.0 - 2016-04-30
 * @link https://github.com/Narzerus/angular-permission
 * @author Rafael Vidaurre <narzerus@gmail.com> (http://www.rafaelvidaurre.com), Blazej Krysiak
 *   <blazej.krysiak@gmail.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */


!function () {
  "use strict";
  angular.module("permission", [])
}(), function () {
  "use strict";
  function a(a) {
    "ngInject";
    function b(b) {
      var c = a.defer(), d = 0, e = angular.isArray(b) ? [] : {};
      return angular.forEach(b, function (b, f) {
        d++, a.when(b).then(function (a) {
          c.resolve(a)
        })["catch"](function (a) {
          e[f] = a, --d || c.reject(a)
        })
      }), 0 === d && c.reject(e), c.promise
    }

    return a.any = b, a
  }

  a.$inject = ["$delegate"], angular.module("permission").decorator("$q", a)
}(), function () {
  "use strict";
  var a = {
    enableElement: function (a) {
      a.removeAttr("disabled")
    }, disableElement: function (a) {
      a.attr("disabled", "disabled")
    }, showElement: function (a) {
      a.removeClass("ng-hide")
    }, hideElement: function (a) {
      a.addClass("ng-hide")
    }
  };
  angular.module("permission").constant("PermissionStrategies", a)
}(), function () {
  "use strict";
  var a = {};
  angular.module("permission").value("TransitionProperties", a)
}(), function () {
  "use strict";
  function a() {
    this.broadcastPermissionStartEvent = function () {
      throw new Error("Method broadcastPermissionStartEvent in TransitionEvents interface must be implemented")
    }, this.broadcastPermissionAcceptedEvent = function () {
      throw new Error("Method broadcastPermissionAcceptedEvent in TransitionEvents interface must be implemented")
    }, this.broadcastPermissionDeniedEvent = function () {
      throw new Error("Method broadcastPermissionDeniedEvent in TransitionEvents interface must be implemented")
    }
  }

  angular.module("permission").service("TransitionEvents", a)
}(), function () {
  "use strict";
  function a(a, b) {
    function c(a, b) {
      e(a, b), this.permissionName = a, this.validationFunction = b
    }

    function d(b, c) {
      var d = a.defer();
      return b ? d.resolve(c) : d.reject(c), d.promise
    }

    function e(a, b) {
      if (!angular.isString(a))throw new TypeError('Parameter "permissionName" name must be String');
      if (!angular.isFunction(b))throw new TypeError('Parameter "validationFunction" must be Function')
    }

    return c.prototype.validatePermission = function () {
      var a = this.validationFunction.call(null, this.permissionName, b);
      return angular.isFunction(a.then) || (a = d(a, this.permissionName)), a
    }, c
  }

  a.$inject = ["$q", "TransitionProperties"], angular.module("permission").factory("Permission", a)
}(), function () {
  "use strict";
  function a(a, b, c) {
    function d(a, b) {
      f(a, b), this.roleName = a, this.validationFunction = b
    }

    function e(b, c) {
      var d = a.defer();
      return b ? d.resolve(c) : d.reject(c), d.promise
    }

    function f(a, b) {
      if (!angular.isString(a))throw new TypeError('Parameter "roleName" name must be String');
      if (!angular.isArray(b) && !angular.isFunction(b))throw new TypeError('Parameter "validationFunction" must be array or function')
    }

    return d.prototype.validateRole = function () {
      if (angular.isFunction(this.validationFunction)) {
        var d = this.validationFunction.call(null, this.roleName, c);
        return angular.isFunction(d.then) || (d = e(d, this.roleName)), d
      }
      if (angular.isArray(this.validationFunction)) {
        var f = this.validationFunction.map(function (c) {
          if (b.hasPermissionDefinition(c)) {
            var d = b.getPermissionDefinition(c);
            return d.validatePermission()
          }
          return a.reject(c)
        });
        return a.all(f)
      }
    }, d
  }

  a.$inject = ["$q", "PermissionStore", "TransitionProperties"], angular.module("permission").factory("Role", a)
}(), function () {
  "use strict";
  function a(a) {
    function b(b, c) {
      var d = new a(b, c);
      i[b] = d
    }

    function c(a, c) {
      if (!angular.isArray(a))throw new TypeError('Parameter "permissionNames" name must be Array');
      angular.forEach(a, function (a) {
        b(a, c)
      })
    }

    function d(a) {
      delete i[a]
    }

    function e(a) {
      return angular.isDefined(i[a])
    }

    function f(a) {
      return i[a]
    }

    function g() {
      return i
    }

    function h() {
      i = {}
    }

    var i = {};
    this.definePermission = b, this.defineManyPermissions = c, this.removePermissionDefinition = d, this.hasPermissionDefinition = e, this.getPermissionDefinition = f, this.getStore = g, this.clearStore = h
  }

  a.$inject = ["Permission"], angular.module("permission").service("PermissionStore", a)
}(), function () {
  "use strict";
  function a(a) {
    function b(b, c) {
      i[b] = new a(b, c)
    }

    function c(a) {
      if (!angular.isObject(a))throw new TypeError('Parameter "roleNames" name must be object');
      angular.forEach(a, function (a, c) {
        b(c, a)
      })
    }

    function d(a) {
      delete i[a]
    }

    function e(a) {
      return angular.isDefined(i[a])
    }

    function f(a) {
      return i[a]
    }

    function g() {
      return i
    }

    function h() {
      i = {}
    }

    var i = {};
    this.defineRole = b, this.defineManyRoles = c, this.getRoleDefinition = f, this.hasRoleDefinition = e, this.removeRoleDefinition = d, this.getStore = g, this.clearStore = h
  }

  a.$inject = ["Role"], angular.module("permission").service("RoleStore", a)
}(), function () {
  "use strict";
  function a(a, b, c, d) {
    return {
      restrict: "A",
      bindToController: {
        only: "=?permissionOnly",
        except: "=?permissionExcept",
        onAuthorized: "&?permissionOnAuthorized",
        onUnauthorized: "&?permissionOnUnauthorized"
      },
      controllerAs: "permission",
      controller: ["$scope", "$element", function (e, f) {
        function g() {
          angular.isFunction(i.onAuthorized) ? i.onAuthorized()(f) : d.showElement(f)
        }

        function h() {
          angular.isFunction(i.onUnauthorized) ? i.onUnauthorized()(f) : d.hideElement(f)
        }

        var i = this;
        e.$watchGroup(["permission.only", "permission.except"], function () {
          try {
            var d = new c({only: i.only, except: i.except});
            b.authorize(d).then(function () {
              g()
            })["catch"](function () {
              h()
            })
          } catch (e) {
            h(), a.error(e.message)
          }
        })
      }]
    }
  }

  a.$inject = ["$log", "Authorization", "PermissionMap", "PermissionStrategies"], angular.module("permission").directive("permission", a)
}(), function () {
  "use strict";
  function a(a) {
    function b(a) {
      return c(a)
    }

    function c(b) {
      var c = a.defer();
      return d(c, b), c.promise
    }

    function d(b, c) {
      var d = c.resolvePropertyValidity(c.except);
      a.any(d).then(function (a) {
        b.reject(a)
      })["catch"](function () {
        e(b, c)
      })
    }

    function e(b, c) {
      if (!c.only.length)return void b.resolve();
      var d = c.resolvePropertyValidity(c.only);
      a.any(d).then(function (a) {
        b.resolve(a)
      })["catch"](function (a) {
        b.reject(a)
      })
    }

    this.authorize = b
  }

  a.$inject = ["$q"], angular.module("permission").service("Authorization", a)
}(), function () {
  "use strict";
  function a(a, b, c, d) {
    function e(a) {
      a = a || {}, this.only = h(a.only), this.except = h(a.except), this.redirectTo = a.redirectTo
    }

    function f(c, d) {
      return a.when(c.call(null, d, b)).then(function (b) {
        return angular.isString(b) ? {state: b} : angular.isObject(b) ? b : a.reject()
      })
    }

    function g(b, c) {
      if (!angular.isDefined(b["default"]))throw new ReferenceError('When used "redirectTo" as object, property "default" must be defined');
      var d = b[c];
      return angular.isDefined(d) || (d = b["default"]), angular.isFunction(d) ? f(d, c) : angular.isObject(d) ? a.resolve(d) : angular.isString(d) ? a.resolve({state: d}) : void 0
    }

    function h(a) {
      return angular.isString(a) ? [a] : angular.isArray(a) ? a : angular.isFunction(a) ? a.call(null, b) : []
    }

    return e.prototype.resolveRedirectState = function (b) {
      return angular.isFunction(this.redirectTo) ? f(this.redirectTo, b) : angular.isObject(this.redirectTo) ? g(this.redirectTo, b) : angular.isString(this.redirectTo) ? a.resolve({state: this.redirectTo}) : a.reject()
    }, e.prototype.resolvePropertyValidity = function (b) {
      return b.map(function (b) {
        if (c.hasRoleDefinition(b)) {
          var e = c.getRoleDefinition(b);
          return e.validateRole()
        }
        if (d.hasPermissionDefinition(b)) {
          var f = d.getPermissionDefinition(b);
          return f.validatePermission()
        }
        return a.reject(b)
      })
    }, e
  }

  a.$inject = ["$q", "TransitionProperties", "RoleStore", "PermissionStore"], angular.module("permission").factory("PermissionMap", a)
}();
//# sourceMappingURL=angular-permission.min.js.map