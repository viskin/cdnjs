{"version":3,"file":"incremental-dom.js","sources":["src/util.js","src/node_data.js","src/nodes.js","src/notifications.js","src/context.js","src/symbols.js","src/assertions.js","src/core.js","src/attributes.js","src/virtual_elements.js"],"sourcesContent":["/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A cached reference to the create function.\n */\nconst create = Object.create;\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nconst has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nconst createMap = function() {\n  return create(null);\n};\n\n\n/** */\nexport {\n  createMap,\n  has\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createMap } from './util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nconst initData = function(node, nodeName, key) {\n  const data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nconst getData = function(node) {\n  let data = node['__incrementalDOMData'];\n\n  if (!data) {\n    const nodeName = node.nodeName.toLowerCase();\n    let key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n\n/** */\nexport {\n  getData,\n  initData\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n    getData,\n    initData\n} from './node_data';\nimport { createMap } from './util';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nconst getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @return {!Element}\n */\nconst createElement = function(doc, parent, tag, key) {\n  const namespace = getNamespaceForTag(tag, parent);\n  let el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nconst createText = function(doc) {\n  const node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nconst createKeyMap = function(el) {\n  const map = createMap();\n  let child = el.firstElementChild;\n\n  while (child) {\n    const key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nconst getKeyMap = function(el) {\n  const data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nconst getChild = function(parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nconst registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n\n/** */\nexport {\n  createElement,\n  createText,\n  getChild,\n  registerChild\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\nexport {\n  notifications\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { notifications } from './notifications';\n\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n\n/** */\nexport {\n  Context\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nlet inAttributes = false;\n\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nlet inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n * @param {*} context\n */\nconst assertInPatch = function(context) {\n  if (!context) {\n    throw new Error('Cannot call currentElement() unless in patch.');\n  }\n};\n\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nconst assertKeyedTagMatches = function(nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\n        tag + ', not a ' + nodeName + '.');\n  }\n};\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nconst assertNoUnclosedTags = function(openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  let currentElement = openElement;\n  const openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' +\n      openTags.join('\\n'));\n};\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nconst assertNotInAttributes = function(functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() can not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nconst assertNotInSkip = function(functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nconst assertInAttributes = function(functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() can only be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nconst assertVirtualAttributesClosed = function() {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n  * Makes sure that placeholders have a key specified. Otherwise, conditional\n  * placeholders and conditional elements next to placeholders will cause\n  * placeholder elements to be re-used as non-placeholders and vice versa.\n  * @param {string} key\n  */\nconst assertPlaceholderKeySpecified = function(key) {\n  if (!key) {\n    throw new Error('elementPlaceholder() requires a key.');\n  }\n};\n\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nconst assertCloseMatchesOpenTag = function(nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close \"' + tag + '\" but \"' +\n        nodeName + '\" was open.');\n  }\n};\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nconst assertNoChildrenDeclaredYet = function(functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n};\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} node The node requested to be patched.\n * @param {?Node} currentNode The currentNode after the patch.\n */\nconst assertPatchElementNotEmpty = function(node, currentNode) {\n  if (node === currentNode) {\n    throw new Error('There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n};\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} node The node requested to be patched.\n * @param {?Node} previousNode The previousNode after the patch.\n */\nconst assertPatchElementNoExtras = function(node, previousNode) {\n  if (node !== previousNode) {\n    throw new Error('There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n};\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInAttributes = function(value) {\n  const previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInSkip = function(value) {\n  const previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n\n/** */\nexport {\n  assertInPatch,\n  assertKeyedTagMatches,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertInAttributes,\n  assertPlaceholderKeySpecified,\n  assertCloseMatchesOpenTag,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertNotInSkip,\n  assertPatchElementNotEmpty,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createElement,\n  createText,\n  getChild,\n  registerChild\n} from './nodes';\nimport { getData } from './node_data';\nimport { Context } from './context';\nimport { symbols } from './symbols';\nimport {\n  assertInPatch,\n  assertKeyedTagMatches,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertPatchElementNotEmpty,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n} from './assertions';\nimport { notifications } from './notifications';\n\n\n/** @type {?Context} */\nlet context = null;\n\n/** @type {?Node} */\nlet currentNode;\n\n/** @type {?Node} */\nlet currentParent;\n\n/** @type {?Element|?DocumentFragment} */\nlet root;\n\n/** @type {?Document} */\nlet doc;\n\n\n/**\n * Sets up and restores a patch context, running the patch function with the\n * provided data.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     where the patch should start.\n * @param {!function(T)} fn The patching function.\n * @param {T=} data An argument passed to fn.\n * @template T\n */\nconst runPatch = function(node, fn, data) {\n  const prevContext = context;\n  const prevRoot = root;\n  const prevDoc = doc;\n  const prevCurrentNode = currentNode;\n  const prevCurrentParent = currentParent;\n  let previousInAttributes = false;\n  let previousInSkip = false;\n\n  context = new Context();\n  root = node;\n  doc = node.ownerDocument;\n\n  if (process.env.NODE_ENV !== 'production') {\n    previousInAttributes = setInAttributes(false);\n    previousInSkip = setInSkip(false);\n  }\n\n  fn(data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertVirtualAttributesClosed();\n    setInAttributes(previousInAttributes);\n    setInSkip(previousInSkip);\n  }\n\n  context.notifyChanges();\n\n  context = prevContext;\n  root = prevRoot;\n  doc = prevDoc;\n  currentNode = prevCurrentNode;\n  currentParent = prevCurrentParent;\n};\n\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nconst patchInner = function(node, fn, data) {\n  runPatch(node, function(data) {\n    currentNode = node;\n    currentParent = node.parentNode;\n\n    enterNode();\n    fn(data);\n    exitNode();\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertNoUnclosedTags(currentNode, node);\n    }\n  }, data);\n};\n\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nconst patchOuter = function(node, fn, data) {\n  runPatch(node, function(data) {\n    currentNode = /** @type {!Element} */({ nextSibling: node });\n    currentParent = node.parentNode;\n\n    fn(data);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertPatchElementNotEmpty(node, currentNode.nextSibling);\n      assertPatchElementNoExtras(node, currentNode);\n    }\n  }, data);\n};\n\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nconst matches = function(nodeName, key) {\n  const data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {function(!Node, T)=} opt_initCallback\n * @param {T=} opt_initData\n * @template T\n */\nconst alignWithDOM = function(nodeName, key, opt_initCallback, opt_initData) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  let node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && process.env.NODE_ENV !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key);\n    }\n\n    if (opt_initCallback) {\n      opt_initCallback(opt_initData);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nconst clearUnvisitedDOM = function() {\n  const node = currentParent;\n  const data = getData(node);\n  const keyMap = data.keyMap;\n  const keyMapValid = data.keyMapValid;\n  let child = node.lastChild;\n  let key;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('symbols.placeholder will be removed in Incremental DOM' +\n          ' 0.5 use skip() instead');\n    }\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted(/** @type {!Node}*/(child));\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nconst enterNode = function() {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nconst nextNode = function() {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nconst exitNode = function() {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {!function(!Node, T)} initCallback\n * @param {T} initData\n * @return {!Element} The corresponding Element.\n * @template T\n */\nconst elementOpen = function(tag, key, initCallback, initData) {\n  nextNode();\n  alignWithDOM(tag, key, initCallback, initData);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(currentNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nconst text = function() {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return /** @type {!Text} */(currentNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nconst currentElement = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch(context);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nconst skip = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n\n/** */\nexport {\n  elementOpen,\n  elementClose,\n  text,\n  patchInner,\n  patchOuter,\n  currentElement,\n  skip\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  createMap,\n  has\n} from './util';\n\n\n/**\n * @param {string} name\n * @return {?string} The namespace to use for the attribute.\n */\nconst getNamespace = function(name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nconst applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    const attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nconst applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nconst applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    const elStyle = el.style;\n    const obj = /** @type {!Object<string,string>} */(style);\n\n    for (const prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nconst applyAttributeTyped = function(el, name, value) {\n  const type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nconst updateAttribute = function(el, name, value) {\n  const data = getData(el);\n  const attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  const mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nconst attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function() {};\n\nattributes['style'] = applyStyle;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  elementOpen as coreElementOpen,\n  elementClose as coreElementClose,\n  text as coreText,\n  currentElement,\n  skip\n} from './core';\nimport { updateAttribute } from './attributes';\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  assertNotInAttributes,\n  assertNotInSkip,\n  assertInAttributes,\n  assertPlaceholderKeySpecified,\n  assertCloseMatchesOpenTag,\n  setInAttributes\n} from './assertions';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nconst ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nconst argsBuilder = [];\n\n\n/**\n * @param {!Node} node\n * @param {?Array<*>=} statics\n */\nconst initElement = function(node, statics) {\n  if (!statics) {\n    return;\n  }\n\n  for (i = 0; i < statics.length; i += 2) {\n    updateAttribute(/** {!Element} */(node), statics[i], statics[i + 1]);\n  }\n};\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(tag, key, statics, const_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  const node = coreElementOpen(tag, key, initElement, statics);\n  const data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  const attrsArr = data.attrsArr;\n  const newAttrs = data.newAttrs;\n  let attrsChanged = false;\n  let i = ATTRIBUTES_OFFSET;\n  let j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (const attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n      newAttrs[attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nconst elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nconst attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  const node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  const node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementVoid = function(tag, key, statics, const_args) {\n  const node = elementOpen.apply(null, arguments);\n  elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementPlaceholder = function(tag, key, statics, const_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n    console.warn('elementPlaceholder will be removed in Incremental DOM 0.5' +\n        ' use skip() instead');\n  }\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose.apply(null, arguments);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nconst text = function(value, const_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  const node = coreText();\n  const data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    let formatted = value;\n    for (let i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      const fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  elementPlaceholder,\n  text,\n  attr\n};\n"],"names":["elementOpen","elementClose","text"],"mappings":"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","sourceRoot":"/source/"}