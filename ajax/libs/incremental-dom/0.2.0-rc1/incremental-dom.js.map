{"version":3,"sources":["incremental-dom.js","src/walker.js","src/node_data.js","src/namespace.js","src/traversal.js","src/tree_walker.js","src/attributes.js","src/nodes.js","src/alignment.js","src/patch.js","src/virtual_elements.js"],"names":[],"mappings":"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","file":"incremental-dom.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.IncrementalDOM = {}))\n}(this, function (exports) { 'use strict';\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /**\n   * @type {TreeWalker}\n   */\n  var walker_;\n\n\n  /**\n   * @return {TreeWalker} the current TreeWalker\n   */\n  var getWalker = function() {\n    return walker_;\n  };\n\n\n  /**\n   * Sets the current TreeWalker\n   * @param {TreeWalker} walker\n   */\n  var setWalker = function(walker) {\n    walker_ = walker;\n  };\n\n\n  /** */\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n\n  /**\n   * Keeps track of information needed to perform diffs for a given DOM node.\n   * @param {?string} nodeName\n   * @param {?string} key\n   * @constructor\n   */\n  function NodeData(nodeName, key) {\n    /**\n     * The attributes and their values.\n     * @const\n     */\n    this.attrs = {};\n\n    /**\n     * An array of attribute name/value pairs, used for quickly diffing the\n     * incomming attributes to see if the DOM node's attributes need to be\n     * updated.\n     * @const {Array<*>}\n     */\n    this.attrsArr = [];\n\n    /**\n     * The incoming attributes for this Node, before they are updated.\n     * @const {!Object<string, *>}\n     */\n    this.newAttrs = {};\n\n    /**\n     * The key used to identify this node, used to preserve DOM nodes when they\n     * move within their parent.\n     * @const\n     */\n    this.key = key;\n\n    /**\n     * Keeps track of children within this node by their key.\n     * {?Object<string, Node>}\n     */\n    this.keyMap = null;\n\n    /**\n     * The last child to have been visited within the current pass.\n     * {?Node}\n     */\n    this.lastVisitedChild = null;\n\n    /**\n     * The node name for this node.\n     * @const\n     */\n    this.nodeName = nodeName;\n\n    /**\n     * @const {string}\n     */\n    this.text = null;\n  }\n\n\n  /**\n   * Initializes a NodeData object for a Node.\n   *\n   * @param {!Node} node The node to initialize data for.\n   * @param {string} nodeName The node name of node.\n   * @param {?string} key The key that identifies the node.\n   * @return {!NodeData} The newly initialized data object\n   */\n  var initData = function(node, nodeName, key) {\n    var data = new NodeData(nodeName, key);\n    node['__incrementalDOMData'] = data;\n    return data;\n  };\n\n\n  /**\n   * Retrieves the NodeData object for a Node, creating it if necessary.\n   *\n   * @param {!Node} node The node to retrieve the data for.\n   * @return {NodeData} The NodeData for this Node.\n   */\n  var getData = function(node) {\n    var data = node['__incrementalDOMData'];\n\n    if (!data) {\n      var nodeName = node.nodeName.toLowerCase();\n      var key = null;\n\n      if (node instanceof Element) {\n        key = node.getAttribute('key');\n      }\n\n      data = initData(node, nodeName, key);\n    }\n\n    return data;\n  };\n\n\n  /** */\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var SVG_NS = 'http://www.w3.org/2000/svg';\n\n  /**\n   * Enters a tag, checking to see if it is a namespace boundary, and if so,\n   * updates the current namespace.\n   * @param {string} tag The tag to enter.\n   */\n  var enterTag = function(tag) {\n    if (tag === 'svg') {\n      getWalker().enterNamespace(SVG_NS);\n    } else if (tag === 'foreignObject') {\n      getWalker().enterNamespace(undefined);\n    }\n  };\n\n\n  /**\n   * Exits a tag, checking to see if it is a namespace boundary, and if so,\n   * updates the current namespace.\n   * @param {string} tag The tag to enter.\n   */\n  var exitTag = function(tag) {\n    if (tag === 'svg' || tag === 'foreignObject') {\n      getWalker().exitNamespace();\n    }\n  };\n\n\n  /**\n   * Gets the namespace to create an element (of a given tag) in.\n   * @param {string} tag The tag to get the namespace for.\n   * @return {string} The namespace to create the tag in.\n   */\n  var getNamespaceForTag = function(tag) {\n    if (tag === 'svg') {\n      return SVG_NS;\n    }\n\n    return getWalker().getCurrentNamespace();\n  };\n\n\n  /** */\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var traversal__dummy;\n\n\n  /**\n   * Enters an Element, setting the current namespace for nested elements.\n   * @param {!Element} node\n   */\n  var enterNode = function(node) {\n    var data = getData(node);\n    enterTag(data.nodeName);\n  };\n\n\n  /**\n   * Exits an Element, unwinding the current namespace to the previous value.\n   * @param {!Element} node\n   */\n  var exitNode = function(node) {\n    var data = getData(node);\n    exitTag(data.nodeName);\n  };\n\n\n  /**\n   * Marks node's parent as having visited node.\n   * @param {!Node} node\n   */\n  var markVisited = function(node) {\n    var walker = getWalker();\n    var parent = walker.getCurrentParent();\n    var data = getData(parent);\n    data.lastVisitedChild = node;\n  };\n\n\n  /**\n   * Changes to the first child of the current node.\n   */\n  var firstChild = function() {\n    var walker = getWalker();\n    enterNode(walker.currentNode);\n    walker.firstChild();\n  };\n\n\n  /**\n   * Changes to the next sibling of the current node.\n   */\n  var nextSibling = function() {\n    var walker = getWalker();\n    markVisited(walker.currentNode);\n    walker.nextSibling();\n  };\n\n\n  /**\n   * Changes to the parent of the current node, removing any unvisited children.\n   */\n  var parentNode = function() {\n    var walker = getWalker();\n    walker.parentNode();\n    exitNode(walker.currentNode);\n  };\n\n\n  /** */\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /**\n   * Similar to the built-in Treewalker class, but simplified and allows direct\n   * access to modify the currentNode property.\n   * @param {!Node} node The root Node of the subtree the walker should start\n   *     traversing.\n   * @constructor\n   */\n  function TreeWalker(node) {\n    /**\n     * Keeps track of the current parent node. This is necessary as the traversal\n     * methods may traverse past the last child and we still need a way to get\n     * back to the parent.\n     * @const @private {!Array<!Node>}\n     */\n    this.stack_ = [];\n\n    /** {?Node} */\n    this.currentNode = node;\n\n    /** {!Document} */\n    this.doc = node.ownerDocument;\n\n    /**\n     * Keeps track of what namespace to create new Elements in.\n     * @const @private {!Array<string>}\n     */\n    this.nsStack_ = [undefined];\n  }\n\n\n  /**\n   * @return {!Node} The current parent of the current location in the subtree.\n   */\n  TreeWalker.prototype.getCurrentParent = function() {\n    return this.stack_[this.stack_.length - 1];\n  };\n\n\n  /**\n   * @return {string} The current namespace to create Elements in.\n   */\n  TreeWalker.prototype.getCurrentNamespace = function() {\n    return this.nsStack_[this.nsStack_.length - 1];\n  };\n\n\n  /**\n   * @param {string} namespace The namespace to enter.\n   */\n  TreeWalker.prototype.enterNamespace = function(namespace) {\n    this.nsStack_.push(namespace);\n  };\n\n\n  /**\n   * Exits the current namespace\n   */\n  TreeWalker.prototype.exitNamespace = function() {\n    this.nsStack_.pop();\n  };\n\n\n  /**\n   * Changes the current location the firstChild of the current location.\n   */\n  TreeWalker.prototype.firstChild = function() {\n    this.stack_.push(this.currentNode);\n    this.currentNode = this.currentNode.firstChild;\n  };\n\n\n  /**\n   * Changes the current location the nextSibling of the current location.\n   */\n  TreeWalker.prototype.nextSibling = function() {\n    this.currentNode = this.currentNode.nextSibling;\n  };\n\n\n  /**\n   * Changes the current location the parentNode of the current location.\n   */\n  TreeWalker.prototype.parentNode = function() {\n    this.currentNode = this.stack_.pop();\n  };\n\n\n  /** */\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var attributes = {\n    /**\n     * Applies an attribute or property to a given Element. If the value is a\n     * object or a function (which includes null), it is set as a property on the\n     * Element. Otherwise, the value is set as an attribute.\n     * @param {!Element} el\n     * @param {string} name The attribute's name.\n     * @param {*} value The attribute's value. If the value is a string, it is set\n     *     as an HTML attribute, otherwise, it is set on node.\n     */\n    applyAttr: function(el, name, value) {\n      var type = typeof value;\n\n      if (type === 'object' || type === 'function') {\n        el[name] = value;\n      } else if (value === undefined) {\n        el.removeAttribute(name);\n      } else {\n        el.setAttribute(name, value);\n      }\n    },\n\n\n    /**\n     * Applies a style to an Element. No vendor prefix expansion is done for\n     * property names/values.\n     * @param {!Element} el\n     * @param {string|Object<string,string>} style The style to set. Either a\n     *     string of css or an object containing property-value pairs.\n     */\n    applyStyle: function(el, style) {\n      if (typeof style === 'string') {\n        el.style.cssText = style;\n      } else {\n        el.style.cssText = '';\n\n        for (var prop in style) {\n          el.style[prop] = style[prop];\n        }\n      }\n    },\n\n\n    /**\n     * Updates a single attribute on an Element.\n     * @param {!Element} el\n     * @param {string} name The attribute's name.\n     * @param {*} value The attribute's value. If the value is a string, it is set\n     *     as an HTML attribute, otherwise, it is set on node.\n     */\n    updateAttribute: function(el, name, value) {\n      var data = getData(el);\n      var attrs = data.attrs;\n\n      if (attrs[name] === value) {\n        return;\n      }\n\n      if (name === 'style') {\n        attributes.applyStyle(el, value);\n      } else {\n        attributes.applyAttr(el, name, value);\n      }\n\n      attrs[name] = value;\n    }\n  };\n\n\n  /** */\n\n  exports.attributes = attributes;\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var nodes__dummy;\n\n\n  /**\n   * Creates an Element.\n   * @param {!Document} doc The document with which to create the Element.\n   * @param {string} tag The tag for the Element.\n   * @param {?string} key A key to identify the Element.\n   * @param {?Array<*>} statics An array of attribute name/value pairs of\n   *     the static attributes for the Element.\n   * @return {!Element}\n   */\n  var createElement = function(doc, tag, key, statics) {\n    var namespace = getNamespaceForTag(tag);\n    var el;\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, tag);\n    } else {\n      el = doc.createElement(tag);\n    }\n\n    initData(el, tag, key);\n\n    if (statics) {\n      for (var i = 0; i < statics.length; i += 2) {\n        attributes.updateAttribute(el, statics[i], statics[i + 1]);\n      }\n    }\n\n    return el;\n  };\n\n\n  /**\n   * Creates a Node, either a Text or an Element depending on the node name\n   * provided.\n   * @param {!Document} doc The document with which to create the Node.\n   * @param {string} nodeName The tag if creating an element or #text to create\n   *     a Text.\n   * @param {?string} key A key to identify the Element.\n   * @param {?Array<*>} statics The static data to initialize the Node\n   *     with. For an Element, an array of attribute name/value pairs of\n   *     the static attributes for the Element.\n   * @return {!Node}\n   */\n  var createNode = function(doc, nodeName, key, statics) {\n    if (nodeName === '#text') {\n      return doc.createTextNode('');\n    }\n\n    return createElement(doc, nodeName, key, statics);\n  };\n\n\n  /**\n   * Creates a mapping that can be used to look up children using a key.\n   * @param {!Element} el\n   * @return {!Object<string, !Node>} A mapping of keys to the children of the\n   *     Element.\n   */\n  var createKeyMap = function(el) {\n    var map = {};\n    var children = el.children;\n    var count = children.length;\n\n    for (var i = 0; i < count; i += 1) {\n      var child = children[i];\n      var key = getData(child).key;\n\n      if (key) {\n        map[key] = child;\n      }\n    }\n\n    return map;\n  };\n\n\n  /**\n   * Retrieves the mapping of key to child node for a given Element, creating it\n   * if necessary.\n   * @param {!Element} el\n   * @return {!Object<string,!Node>} A mapping of keys to child Nodes\n   */\n  var getKeyMap = function(el) {\n    var data = getData(el);\n\n    if (!data.keyMap) {\n      data.keyMap = createKeyMap(el);\n    }\n\n    return data.keyMap;\n  };\n\n\n  /**\n   * Retrieves a child from the parent with the given key.\n   * @param {!Element} parent\n   * @param {?string} key\n   * @return {?Node} The child corresponding to the key.\n   */\n  var getChild = function(parent, key) {\n    return getKeyMap(parent)[key];\n  };\n\n\n  /**\n   * Registers a node as being a child. The parent will keep track of the child\n   * using the key. The child can be retrieved using the same key using\n   * getKeyMap. The provided key should be unique within the parent Element.\n   * @param {!Element} parent The parent of child.\n   * @param {string} key A key to identify the child with.\n   * @param {!Node} child The child to register.\n   */\n  var registerChild = function(parent, key, child) {\n    getKeyMap(parent)[key] = child;\n  };\n\n\n  /** */\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var alignment__dummy;\n\n\n  /**\n   * Checks whether or not a given node matches the specified nodeName and key.\n   *\n   * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n   * @param {?string} nodeName The nodeName for this node.\n   * @param {?string} key An optional key that identifies a node.\n   * @return {boolean} True if the node matches, false otherwise.\n   */\n  var matches = function(node, nodeName, key) {\n    var data = getData(node);\n\n    // Key check is done using double equals as we want to treat a null key the\n    // same as undefined. This should be okay as the only values allowed are\n    // strings, null and undefined so the == semantics are not too weird.\n    return key == data.key &&\n           nodeName === data.nodeName;\n  };\n\n\n  /**\n   * Aligns the virtual Element definition with the actual DOM, moving the\n   * corresponding DOM node to the correct location or creating it if necessary.\n   * @param {?string} nodeName For an Element, this should be a valid tag string.\n   *     For a Text, this should be #text.\n   * @param {?string} key The key used to identify this element.\n   * @param {?Array<*>} statics For an Element, this should be an array of\n   *     name-value pairs.\n   * @return {!Node} The matching node.\n   */\n  var alignWithDOM = function(nodeName, key, statics) {\n    var walker = getWalker();\n    var currentNode = walker.currentNode;\n    var parent = walker.getCurrentParent();\n    var matchingNode;\n\n    // Check to see if we have a node to reuse\n    if (currentNode && matches(currentNode, nodeName, key)) {\n      matchingNode = currentNode;\n    } else {\n      var existingNode = key && getChild(parent, key);\n\n      // Check to see if the node has moved within the parent or if a new one\n      // should be created\n      if (existingNode && matches(existingNode, nodeName, key)) {\n        matchingNode = existingNode;\n      } else {\n        matchingNode = createNode(walker.doc, nodeName, key, statics);\n        if (key) {\n          registerChild(parent, key, matchingNode);\n        }\n      }\n\n      parent.insertBefore(matchingNode, currentNode);\n      walker.currentNode = matchingNode;\n    }\n\n    return matchingNode;\n  };\n\n\n  /**\n   * Clears out any unvisited Nodes, as the corresponding virtual element\n   * functions were never called for them.\n   * @param {!Element} node\n   */\n  var clearUnvisitedDOM = function(node) {\n    var data = getData(node);\n    var lastChild = node.lastChild;\n    var lastVisitedChild = data.lastVisitedChild;\n    data.lastVisitedChild = null;\n\n    if (lastChild === lastVisitedChild) {\n      return;\n    }\n\n    while (lastChild !== lastVisitedChild) {\n      node.removeChild(lastChild);\n      lastChild = node.lastChild;\n    }\n\n    // Invalidate the key map since we removed children. It will get recreated\n    // next time we need it.\n    data.keyMap = null;\n  };\n\n\n  /** */\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var src_patch__dummy;\n\n\n  /**\n   * @const {boolean}\n   */\n  if (process.env.NODE_ENV !== 'production') {\n    var assertNoUnclosedTags = function(root) {\n      var openElement = getWalker().getCurrentParent();\n      if (!openElement) {\n        return;\n      }\n\n      var openTags = [];\n      while (openElement && openElement !== root) {\n        openTags.push(openElement.nodeName.toLowerCase());\n        openElement = openElement.parentNode;\n      }\n\n      throw new Error('One or more tags were not closed:\\n' +\n          openTags.join('\\n'));\n    };\n  }\n\n\n  /**\n   * Patches the document starting at el with the provided function. This function\n   * may be called during an existing patch operation.\n   * @param {!Element|!Document} node The Element or Document to patch.\n   * @param {!function} fn A function containing elementOpen/elementClose/etc.\n   *     calls that describe the DOM.\n   * @param {*} data An argument passed to fn to represent DOM state.\n   */\n  var patch = function(node, fn, data) {\n    var prevWalker = getWalker();\n    setWalker(new TreeWalker(node));\n\n    firstChild();\n    fn(data);\n    parentNode();\n    clearUnvisitedDOM(node);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertNoUnclosedTags(node);\n    }\n\n    setWalker(prevWalker);\n  };\n\n\n  /** */\n\n  exports.patch = patch;\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var virtual_elements__dummy;\n\n\n  /**\n   * The offset in the virtual element declaration where the attributes are\n   * specified.\n   * @const\n   */\n  var ATTRIBUTES_OFFSET = 3;\n\n\n  /**\n   * Builds an array of arguments for use with elementOpenStart, attr and\n   * elementOpenEnd.\n   * @const {Array<*>}\n   */\n  var argsBuilder = [];\n\n\n  if (process.env.NODE_ENV !== 'production') {\n    /**\n     * Keeps track whether or not we are in an attributes declaration (after\n     * elementOpenStart, but before elementOpenEnd).\n     * @type {boolean}\n     */\n    var inAttributes = false;\n\n\n    /** Makes sure that the caller is not where attributes are expected. */\n    var assertNotInAttributes = function() {\n      if (inAttributes) {\n        throw new Error('Was not expecting a call to attr or elementOpenEnd, ' +\n            'they must follow a call to elementOpenStart.');\n      }\n    };\n\n\n    /** Makes sure that the caller is where attributes are expected. */\n    var assertInAttributes = function() {\n      if (!inAttributes) {\n        throw new Error('Was expecting a call to attr or elementOpenEnd. ' +\n            'elementOpenStart must be followed by zero or more calls to attr, ' +\n            'then one call to elementOpenEnd.');\n      }\n    };\n\n\n    /**\n     * Makes sure that tags are correctly nested.\n     * @param {string} tag\n     */\n    var assertCloseMatchesOpenTag = function(tag) {\n      var closingNode = getWalker().getCurrentParent();\n      var data = getData(closingNode);\n\n      if (tag !== data.nodeName) {\n        throw new Error('Received a call to close ' + tag + ' but ' +\n              data.nodeName + ' was open.');\n      }\n    };\n\n\n    /** Updates the state to being in an attribute declaration. */\n    var setInAttributes = function() {\n      inAttributes = true;\n    };\n\n\n    /** Updates the state to not being in an attribute declaration. */\n    var setNotInAttributes = function() {\n      inAttributes = false;\n    };\n  }\n\n\n  var elementOpen = function(tag, key, statics, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n    }\n\n    var node = alignWithDOM(tag, key, statics);\n    var data = getData(node);\n\n    /*\n     * Checks to see if one or more attributes have changed for a given Element.\n     * When no attributes have changed, this is much faster than checking each\n     * individual argument. When attributes have changed, the overhead of this is\n     * minimal.\n     */\n    var attrsArr = data.attrsArr;\n    var attrsChanged = false;\n    var i = ATTRIBUTES_OFFSET;\n    var j = 0;\n\n    for (; i < arguments.length; i += 1, j += 1) {\n      if (attrsArr[j] !== arguments[i]) {\n        attrsChanged = true;\n        break;\n      }\n    }\n\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsChanged = true;\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    if (attrsChanged) {\n      var newAttrs = data.newAttrs;\n\n      for (var attr in newAttrs) {\n        newAttrs[attr] = undefined;\n      }\n\n      for (var i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n        newAttrs[arguments[i]] = arguments[i + 1];\n      }\n\n      for (var attr in newAttrs) {\n        attributes.updateAttribute(node, attr, newAttrs[attr]);\n      }\n    }\n\n    firstChild();\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Element at the current location in the document. This\n   * corresponds to an opening tag and a elementClose tag is required. This is\n   * like elementOpen, but the attributes are defined using the attr function\n   * rather than being passed as arguments. Must be folllowed by 0 or more calls\n   * to attr, then a call to elementOpenEnd.\n   * @param {string} tag The element's tag.\n   * @param {?string} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   */\n  var elementOpenStart = function(tag, key, statics) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n      setInAttributes();\n    }\n\n    argsBuilder[0] = tag;\n    argsBuilder[1] = key;\n    argsBuilder[2] = statics;\n  };\n\n\n  /***\n   * Defines a virtual attribute at this point of the DOM. This is only valid\n   * when called between elementOpenStart and elementOpenEnd.\n   *\n   * @param {string} name\n   * @param {*} value\n   */\n  var attr = function(name, value) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertInAttributes();\n    }\n\n    argsBuilder.push(name, value);\n  };\n\n\n  /**\n   * Closes an open tag started with elementOpenStart.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementOpenEnd = function() {\n    if (process.env.NODE_ENV !== 'production') {\n      assertInAttributes();\n      setNotInAttributes();\n    }\n\n    var node = elementOpen.apply(null, argsBuilder);\n    argsBuilder.length = 0;\n    return node;\n  };\n\n\n  /**\n   * Closes an open virtual Element.\n   *\n   * @param {string} tag The element's tag.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementClose = function(tag) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n      assertCloseMatchesOpenTag(tag);\n    }\n\n    parentNode();\n\n    var node = getWalker().currentNode;\n    clearUnvisitedDOM(node);\n\n    nextSibling();\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Element at the current location in the document that has\n   * no children.\n   * @param {string} tag The element's tag.\n   * @param {?string} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementVoid = function(tag, key, statics, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n    }\n\n    var node = elementOpen.apply(null, arguments);\n    elementClose.apply(null, arguments);\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Text at this point in the document.\n   *\n   * @param {string|number|boolean} value The value of the Text.\n   * @param {...(function(string|number|boolean):string|number|boolean)} var_args\n   *     Functions to format the value which are called only when the value has\n   *     changed.\n   */\n  var text = function(value, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n    }\n\n    var node = alignWithDOM('#text', null);\n    var data = getData(node);\n\n    if (data.text !== value) {\n      data.text = value;\n\n      var formatted = value;\n      for (var i = 1; i < arguments.length; i += 1) {\n        formatted = arguments[i](formatted);\n      }\n\n      node.data = formatted;\n    }\n\n    nextSibling();\n  };\n\n\n  /** */\n\n  exports.elementVoid = elementVoid;\n  exports.elementOpenStart = elementOpenStart;\n  exports.elementOpenEnd = elementOpenEnd;\n  exports.elementOpen = elementOpen;\n  exports.elementClose = elementClose;\n  exports.text = text;\n  exports.attr = attr;\n\n  /**\n   * @license\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n}));\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @type {TreeWalker}\n */\nvar walker_;\n\n\n/**\n * @return {TreeWalker} the current TreeWalker\n */\nvar getWalker = function() {\n  return walker_;\n};\n\n\n/**\n * Sets the current TreeWalker\n * @param {TreeWalker} walker\n */\nvar setWalker = function(walker) {\n  walker_ = walker;\n};\n\n\n/** */\nexport {\n  getWalker,\n  setWalker\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {?string} nodeName\n * @param {?string} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = {};\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = {};\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, Node>}\n   */\n  this.keyMap = null;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @const {string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {!Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function(node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {!Node} node The node to retrieve the data for.\n * @return {NodeData} The NodeData for this Node.\n */\nvar getData = function(node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n\n/** */\nexport {\n  getData,\n  initData\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getWalker } from './walker';\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function(tag) {\n  if (tag === 'svg') {\n    getWalker().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getWalker().enterNamespace(undefined);\n  }\n};\n\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function(tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getWalker().exitNamespace();\n  }\n};\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function(tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getWalker().getCurrentNamespace();\n};\n\n\n/** */\nexport {\n  enterTag,\n  exitTag,\n  getNamespaceForTag\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getWalker } from './walker';\nimport { getData } from './node_data';\nimport {\n  enterTag,\n  exitTag\n} from './namespace';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\n/**\n * Enters an Element, setting the current namespace for nested elements.\n * @param {!Element} node\n */\nvar enterNode = function(node) {\n  var data = getData(node);\n  enterTag(data.nodeName);\n};\n\n\n/**\n * Exits an Element, unwinding the current namespace to the previous value.\n * @param {!Element} node\n */\nvar exitNode = function(node) {\n  var data = getData(node);\n  exitTag(data.nodeName);\n};\n\n\n/**\n * Marks node's parent as having visited node.\n * @param {!Node} node\n */\nvar markVisited = function(node) {\n  var walker = getWalker();\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function() {\n  var walker = getWalker();\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function() {\n  var walker = getWalker();\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function() {\n  var walker = getWalker();\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\n\n/** */\nexport {\n  firstChild,\n  nextSibling,\n  parentNode\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Node} node The root Node of the subtree the walker should start\n *     traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /** {?Node} */\n  this.currentNode = node;\n\n  /** {!Document} */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @const @private {!Array<string>}\n   */\n  this.nsStack_ = [undefined];\n}\n\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function() {\n  return this.stack_[this.stack_.length - 1];\n};\n\n\n/**\n * @return {string} The current namespace to create Elements in.\n */\nTreeWalker.prototype.getCurrentNamespace = function() {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n\n/**\n * @param {string} namespace The namespace to enter.\n */\nTreeWalker.prototype.enterNamespace = function(namespace) {\n  this.nsStack_.push(namespace);\n};\n\n\n/**\n * Exits the current namespace\n */\nTreeWalker.prototype.exitNamespace = function() {\n  this.nsStack_.pop();\n};\n\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function() {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function() {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function() {\n  this.currentNode = this.stack_.pop();\n};\n\n\n/** */\nexport {\n  TreeWalker\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getData } from './node_data';\n\n\nvar attributes = {\n  /**\n   * Applies an attribute or property to a given Element. If the value is a\n   * object or a function (which includes null), it is set as a property on the\n   * Element. Otherwise, the value is set as an attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value. If the value is a string, it is set\n   *     as an HTML attribute, otherwise, it is set on node.\n   */\n  applyAttr: function(el, name, value) {\n    var type = typeof value;\n\n    if (type === 'object' || type === 'function') {\n      el[name] = value;\n    } else if (value === undefined) {\n      el.removeAttribute(name);\n    } else {\n      el.setAttribute(name, value);\n    }\n  },\n\n\n  /**\n   * Applies a style to an Element. No vendor prefix expansion is done for\n   * property names/values.\n   * @param {!Element} el\n   * @param {string|Object<string,string>} style The style to set. Either a\n   *     string of css or an object containing property-value pairs.\n   */\n  applyStyle: function(el, style) {\n    if (typeof style === 'string') {\n      el.style.cssText = style;\n    } else {\n      el.style.cssText = '';\n\n      for (var prop in style) {\n        el.style[prop] = style[prop];\n      }\n    }\n  },\n\n\n  /**\n   * Updates a single attribute on an Element.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value. If the value is a string, it is set\n   *     as an HTML attribute, otherwise, it is set on node.\n   */\n  updateAttribute: function(el, name, value) {\n    var data = getData(el);\n    var attrs = data.attrs;\n\n    if (attrs[name] === value) {\n      return;\n    }\n\n    if (name === 'style') {\n      attributes.applyStyle(el, value);\n    } else {\n      attributes.applyAttr(el, name, value);\n    }\n\n    attrs[name] = value;\n  }\n};\n\n\n/** */\nexport {\n  attributes\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { attributes } from './attributes';\nimport {\n    getData,\n    initData\n} from './node_data';\nimport { getNamespaceForTag } from './namespace';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\n/**\n * Creates an Element.\n * @param {!Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string} key A key to identify the Element.\n * @param {?Array<*>} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function(doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      attributes.updateAttribute(el, statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {!Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string} key A key to identify the Element.\n * @param {?Array<*>} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Node}\n */\nvar createNode = function(doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return doc.createTextNode('');\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Element} el\n * @return {!Object<string, !Node>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function(el) {\n  var map = {};\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Element} el\n * @return {!Object<string,!Node>} A mapping of keys to child Nodes\n */\nvar getKeyMap = function(el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Element} parent\n * @param {?string} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function(parent, key) {\n  return getKeyMap(parent)[key];\n};\n\n\n/**\n * Registers a node as being a child. The parent will keep track of the child\n * using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Element} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n\n/** */\nexport {\n  createNode,\n  getChild,\n  registerChild\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n    createNode,\n    getChild,\n    registerChild\n} from './nodes';\nimport { getData } from './node_data';\nimport { getWalker } from './walker';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function(node, nodeName, key) {\n  var data = getData(node);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return key == data.key &&\n         nodeName === data.nodeName;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {?string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string} key The key used to identify this element.\n * @param {?Array<*>} statics For an Element, this should be an array of\n *     name-value pairs.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function(nodeName, key, statics) {\n  var walker = getWalker();\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = key && getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode && matches(existingNode, nodeName, key)) {\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(walker.doc, nodeName, key, statics);\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n    }\n\n    parent.insertBefore(matchingNode, currentNode);\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n * @param {!Element} node\n */\nvar clearUnvisitedDOM = function(node) {\n  var data = getData(node);\n  var lastChild = node.lastChild;\n  var lastVisitedChild = data.lastVisitedChild;\n  data.lastVisitedChild = null;\n\n  if (lastChild === lastVisitedChild) {\n    return;\n  }\n\n  while (lastChild !== lastVisitedChild) {\n    node.removeChild(lastChild);\n    lastChild = node.lastChild;\n  }\n\n  // Invalidate the key map since we removed children. It will get recreated\n  // next time we need it.\n  data.keyMap = null;\n};\n\n\n/** */\nexport {\n  alignWithDOM,\n  clearUnvisitedDOM\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n    firstChild,\n    parentNode\n} from './traversal';\nimport { TreeWalker } from './tree_walker';\nimport {\n    getWalker,\n    setWalker\n} from './walker';\nimport { clearUnvisitedDOM } from './alignment';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\n/**\n * @const {boolean}\n */\nif (process.env.NODE_ENV !== 'production') {\n  var assertNoUnclosedTags = function(root) {\n    var openElement = getWalker().getCurrentParent();\n    if (!openElement) {\n      return;\n    }\n\n    var openTags = [];\n    while (openElement && openElement !== root) {\n      openTags.push(openElement.nodeName.toLowerCase());\n      openElement = openElement.parentNode;\n    }\n\n    throw new Error('One or more tags were not closed:\\n' +\n        openTags.join('\\n'));\n  };\n}\n\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!Document} node The Element or Document to patch.\n * @param {!function} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {*} data An argument passed to fn to represent DOM state.\n */\nvar patch = function(node, fn, data) {\n  var prevWalker = getWalker();\n  setWalker(new TreeWalker(node));\n\n  firstChild();\n  fn(data);\n  parentNode();\n  clearUnvisitedDOM(node);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(node);\n  }\n\n  setWalker(prevWalker);\n};\n\n\n/** */\nexport {\n  patch\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  alignWithDOM,\n  clearUnvisitedDOM\n} from './alignment';\nimport { attributes } from './attributes';\nimport { getData } from './node_data';\nimport { getWalker } from './walker';\nimport {\n    firstChild,\n    nextSibling,\n    parentNode\n} from './traversal';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function() {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' +\n          'they must follow a call to elementOpenStart.');\n    }\n  };\n\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function() {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' +\n          'elementOpenStart must be followed by zero or more calls to attr, ' +\n          'then one call to elementOpenEnd.');\n    }\n  };\n\n\n  /**\n   * Makes sure that tags are correctly nested.\n   * @param {string} tag\n   */\n  var assertCloseMatchesOpenTag = function(tag) {\n    var closingNode = getWalker().getCurrentParent();\n    var data = getData(closingNode);\n\n    if (tag !== data.nodeName) {\n      throw new Error('Received a call to close ' + tag + ' but ' +\n            data.nodeName + ' was open.');\n    }\n  };\n\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function() {\n    inAttributes = true;\n  };\n\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function() {\n    inAttributes = false;\n  };\n}\n\n\nvar elementOpen = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = alignWithDOM(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    var newAttrs = data.newAttrs;\n\n    for (var attr in newAttrs) {\n      newAttrs[attr] = undefined;\n    }\n\n    for (var i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var attr in newAttrs) {\n      attributes.updateAttribute(node, attr, newAttrs[attr]);\n    }\n  }\n\n  firstChild();\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    assertCloseMatchesOpenTag(tag);\n  }\n\n  parentNode();\n\n  var node = getWalker().currentNode;\n  clearUnvisitedDOM(node);\n\n  nextSibling();\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = elementOpen.apply(null, arguments);\n  elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function(string|number|boolean):string|number|boolean)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n */\nvar text = function(value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = alignWithDOM('#text', null);\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  nextSibling();\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  text,\n  attr\n};\n\n"],"sourceRoot":"/source/"}