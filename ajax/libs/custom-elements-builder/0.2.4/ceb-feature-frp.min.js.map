{"version":3,"file":"ceb-feature-frp.min.js","sources":["../src/ceb-feature-frp.js"],"names":["g","factory","exports","module","define","amd","cebFeatureFrp","this","feature","el","__cebFrpScope","emptyFn","disposable","disposableFactory","handlers","handlersFactory","anotherDisposable","defaultLibraries","libraries","none","propertyObserverFactory","Error","propertyObservableInterceptor","disposeDisposable","setup","struct","builder","options","observerProperties","defaultLibrary","library","Object","keys","properties","map","propName","property","filter","entry","observable","forEach","valueFactory","attName","set","intercept","wrap","next","arguments","disposables","undefined"],"mappings":";;;;;;;;CAAC,SAAUA,EAAGC,GACV,YAKuB,iBAAZC,SACPC,OAAOD,QAAUD,IACQ,kBAAXG,SAAyBA,OAAOC,IAC9CD,OAAO,qBAAuBH,GAE9BD,EAAEM,cAAgBL,KAGxBM,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHKA,GAAGC,gBACJD,EAAGC,kBAEAD,EAAGC,cAsDd,QAASC,KACL,MAAO,cAwEX,MA1HAH,GAAQI,WAAa,SAAUC,GAW3B,MAVAA,GAAkBC,SAAW,SAAUC,GACnC,MAAO,UAAUN,GACb,GAAIG,GAAaC,EAAkBJ,GAC/BO,EAAoBD,EAAgBN,EAAIG,EAC5C,OAAII,GACOA,EAEJJ,IAGRC,GAKXL,EAAQS,iBAAmB,OAE3BT,EAAQU,WACHC,SAMLX,EAAQU,UAAUC,KAAKC,wBAA0B,WAC7C,KAAM,IAAIC,OAAM,qBASpBb,EAAQU,UAAUC,KAAKG,8BAAgC,WACnD,KAAM,IAAID,OAAM,qBAMpBb,EAAQU,UAAUC,KAAKI,kBAAoB,WACvC,KAAM,IAAIF,OAAM,qBAUpBb,EAAQgB,MAAQ,SAAUC,EAAQC,EAASC,GACvC,GAAIC,MACAC,EAAiBrB,EAAQU,UAAUS,EAAQG,SAAWtB,EAAQqB,gBAE9DT,EAA0BO,EAAQP,yBAA2BS,EAAeT,wBAC5EE,EAAgCK,EAAQL,+BAAiCO,EAAeP,8BACxFC,EAAoBI,EAAQJ,mBAAqBM,EAAeN,iBAGpEQ,QAAOC,KAAKP,EAAOQ,YAAYC,IAAI,SAAUC,GACzC,OACIA,SAAUA,EACVC,SAAUX,EAAOQ,WAAWE,MAEjCE,OAAO,SAAUC,GAChB,MAAOA,GAAMF,SAASG,aACvBC,QAAQ,SAAUF,GAEjBV,EAAmBU,EAAMH,SAAW,aAChCM,aAAcrB,GAGbkB,EAAMF,SAASM,SAAYJ,EAAMF,SAASO,MAC3CL,EAAMF,SAASO,IAAMhC,KAGzBe,EAAQkB,UAAUN,EAAMH,SAAUb,KAItCI,EAAQO,WAAWL,GAEnBF,EAAQmB,KAAK,kBAAmB,SAAUC,EAAMrC,GAC5CqC,EAAKC,WAELvC,EAAQC,GAAIuC,aAAerB,EAAQqB,iBAAmBd,IAAI,SAAUrB,GAChE,MAAOA,GAAkBJ,OAIjCiB,EAAQmB,KAAK,mBAAoB,SAAUC,EAAMrC,GAE7CsB,OAAOC,KAAKJ,GAAoBY,QAAQ,SAAUL,GACzC1B,EAAG0B,KACJ1B,EAAG0B,GAAYf,EAAwBX,MAI1CD,EAAQC,GAAIuC,cACbxC,EAAQC,GAAIuC,aAAerB,EAAQqB,iBAAmBd,IAAI,SAAUrB,GAChE,MAAOA,GAAkBJ,MAGjCqC,EAAKC,aAGTrB,EAAQmB,KAAK,mBAAoB,SAAUC,EAAMrC,GAC7CqC,EAAKC,WAELhB,OAAOC,KAAKJ,GAAoBY,QAAQ,SAAUL,GAC9CZ,EAAkBd,EAAG0B,IACrB1B,EAAG0B,GAAYc,SAGnBzC,EAAQC,GAAIuC,YAAYR,QAAQjB,GAChCf,EAAQC,GAAIuC,YAAc,QAI3BxC","sourcesContent":["(function (g, factory) {\n    'use strict';\n\n    // Export the **ceb-feature-frp** function according the detected loader.\n\n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb-feature-frp', [], factory);\n    } else {\n        g.cebFeatureFrp = factory();\n    }\n\n}(this, function () {\n    'use strict';\n\n    // ## Feature function\n\n    // The FRP feature's function returns nothing for public API.\n    function feature(el) {\n        if (!el.__cebFrpScope) {\n            el.__cebFrpScope = {};\n        }\n        return el.__cebFrpScope;\n    }\n\n    // ## Observer factory\n\n    feature.disposable = function (disposableFactory) {\n        disposableFactory.handlers = function (handlersFactory) {\n            return function (el) {\n                var disposable = disposableFactory(el);\n                var anotherDisposable = handlersFactory(el, disposable);\n                if (anotherDisposable) {\n                    return anotherDisposable;\n                }\n                return disposable;\n            };\n        };\n        return disposableFactory;\n    };\n\n    // ## Default library\n\n    feature.defaultLibraries = 'none';\n\n    feature.libraries = {\n         none: {}\n    };\n\n    // This function must returns the instance to the property observer.\n    // > @param el (HTMLElement) the current element\n    /* istanbul ignore next */\n    feature.libraries.none.propertyObserverFactory = function defaultPropertyObserverFactory() {\n        throw new Error('not implemented!');\n    };\n\n    // When the observed property is set, the value must be pushed into the stream.\n    // > @param next (function) will call the next stacked callback\n    // > @param el (HTMLElement) the current element\n    // > @param propName (string) the name of the observed property\n    // > @param value (*) the value of the previous stacked callback\n    /* istanbul ignore next */\n    feature.libraries.none.propertyObservableInterceptor = function defaultPropertyObservableInterceptor(next, el, propName, value) {\n        throw new Error('not implemented!');\n    };\n\n    // This function must clear the observers instances given as argument.\n    // > @param observer (object) the observer to kick\n    /* istanbul ignore next */\n    feature.libraries.none.disposeDisposable = function defaultDisposeDisposable(observer) {\n        throw new Error('not implemented!');\n    };\n\n    // ## Setup\n\n    // Return a new empty function.\n    function emptyFn() {\n        return function () {};\n    }\n\n    feature.setup = function (struct, builder, options) {\n        var observerProperties = {};\n        var defaultLibrary = feature.libraries[options.library || feature.defaultLibrary];\n        // Resolve the locked functions.\n        var propertyObserverFactory = options.propertyObserverFactory || defaultLibrary.propertyObserverFactory;\n        var propertyObservableInterceptor = options.propertyObservableInterceptor || defaultLibrary.propertyObservableInterceptor;\n        var disposeDisposable = options.disposeDisposable || defaultLibrary.disposeDisposable;\n\n        // Iterate over the structure's properties in order to detect the observable properties.\n        Object.keys(struct.properties).map(function (propName) {\n            return {\n                propName: propName,\n                property: struct.properties[propName]\n            };\n        }).filter(function (entry) {\n            return entry.property.observable;\n        }).forEach(function (entry) {\n            // Create the observer property of the observed property.\n            observerProperties[entry.propName + 'Observer'] = {\n                valueFactory: propertyObserverFactory\n            };\n            // Set is required for interception\n            if (!entry.property.attName && !entry.property.set) {\n                entry.property.set = emptyFn();\n            }\n            // Register the interceptor which will sync the observer with the property's value.\n            builder.intercept(entry.propName, propertyObservableInterceptor);\n        });\n\n        // Add the new properties to the structure.\n        builder.properties(observerProperties);\n\n        builder.wrap('createdCallback', function (next, el) {\n            next(arguments);\n            // When the element is created the observers must created.\n            feature(el).disposables = (options.disposables || []).map(function (disposableFactory) {\n                return disposableFactory(el);\n            });\n        });\n\n        builder.wrap('attachedCallback', function (next, el) {\n            // When the element is attached the observers of properties must be available ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                if (!el[propName]) {\n                    el[propName] = propertyObserverFactory(el);\n                }\n            });\n            // ... and the others observers too.\n            if (!feature(el).disposables) {\n                feature(el).disposables = (options.disposables || []).map(function (disposableFactory) {\n                    return disposableFactory(el);\n                });\n            }\n            next(arguments);\n        });\n\n        builder.wrap('detachedCallback', function (next, el) {\n            next(arguments);\n            // When the element is detached the observers of properties must be disposed ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                disposeDisposable(el[propName]);\n                el[propName] = undefined;\n            });\n            // ... and the others observers too.\n            feature(el).disposables.forEach(disposeDisposable);\n            feature(el).disposables = null;\n        });\n    };\n\n    return feature;\n}));\n"]}