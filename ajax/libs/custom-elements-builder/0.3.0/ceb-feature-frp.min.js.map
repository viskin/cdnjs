{"version":3,"file":"ceb-feature-frp.min.js","sources":["../src/ceb-feature-frp.js"],"names":["g","factory","exports","module","define","amd","cebFeatureFrp","this","feature","el","__cebFrpScope","emptyFn","defaultLibrary","libraries","none","propertyObserverFactory","Error","propertyObservableInterceptor","disposeDisposable","disposable","disposableFactory","handlers","handlersFactory","anotherDisposable","setup","struct","builder","options","observerProperties","library","Object","keys","properties","map","propName","property","filter","entry","observable","forEach","valueFactory","attName","set","intercept","wrap","next","arguments","disposables","undefined"],"mappings":";;;;;;;;CAAC,SAAUA,EAAGC,GACV,YAKsB,iBAAZC,SACNC,OAAOD,QAAUD,IACO,kBAAXG,SAAyBA,OAAOC,IAC7CD,OAAO,qBAAuBH,GAE9BD,EAAEM,cAAgBL,KAGxBM,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHIA,GAAGC,gBACHD,EAAGC,kBAEAD,EAAGC,cAsDd,QAASC,KACL,MAAO,cAwEX,MA1HAH,GAAQI,eAAiB,OAEzBJ,EAAQK,WACJC,SAMJN,EAAQK,UAAUC,KAAKC,wBAA0B,WAC7C,KAAM,IAAIC,OAAM,qBASpBR,EAAQK,UAAUC,KAAKG,8BAAgC,WACnD,KAAM,IAAID,OAAM,qBAMpBR,EAAQK,UAAUC,KAAKI,kBAAoB,WACvC,KAAM,IAAIF,OAAM,qBAKpBR,EAAQW,WAAa,SAAUC,GAW3B,MAVAA,GAAkBC,SAAW,SAAUC,GACnC,MAAO,UAAUb,GACb,GAAIU,GAAaC,EAAkBX,GAC/Bc,EAAoBD,EAAgBb,EAAIU,EAC5C,OAAGI,GACQA,EAEJJ,IAGRC,GAUXZ,EAAQgB,MAAQ,SAAUC,EAAQC,EAASC,GACvC,GAAIC,MACAhB,EAAiBJ,EAAQK,UAAUc,EAAQE,SAAWrB,EAAQI,gBAE9DG,EAA0BY,EAAQZ,yBAA2BH,EAAeG,wBAC5EE,EAAgCU,EAAQV,+BAAiCL,EAAeK,8BACxFC,EAAoBS,EAAQT,mBAAqBN,EAAeM,iBAGpEY,QAAOC,KAAKN,EAAOO,YAAYC,IAAI,SAAUC,GACzC,OACIA,SAAUA,EACVC,SAAUV,EAAOO,WAAWE,MAEjCE,OAAO,SAAUC,GAChB,MAAOA,GAAMF,SAASG,aACvBC,QAAQ,SAAUF,GAEjBT,EAAmBS,EAAMH,SAAW,aAChCM,aAAczB,GAGdsB,EAAMF,SAASM,SAAYJ,EAAMF,SAASO,MAC1CL,EAAMF,SAASO,IAAM/B,KAGzBe,EAAQiB,UAAUN,EAAMH,SAAUjB,KAItCS,EAAQM,WAAWJ,GAEnBF,EAAQkB,KAAK,kBAAmB,SAAUC,EAAMpC,GAC5CoC,EAAKC,WAELtC,EAAQC,GAAIsC,aAAepB,EAAQoB,iBAAmBd,IAAI,SAAUb,GAChE,MAAOA,GAAkBX,OAIjCiB,EAAQkB,KAAK,mBAAoB,SAAUC,EAAMpC,GAE7CqB,OAAOC,KAAKH,GAAoBW,QAAQ,SAAUL,GAC1CzB,EAAGyB,KACHzB,EAAGyB,GAAYnB,EAAwBN,MAI3CD,EAAQC,GAAIsC,cACZvC,EAAQC,GAAIsC,aAAepB,EAAQoB,iBAAmBd,IAAI,SAAUb,GAChE,MAAOA,GAAkBX,MAGjCoC,EAAKC,aAGTpB,EAAQkB,KAAK,mBAAoB,SAAUC,EAAMpC,GAC7CoC,EAAKC,WAELhB,OAAOC,KAAKH,GAAoBW,QAAQ,SAAUL,GAC9ChB,EAAkBT,EAAGyB,IACrBzB,EAAGyB,GAAYc,SAGnBxC,EAAQC,GAAIsC,YAAYR,QAAQrB,GAChCV,EAAQC,GAAIsC,YAAc,QAI3BvC","sourcesContent":["(function (g, factory) {\n    'use strict';\n\n    // Export the **ceb-feature-frp** function according the detected loader.\n\n    /* istanbul ignore next */\n    if(typeof exports === 'object') {\n        module.exports = factory();\n    } else if(typeof define === 'function' && define.amd) {\n        define('ceb-feature-frp', [], factory);\n    } else {\n        g.cebFeatureFrp = factory();\n    }\n\n}(this, function () {\n    'use strict';\n\n    // ## Feature function\n\n    // The FRP feature's function returns nothing for public API.\n    function feature(el) {\n        if(!el.__cebFrpScope) {\n            el.__cebFrpScope = {};\n        }\n        return el.__cebFrpScope;\n    }\n\n    // ## Default library\n\n    feature.defaultLibrary = 'none';\n\n    feature.libraries = {\n        none: {}\n    };\n\n    // This function must returns the instance to the property observer.\n    // > @param el (HTMLElement) the current element\n    /* istanbul ignore next */\n    feature.libraries.none.propertyObserverFactory = function defaultPropertyObserverFactory() {\n        throw new Error('not implemented!');\n    };\n\n    // When the observed property is set, the value must be pushed into the stream.\n    // > @param next (function) will call the next stacked callback\n    // > @param el (HTMLElement) the current element\n    // > @param propName (string) the name of the observed property\n    // > @param value (*) the value of the previous stacked callback\n    /* istanbul ignore next */\n    feature.libraries.none.propertyObservableInterceptor = function defaultPropertyObservableInterceptor(next, el, propName, value) {\n        throw new Error('not implemented!');\n    };\n\n    // This function must clear the observers instances given as argument.\n    // > @param observer (object) the observer to kick\n    /* istanbul ignore next */\n    feature.libraries.none.disposeDisposable = function defaultDisposeDisposable(observer) {\n        throw new Error('not implemented!');\n    };\n\n    // ## Observer factory\n\n    feature.disposable = function (disposableFactory) {\n        disposableFactory.handlers = function (handlersFactory) {\n            return function (el) {\n                var disposable = disposableFactory(el);\n                var anotherDisposable = handlersFactory(el, disposable);\n                if(anotherDisposable) {\n                    return anotherDisposable;\n                }\n                return disposable;\n            };\n        };\n        return disposableFactory;\n    };\n\n    // ## Setup\n\n    // Return a new empty function.\n    function emptyFn() {\n        return function () {};\n    }\n\n    feature.setup = function (struct, builder, options) {\n        var observerProperties = {};\n        var defaultLibrary = feature.libraries[options.library || feature.defaultLibrary];\n        // Resolve the locked functions.\n        var propertyObserverFactory = options.propertyObserverFactory || defaultLibrary.propertyObserverFactory;\n        var propertyObservableInterceptor = options.propertyObservableInterceptor || defaultLibrary.propertyObservableInterceptor;\n        var disposeDisposable = options.disposeDisposable || defaultLibrary.disposeDisposable;\n\n        // Iterate over the structure's properties in order to detect the observable properties.\n        Object.keys(struct.properties).map(function (propName) {\n            return {\n                propName: propName,\n                property: struct.properties[propName]\n            };\n        }).filter(function (entry) {\n            return entry.property.observable;\n        }).forEach(function (entry) {\n            // Create the observer property of the observed property.\n            observerProperties[entry.propName + 'Observer'] = {\n                valueFactory: propertyObserverFactory\n            };\n            // Set is required for interception\n            if(!entry.property.attName && !entry.property.set) {\n                entry.property.set = emptyFn();\n            }\n            // Register the interceptor which will sync the observer with the property's value.\n            builder.intercept(entry.propName, propertyObservableInterceptor);\n        });\n\n        // Add the new properties to the structure.\n        builder.properties(observerProperties);\n\n        builder.wrap('createdCallback', function (next, el) {\n            next(arguments);\n            // When the element is created the observers must created.\n            feature(el).disposables = (options.disposables || []).map(function (disposableFactory) {\n                return disposableFactory(el);\n            });\n        });\n\n        builder.wrap('attachedCallback', function (next, el) {\n            // When the element is attached the observers of properties must be available ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                if(!el[propName]) {\n                    el[propName] = propertyObserverFactory(el);\n                }\n            });\n            // ... and the others observers too.\n            if(!feature(el).disposables) {\n                feature(el).disposables = (options.disposables || []).map(function (disposableFactory) {\n                    return disposableFactory(el);\n                });\n            }\n            next(arguments);\n        });\n\n        builder.wrap('detachedCallback', function (next, el) {\n            next(arguments);\n            // When the element is detached the observers of properties must be disposed ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                disposeDisposable(el[propName]);\n                el[propName] = undefined;\n            });\n            // ... and the others observers too.\n            feature(el).disposables.forEach(disposeDisposable);\n            feature(el).disposables = null;\n        });\n    };\n\n    return feature;\n}));\n"]}