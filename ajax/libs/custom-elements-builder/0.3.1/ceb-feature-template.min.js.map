{"version":3,"file":"ceb-feature-template.min.js","sources":["../src/ceb-feature-template.js"],"names":["g","factory","exports","module","define","amd","cebFeatureTemplate","this","feature","el","__cebTemplateScope","findContentNode","oldCebContentId","getAttribute","querySelector","renderTemplate","template","innerHTML","apply","tpl","options","isHandleLightDOM","isNodeReferences","lightChildren","refrencedNodes","result","nodesRegEx","exec","property","newAtt","counter","replace","push","attribute","oldContentNode","childNodes","length","removeChild","newCebContentId","setAttribute","newContentNode","forEach","child","appendChild","entry","setup","struct","builder","search","contentRegEx","wrap","next","arguments","properties","contentNode","get"],"mappings":";;;;;;;;CAAC,SAAUA,EAAGC,GACV,YAKsB,iBAAZC,SACNC,OAAOD,QAAUD,IACO,kBAAXG,SAAyBA,OAAOC,IAC7CD,OAAO,0BAA4BH,GAEnCD,EAAEM,mBAAqBL,KAG7BM,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHIA,GAAGC,qBACHD,EAAGC,uBAEAD,EAAGC,mBAed,QAASC,GAAgBF,GACrB,GAAIG,GAAkBH,EAAGI,aAAa,qBACtC,OAAGD,GACQD,EAAgBF,EAAGK,cAAc,IAAMF,EAAkB,MAE7DH,EAIX,QAASM,GAAeN,EAAIO,GACxBP,EAAGQ,UAAYD,EAKnB,QAASE,GAAMT,EAAIU,EAAKC,EAASC,EAAkBC,GAC/C,GAAIC,MACAC,KACAR,EAAWG,CAEf,IAAGG,EAGC,IADA,GAAIG,GAC2C,QAAxCA,EAASC,EAAWC,KAAKX,KAAqB,CACjD,GAAIY,GAAWH,EAAO,GAElBI,EAAS,OAAUC,KAAa,MAEpCd,GAAWA,EAASe,QAAQ,WAAY,IAAMF,GAE9CL,EAAeQ,MACXC,UAAWJ,EACXD,SAAUA,IAKtB,GAAGP,EAAkB,CASjB,IAHA,GAAIa,GAAiBvB,EAAgBF,GAG/ByB,EAAeC,WAAWC,OAAS,GACrCb,EAAcS,KAAKE,EAAeG,YAAYH,EAAeC,WAAW,IAK5E,IAAIG,GAAkB,OAAUR,KAAa,UAG7Cd,GAAWA,EAASe,QAAQ,eAAgB,IAAMO,GAGlD7B,EAAG8B,aAAa,qBAAsBD,GAI1C,GAAIvB,GAAiBK,EAAQL,gBAAkBP,EAAQO,cAGvD,IAFAA,EAAeN,EAAIO,GAEhBK,EAAkB,CAEjB,GAAImB,GAAiB7B,EAAgBF,EACrCc,GAAckB,QAAQ,SAAUC,GAC5BF,EAAeG,YAAYD,KAIhCpB,GAECE,EAAeiB,QAAQ,SAAUG,GAC7BpC,EAAQC,GAAImC,EAAMhB,UAAYnB,EAAGK,cAAc,IAAM8B,EAAMX,UAAY,OASnF,QAASY,GAAMC,EAAQC,EAAS3B,GAC5B,GAAID,GAAMC,EAAQJ,UAAY,GAC1BK,EAAgD,KAA7BF,EAAI6B,OAAOC,GAC9B3B,EAA8C,KAA3BH,EAAI6B,OAAOtB,EAIlCqB,GAAQG,KAAK,kBAAmB,SAAUC,EAAM1C,GAC5CS,EAAMT,EAAIU,EAAKC,EAASC,EAAkBC,GAC1C6B,EAAKC,aAGN/B,GACC0B,EAAQM,YACJC,aACIC,IAAK,SAAU9C,GACX,MAAOE,GAAgBF,OA9G3C,GAAIqB,GAAU,EAGVJ,EAAa,uBAGbuB,EAAe,gBAgHnB,OAjGAzC,GAAQO,eAAiBA,EA+FzBP,EAAQqC,MAAQA,EAETrC","sourcesContent":["(function (g, factory) {\n    'use strict';\n\n    // Export the **ceb-feature-template** function according the detected loader.\n\n    /* istanbul ignore next */\n    if(typeof exports === 'object') {\n        module.exports = factory();\n    } else if(typeof define === 'function' && define.amd) {\n        define('ceb-feature-template', [], factory);\n    } else {\n        g.cebFeatureTemplate = factory();\n    }\n\n}(this, function () {\n    'use strict';\n\n    // ## Feature function\n\n    // The template feature's function returns the nodes' reference of the template.\n    function feature(el) {\n        if(!el.__cebTemplateScope) {\n            el.__cebTemplateScope = {};\n        }\n        return el.__cebTemplateScope;\n    }\n\n    // ## Templating stuff\n\n    // The counter is used to generate unique DOM's id.\n    var counter = 0;\n\n    // Regex to detect the *ceb-ref* attributes\n    var nodesRegEx = /ceb\\-ref=\\W*(\\w*)/igm;\n\n    // Regex to detect the *ceb-content* attribute\n    var contentRegEx = /ceb\\-content/im;\n\n    // Find recursively the content's node of the current element.\n    function findContentNode(el) {\n        var oldCebContentId = el.getAttribute('ceb-old-content-id');\n        if(oldCebContentId) {\n            return findContentNode(el.querySelector('[' + oldCebContentId + ']'));\n        }\n        return el;\n    }\n\n    // Render the template into the DOM\n    function renderTemplate(el, template) {\n        el.innerHTML = template;\n    }\n    feature.renderTemplate = renderTemplate;\n\n    // Apply a template to an element.\n    function apply(el, tpl, options, isHandleLightDOM, isNodeReferences) {\n        var lightChildren = [],\n            refrencedNodes = [],\n            template = tpl;\n\n        if(isNodeReferences) {\n            // Update the template to detect the DOM nodes references.\n            var result;\n            while((result = nodesRegEx.exec(template)) !== null) {\n                var property = result[1];\n                // build an id of the reference\n                var newAtt = 'ceb-' + (counter++) + '-ref';\n                // replace the original attribute name by the idenitifer\n                template = template.replace(' ceb-ref', ' ' + newAtt);\n                // push the entry\n                refrencedNodes.push({\n                    attribute: newAtt,\n                    property: property\n                });\n            }\n        }\n\n        if(isHandleLightDOM) {\n            // Get the current content node having the light DOM nodes,\n            // When the node is freshly created, the content node is the element.\n            // When the node has been created by clonning, the content node is not anymore the element,\n            // but a sub content node linked to one of its descents.\n\n            var oldContentNode = findContentNode(el);\n\n            // Remove the light DOM to keep it.\n            while(oldContentNode.childNodes.length > 0) {\n                lightChildren.push(oldContentNode.removeChild(oldContentNode.childNodes[0]));\n            }\n            // lightChildren = Array.prototype.slice.call(oldContentNode.childNodes);\n\n            // Generate the new content's id value.\n            var newCebContentId = 'ceb-' + (counter++) + '-content';\n\n            // Replace the original attribute name by the id.\n            template = template.replace(' ceb-content', ' ' + newCebContentId);\n\n            // Keep a value of the content's id value if the node is cloned.\n            el.setAttribute('ceb-old-content-id', newCebContentId);\n        }\n\n        // Transform the template string into an alive DOM nodes.\n        var renderTemplate = options.renderTemplate || feature.renderTemplate;\n        renderTemplate(el, template);\n\n        if(isHandleLightDOM) {\n            // Get the content node to add him the in pending light DOM.\n            var newContentNode = findContentNode(el);\n            lightChildren.forEach(function (child) {\n                newContentNode.appendChild(child);\n            });\n        }\n\n        if(isNodeReferences) {\n            // Get the reference nodes and attach them to the element templating scope.\n            refrencedNodes.forEach(function (entry) {\n                feature(el)[entry.property] = el.querySelector('[' + entry.attribute + ']');\n            });\n        }\n\n    }\n\n    // ## Setup function\n\n    // The templeting process is done before the call of the `createdCallback` method defined in the structure.\n    function setup(struct, builder, options) {\n        var tpl = options.template || '';\n        var isHandleLightDOM = tpl.search(contentRegEx) !== -1;\n        var isNodeReferences = tpl.search(nodesRegEx) !== -1;\n\n        // Register a wrapper to the createdCallback callback in order to\n        // apply the template before the original call.\n        builder.wrap('createdCallback', function (next, el) {\n            apply(el, tpl, options, isHandleLightDOM, isNodeReferences);\n            next(arguments);\n        });\n\n        if(isHandleLightDOM) {\n            builder.properties({\n                contentNode: {\n                    get: function (el) {\n                        return findContentNode(el);\n                    }\n                }\n            });\n        }\n    }\n    feature.setup = setup;\n\n    return feature;\n}));"]}