{"version":3,"file":"ceb-feature-cqrs.min.js","sources":["../src/ceb-feature-cqrs.js"],"names":["g","factory","exports","module","define","amd","cebFeatureCqrs","this","feature","el","__cebCqrsScope","fluentSubscriberFactory","name","build","prepareFn","processFn","process","prepare","defaultLibrary","libraries","none","sendCommand","Error","publishEvent","cmdHandlerFactory","evtListenerFactory","destroyCmdHandler","destroyListenerHandler","handle","cmdName","options","library","listen","setup","struct","builder","methods","payload","metadata","setTimeout","evtName","wrap","next","arguments","handlers","map","listeners","forEach"],"mappings":"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","sourcesContent":["(function (g, factory) {\n    'use strict';\n\n    // Export the **ceb-feature-cqrs** function according the detected loader.\n\n    /* istanbul ignore next */\n    if(typeof exports === 'object') {\n        module.exports = factory();\n    } else if(typeof define === 'function' && define.amd) {\n        define('ceb-feature-cqrs', [], factory);\n    } else {\n        g.cebFeatureCqrs = factory();\n    }\n\n}(this, function () {\n    'use strict';\n\n    // ## Feature function\n\n    // The CQRS' function returns nothing for public API.\n    function feature(el) {\n        if(!el.__cebCqrsScope) {\n            el.__cebCqrsScope = {};\n        }\n        return el.__cebCqrsScope;\n    }\n\n    // ## Default library\n\n    feature.defaultLibrary = 'none';\n\n    feature.libraries = {\n        none: {}\n    };\n\n    // This function must send the given command.\n    // > @param name (string) the name of the command\n    // > @param payload (any) the business data linked to the command\n    // > @param metadata (object) additional data like the current user, date of processing, etc.\n    /* istanbul ignore next */\n    feature.libraries.none.sendCommand = function ( /*name, payload, metadata*/ ) {\n        throw new Error('not implemented!');\n    };\n\n    // This function must publish the given event.\n    // > @param name (string) the name of the event\n    // > @param payload (any) the business data linked to the event\n    // > @param metadata (object) additional data like the current user, date of processing, etc.\n    /* istanbul ignore next */\n    feature.libraries.none.publishEvent = function ( /*name, payload, metadata*/ ) {\n        throw new Error('not implemented!');\n    };\n\n    // This function is called when an handler must be created.\n    // > @param el (HTMLElement) the current element\n    // > @param cmdName (string) the name of the command\n    // > @param prepareFn (function) this callback is used to prepare a *value*, based on a command\n    // > @param processFn (function) this callback is used to process the command, the *value* from the callback above is given as argument\n    /* istanbul ignore next */\n    feature.libraries.none.cmdHandlerFactory = function ( /*el, cmdName, prepareFn, processFn*/ ) {\n        throw new Error('not implemented!');\n    };\n\n    // This function is called when an handler must be created.\n    // > @param el (HTMLElement) the current element\n    // > @param evtName (string) the name of the event\n    // > @param prepareFn (function) this callback is used to prepare a *value*, based on an event\n    // > @param processFn (function) this callback is used to process the command, the *value* from the callback above is given as argument\n    /* istanbul ignore next */\n    feature.libraries.none.evtListenerFactory = function ( /*el, evtName, prepareFn, processFn*/ ) {\n        throw new Error('not implemented!');\n    };\n\n    // This function must destroy the given handler\n    // > @param handler (any) the handler to destroy\n    /* istanbul ignore next */\n    feature.libraries.none.destroyCmdHandler = function ( /*handler*/ ) {\n        throw new Error('not implemented!');\n    };\n\n    // This function must destroy the given listener\n    // > @param handler (any) the listener to destroy\n\n    /* istanbul ignore next */\n    feature.libraries.none.destroyListenerHandler = function ( /*listener*/ ) {\n        throw new Error('not implemented!');\n    };\n\n    // ## Handler and listener builder\n\n    function fluentSubscriberFactory(name, factory) {\n        var build = function (prepareFn, processFn) {\n            return function (el) {\n                return factory(el, name, prepareFn, processFn);\n            };\n        };\n        var process = function (processFn) {\n            return build(null, processFn);\n        };\n        var prepare = function (prepareFn) {\n            return {\n                process: function (processFn) {\n                    return build(prepareFn, processFn);\n                }\n            };\n        };\n        return {\n            prepare: prepare,\n            process: process\n        };\n    }\n    feature.handle = function (cmdName, options) {\n        var library = feature.libraries[(options && options.library) || feature.defaultLibrary];\n        return fluentSubscriberFactory(cmdName, library.cmdHandlerFactory);\n    };\n    feature.listen = function (cmdName, options) {\n        var library = feature.libraries[(options && options.library) || feature.defaultLibrary];\n        return fluentSubscriberFactory(cmdName, library.evtListenerFactory);\n    };\n\n    // ## Setup\n\n    feature.setup = function (struct, builder, options) {\n        // Resolve the locked functions.\n        var library = feature.libraries[options.library || feature.defaultLibrary];\n        var sendCommand = options.sendCommand || library.sendCommand;\n        var publishEvent = options.publishEvent || library.publishEvent;\n        var destroyCmdHandler = options.destroyCmdHandler || library.destroyCmdHandler;\n        var destroyListenerHandler = options.destroyListenerHandler || library.destroyListenerHandler;\n\n        builder.methods({\n            sendCommand: function (el, cmdName, payload, metadata) {\n                setTimeout(function () {\n                    sendCommand(cmdName, payload, metadata);\n                }, 0);\n            },\n            publishEvent: function (el, evtName, payload, metadata) {\n                setTimeout(function () {\n                    publishEvent(evtName, payload, metadata);\n                }, 0);\n            }\n        });\n\n        builder.wrap('createdCallback', function (next, el) {\n            next(arguments);\n            feature(el).handlers = (options.handlers || []).map(function (factory) {\n                return factory(el);\n            });\n            feature(el).listeners = (options.listeners || []).map(function (factory) {\n                return factory(el);\n            });\n        });\n\n        builder.wrap('attachedCallback', function (next, el) {\n            if(!feature(el).handlers) {\n                feature(el).handlers = (options.handlers || []).map(function (factory) {\n                    return factory(el);\n                });\n            }\n            if(!feature(el).listeners) {\n                feature(el).listeners = (options.listeners || []).map(function (factory) {\n                    return factory(el);\n                });\n            }\n            next(arguments);\n        });\n\n        builder.wrap('detachedCallback', function (next, el) {\n            next(arguments);\n            feature(el).handlers.forEach(destroyCmdHandler);\n            feature(el).handlers = null;\n            feature(el).listeners.forEach(destroyListenerHandler);\n            feature(el).listeners = null;\n        });\n    };\n\n    return feature;\n}));"]}