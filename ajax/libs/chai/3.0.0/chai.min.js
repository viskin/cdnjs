(function(b){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=b()}else{if(typeof define==="function"&&define.amd){define([],b)}else{var a;if(typeof window!=="undefined"){a=window}else{if(typeof global!=="undefined"){a=global}else{if(typeof self!=="undefined"){a=self}else{a=this}}}a.chai=b()}}})(function(){var d,b,a;return(function c(f,k,h){function g(q,n){if(!k[q]){if(!f[q]){var m=typeof require=="function"&&require;if(!n&&m){return m(q,!0)}if(e){return e(q,!0)}var p=new Error("Cannot find module '"+q+"'");throw p.code="MODULE_NOT_FOUND",p}var i=k[q]={exports:{}};f[q][0].call(i.exports,function(l){var o=f[q][1][l];return g(o?o:l)},i,i.exports,c,f,k,h)}return k[q].exports}var e=typeof require=="function"&&require;for(var j=0;j<h.length;j++){g(h[j])}return g})({1:[function(h,f,j){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;var o=[],j=f.exports={};
/*!
 * Chai version
 */
;j.version="3.0.0";
/*!
 * Assertion Error
 */
;j.AssertionError=h("assertion-error");
/*!
 * Utils for plugins (not exported)
 */
;var k=h("./chai/utils");j.use=function(p){if(!~o.indexOf(p)){p(this,k);o.push(p)}return this};
/*!
 * Utility Functions
 */
;j.util=k;
/*!
 * Configuration
 */
;var g=h("./chai/config");j.config=g;
/*!
 * Primary `Assertion` prototype
 */
;var n=h("./chai/assertion");j.use(n);
/*!
 * Core Assertions
 */
;var i=h("./chai/core/assertions");j.use(i);
/*!
 * Expect interface
 */
;var m=h("./chai/interface/expect");j.use(m);
/*!
 * Should interface
 */
;var l=h("./chai/interface/should");j.use(l);
/*!
 * Assert interface
 */
;var e=h("./chai/interface/assert");j.use(e)},{"./chai/assertion":2,"./chai/config":3,"./chai/core/assertions":4,"./chai/interface/assert":5,"./chai/interface/expect":6,"./chai/interface/should":7,"./chai/utils":20,"assertion-error":28}],2:[function(g,h,e){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;var f=g("./config");h.exports=function(j,l){
/*!
   * Module dependencies.
   */
;var m=j.AssertionError,k=l.flag;
/*!
   * Module export.
   */
;j.Assertion=i;
/*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */
;function i(o,p,n){k(this,"ssfi",n||arguments.callee);k(this,"object",o);k(this,"message",p)}Object.defineProperty(i,"includeStack",{get:function(){console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");return f.includeStack},set:function(n){console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");f.includeStack=n}});Object.defineProperty(i,"showDiff",{get:function(){console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");return f.showDiff},set:function(n){console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");f.showDiff=n}});i.addProperty=function(n,o){l.addProperty(this.prototype,n,o)};i.addMethod=function(n,o){l.addMethod(this.prototype,n,o)};i.addChainableMethod=function(o,p,n){l.addChainableMethod(this.prototype,o,p,n)};i.overwriteProperty=function(n,o){l.overwriteProperty(this.prototype,n,o)};i.overwriteMethod=function(n,o){l.overwriteMethod(this.prototype,n,o)};i.overwriteChainableMethod=function(o,p,n){l.overwriteChainableMethod(this.prototype,o,p,n)};i.prototype.assert=function(s,t,r,q,o,n){var p=l.test(this,arguments);if(true!==n){n=false}if(true!==f.showDiff){n=false}if(!p){var t=l.getMessage(this,arguments),u=l.getActual(this,arguments);throw new m(t,{actual:u,expected:q,showDiff:n},(f.includeStack)?this.assert:k(this,"ssfi"))}};
/*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */
;Object.defineProperty(i.prototype,"_obj",{get:function(){return k(this,"object")},set:function(n){k(this,"object",n)}})}},{"./config":3}],3:[function(f,g,e){g.exports={includeStack:false,showDiff:true,truncateThreshold:40}},{}],4:[function(f,g,e){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(k,H){var C=k.Assertion,A=Object.prototype.toString,B=H.flag;["to","be","been","is","and","has","have","with","that","which","at","of","same"].forEach(function(I){C.addProperty(I,function(){return this})});C.addProperty("not",function(){B(this,"negate",true)});C.addProperty("deep",function(){B(this,"deep",true)});C.addProperty("any",function(){B(this,"any",true);B(this,"all",false)});C.addProperty("all",function(){B(this,"all",true);B(this,"any",false)});function y(I,L){if(L){B(this,"message",L)}I=I.toLowerCase();var K=B(this,"object"),J=~["a","e","i","o","u"].indexOf(I.charAt(0))?"an ":"a ";this.assert(I===H.type(K),"expected #{this} to be "+J+I,"expected #{this} not to be "+J+I)}C.addChainableMethod("an",y);C.addChainableMethod("a",y);function F(){B(this,"contains",true)}function j(O,N){if(N){B(this,"message",N)}var M=B(this,"object");var K=false;if(H.type(M)==="array"&&H.type(O)==="object"){for(var J in M){if(H.eql(M[J],O)){K=true;break}}}else{if(H.type(O)==="object"){if(!B(this,"negate")){for(var I in O){new C(M).property(I,O[I])}return}var L={};for(var I in O){L[I]=M[I]}K=H.eql(L,O)}else{K=M&&~M.indexOf(O)}}this.assert(K,"expected #{this} to include "+H.inspect(O),"expected #{this} to not include "+H.inspect(O))}C.addChainableMethod("include",j,F);C.addChainableMethod("contain",j,F);C.addChainableMethod("contains",j,F);C.addChainableMethod("includes",j,F);C.addProperty("ok",function(){this.assert(B(this,"object"),"expected #{this} to be truthy","expected #{this} to be falsy")});C.addProperty("true",function(){this.assert(true===B(this,"object"),"expected #{this} to be true","expected #{this} to be false",this.negate?false:true)});C.addProperty("false",function(){this.assert(false===B(this,"object"),"expected #{this} to be false","expected #{this} to be true",this.negate?true:false)});C.addProperty("null",function(){this.assert(null===B(this,"object"),"expected #{this} to be null","expected #{this} not to be null")});C.addProperty("undefined",function(){this.assert(undefined===B(this,"object"),"expected #{this} to be undefined","expected #{this} not to be undefined")});C.addProperty("exist",function(){this.assert(null!=B(this,"object"),"expected #{this} to exist","expected #{this} to not exist")});C.addProperty("empty",function(){var J=B(this,"object"),I=J;if(Array.isArray(J)||"string"===typeof object){I=J.length}else{if(typeof J==="object"){I=Object.keys(J).length}}this.assert(!I,"expected #{this} to be empty","expected #{this} not to be empty")});function i(){var J=B(this,"object"),I=Object.prototype.toString.call(J);this.assert("[object Arguments]"===I,"expected #{this} to be arguments but got "+I,"expected #{this} to not be arguments")}C.addProperty("arguments",i);C.addProperty("Arguments",i);function o(K,J){if(J){B(this,"message",J)}var I=B(this,"object");if(B(this,"deep")){return this.eql(K)}else{this.assert(K===I,"expected #{this} to equal #{exp}","expected #{this} to not equal #{exp}",K,this._obj,true)}}C.addMethod("equal",o);C.addMethod("equals",o);C.addMethod("eq",o);function r(I,J){if(J){B(this,"message",J)}this.assert(H.eql(I,B(this,"object")),"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",I,this._obj,true)}C.addMethod("eql",r);C.addMethod("eqls",r);function v(L,K){if(K){B(this,"message",K)}var J=B(this,"object");if(B(this,"doLength")){new C(J,K).to.have.property("length");var I=J.length;this.assert(I>L,"expected #{this} to have a length above #{exp} but got #{act}","expected #{this} to not have a length above #{exp}",L,I)}else{this.assert(J>L,"expected #{this} to be above "+L,"expected #{this} to be at most "+L)}}C.addMethod("above",v);C.addMethod("gt",v);C.addMethod("greaterThan",v);function z(L,K){if(K){B(this,"message",K)}var J=B(this,"object");if(B(this,"doLength")){new C(J,K).to.have.property("length");var I=J.length;this.assert(I>=L,"expected #{this} to have a length at least #{exp} but got #{act}","expected #{this} to have a length below #{exp}",L,I)}else{this.assert(J>=L,"expected #{this} to be at least "+L,"expected #{this} to be below "+L)}}C.addMethod("least",z);C.addMethod("gte",z);function n(L,K){if(K){B(this,"message",K)}var J=B(this,"object");if(B(this,"doLength")){new C(J,K).to.have.property("length");var I=J.length;this.assert(I<L,"expected #{this} to have a length below #{exp} but got #{act}","expected #{this} to not have a length below #{exp}",L,I)}else{this.assert(J<L,"expected #{this} to be below "+L,"expected #{this} to be at least "+L)}}C.addMethod("below",n);C.addMethod("lt",n);C.addMethod("lessThan",n);function w(L,K){if(K){B(this,"message",K)}var J=B(this,"object");if(B(this,"doLength")){new C(J,K).to.have.property("length");var I=J.length;this.assert(I<=L,"expected #{this} to have a length at most #{exp} but got #{act}","expected #{this} to have a length above #{exp}",L,I)}else{this.assert(J<=L,"expected #{this} to be at most "+L,"expected #{this} to be above "+L)}}C.addMethod("most",w);C.addMethod("lte",w);C.addMethod("within",function(N,K,M){if(M){B(this,"message",M)}var L=B(this,"object"),J=N+".."+K;if(B(this,"doLength")){new C(L,M).to.have.property("length");var I=L.length;this.assert(I>=N&&I<=K,"expected #{this} to have a length within "+J,"expected #{this} to not have a length within "+J)}else{this.assert(L>=N&&L<=K,"expected #{this} to be within "+J,"expected #{this} to not be within "+J)}});function s(J,K){if(K){B(this,"message",K)}var I=H.getName(J);this.assert(B(this,"object") instanceof J,"expected #{this} to be an instance of "+I,"expected #{this} to not be an instance of "+I)}C.addMethod("instanceof",s);C.addMethod("instanceOf",s);C.addMethod("property",function(J,K,L){if(L){B(this,"message",L)}var O=!!B(this,"deep"),I=O?"deep property ":"property ",M=B(this,"negate"),N=B(this,"object"),P=O?H.getPathInfo(J,N):null,R=O?P.exists:H.hasProperty(J,N),Q=O?P.value:N[J];if(M&&arguments.length>1){if(undefined===Q){L=(L!=null)?L+": ":"";throw new Error(L+H.inspect(N)+" has no "+I+H.inspect(J))}}else{this.assert(R,"expected #{this} to have a "+I+H.inspect(J),"expected #{this} to not have "+I+H.inspect(J))}if(arguments.length>1){this.assert(K===Q,"expected #{this} to have a "+I+H.inspect(J)+" of #{exp}, but got #{act}","expected #{this} to not have a "+I+H.inspect(J)+" of #{act}",K,Q)}B(this,"object",Q)});function p(I,K){if(K){B(this,"message",K)}var J=B(this,"object");this.assert(J.hasOwnProperty(I),"expected #{this} to have own property "+H.inspect(I),"expected #{this} to not have own property "+H.inspect(I))}C.addMethod("ownProperty",p);C.addMethod("haveOwnProperty",p);function E(I,L,M){if(typeof L==="string"){M=L;L=null}if(M){B(this,"message",M)}var K=B(this,"object");var J=Object.getOwnPropertyDescriptor(Object(K),I);if(J&&L){this.assert(H.eql(L,J),"expected the own property descriptor for "+H.inspect(I)+" on #{this} to match "+H.inspect(L)+", got "+H.inspect(J),"expected the own property descriptor for "+H.inspect(I)+" on #{this} to not match "+H.inspect(L),L,J,true)}else{this.assert(J,"expected #{this} to have an own property descriptor for "+H.inspect(I),"expected #{this} to not have an own property descriptor for "+H.inspect(I))}B(this,"object",J)}C.addMethod("ownPropertyDescriptor",E);C.addMethod("haveOwnPropertyDescriptor",E);function m(){B(this,"doLength",true)}function q(L,K){if(K){B(this,"message",K)}var J=B(this,"object");new C(J,K).to.have.property("length");var I=J.length;this.assert(I==L,"expected #{this} to have a length of #{exp} but got #{act}","expected #{this} to not have a length of #{act}",L,I)}C.addChainableMethod("length",q,m);C.addMethod("lengthOf",q);function h(I,K){if(K){B(this,"message",K)}var J=B(this,"object");this.assert(I.exec(J),"expected #{this} to match "+I,"expected #{this} not to match "+I)}C.addMethod("match",h);C.addMethod("matches",h);C.addMethod("string",function(K,J){if(J){B(this,"message",J)}var I=B(this,"object");new C(I,J).is.a("string");this.assert(~I.indexOf(K),"expected #{this} to contain "+H.inspect(K),"expected #{this} to not contain "+H.inspect(K))});function D(T){var J=B(this,"object"),O,P=true,N="keys must be given single argument of Array|Object|String, or multiple String arguments";switch(H.type(T)){case"array":if(arguments.length>1){throw (new Error(N))}break;case"object":if(arguments.length>1){throw (new Error(N))}T=Object.keys(T);break;default:T=Array.prototype.slice.call(arguments)}if(!T.length){throw new Error("keys required")}var S=Object.keys(J),L=T,M=T.length,K=B(this,"any"),Q=B(this,"all");if(!K&&!Q){Q=true}if(K){var I=L.filter(function(U){return ~S.indexOf(U)});P=I.length>0}if(Q){P=T.every(function(U){return ~S.indexOf(U)});if(!B(this,"negate")&&!B(this,"contains")){P=P&&T.length==S.length}}if(M>1){T=T.map(function(U){return H.inspect(U)});var R=T.pop();if(Q){O=T.join(", ")+", and "+R}if(K){O=T.join(", ")+", or "+R}}else{O=H.inspect(T[0])}O=(M>1?"keys ":"key ")+O;O=(B(this,"contains")?"contain ":"have ")+O;this.assert(P,"expected #{this} to "+O,"expected #{this} to not "+O,L.slice(0).sort(),S.sort(),true)}C.addMethod("keys",D);C.addMethod("key",D);function l(K,P,J){if(J){B(this,"message",J)}var N=B(this,"object");new C(N,J).is.a("function");var R=false,L=null,I=null,Q=null;if(arguments.length===0){P=null;K=null}else{if(K&&(K instanceof RegExp||"string"===typeof K)){P=K;K=null}else{if(K&&K instanceof Error){L=K;K=null;P=null}else{if(typeof K==="function"){I=K.prototype.name||K.name;if(I==="Error"&&K!==Error){I=(new K()).name}}else{K=null}}}}try{N()}catch(M){if(L){this.assert(M===L,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}",(L instanceof Error?L.toString():L),(M instanceof Error?M.toString():M));B(this,"object",M);return this}if(K){this.assert(M instanceof K,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp} but #{act} was thrown",I,(M instanceof Error?M.toString():M));if(!P){B(this,"object",M);return this}}var T="error"===H.type(M)&&"message" in M?M.message:""+M;if((T!=null)&&P&&P instanceof RegExp){this.assert(P.exec(T),"expected #{this} to throw error matching #{exp} but got #{act}","expected #{this} to throw error not matching #{exp}",P,T);B(this,"object",M);return this}else{if((T!=null)&&P&&"string"===typeof P){this.assert(~T.indexOf(P),"expected #{this} to throw error including #{exp} but got #{act}","expected #{this} to throw error not including #{act}",P,T);B(this,"object",M);return this}else{R=true;Q=M}}}var S="",O=I!==null?I:L?"#{exp}":"an error";if(R){S=" but #{act} was thrown"}this.assert(R===true,"expected #{this} to throw "+O+S,"expected #{this} to not throw "+O+S,(L instanceof Error?L.toString():L),(Q instanceof Error?Q.toString():Q));B(this,"object",Q)}C.addMethod("throw",l);C.addMethod("throws",l);C.addMethod("Throw",l);C.addMethod("respondTo",function(M,L){if(L){B(this,"message",L)}var K=B(this,"object"),I=B(this,"itself"),J=("function"===H.type(K)&&!I)?K.prototype[M]:K[M];this.assert("function"===typeof J,"expected #{this} to respond to "+H.inspect(M),"expected #{this} to not respond to "+H.inspect(M))});C.addProperty("itself",function(){B(this,"itself",true)});C.addMethod("satisfy",function(K,L){if(L){B(this,"message",L)}var J=B(this,"object");var I=K(J);this.assert(I,"expected #{this} to satisfy "+H.objDisplay(K),"expected #{this} to not satisfy"+H.objDisplay(K),this.negate?false:true,I)});C.addMethod("closeTo",function(I,L,K){if(K){B(this,"message",K)}var J=B(this,"object");new C(J,K).is.a("number");if(H.type(I)!=="number"||H.type(L)!=="number"){throw new Error("the arguments to closeTo must be numbers")}this.assert(Math.abs(J-I)<=L,"expected #{this} to be close to "+I+" +/- "+L,"expected #{this} not to be close to "+I+" +/- "+L)});function u(K,I,J){return K.every(function(L){if(!J){return I.indexOf(L)!==-1}return I.some(function(M){return J(L,M)})})}C.addMethod("members",function(K,L){if(L){B(this,"message",L)}var J=B(this,"object");new C(J).to.be.an("array");new C(K).to.be.an("array");var I=B(this,"deep")?H.eql:undefined;if(B(this,"contains")){return this.assert(u(K,J,I),"expected #{this} to be a superset of #{act}","expected #{this} to not be a superset of #{act}",J,K)}this.assert(u(J,K,I)&&u(K,J,I),"expected #{this} to have the same members as #{act}","expected #{this} to not have the same members as #{act}",J,K)});function x(J,M,L){if(L){B(this,"message",L)}var K=B(this,"object");new C(J,L).to.have.property(M);new C(K).is.a("function");var I=J[M];K();this.assert(I!==J[M],"expected ."+M+" to change","expected ."+M+" to not change")}C.addChainableMethod("change",x);C.addChainableMethod("changes",x);function G(J,M,L){if(L){B(this,"message",L)}var K=B(this,"object");new C(J,L).to.have.property(M);new C(K).is.a("function");var I=J[M];K();this.assert(J[M]-I>0,"expected ."+M+" to increase","expected ."+M+" to not increase")}C.addChainableMethod("increase",G);C.addChainableMethod("increases",G);function t(J,M,L){if(L){B(this,"message",L)}var K=B(this,"object");new C(J,L).to.have.property(M);new C(K).is.a("function");var I=J[M];K();this.assert(J[M]-I<0,"expected ."+M+" to decrease","expected ."+M+" to not decrease")}C.addChainableMethod("decrease",t);C.addChainableMethod("decreases",t)}},{}],5:[function(f,g,e){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(l,k){
/*!
   * Chai dependencies.
   */
;var h=l.Assertion,j=k.flag;
/*!
   * Module export.
   */
;var i=l.assert=function(p,o){var n=new h(null,null,l.assert);n.assert(p,o,"[ negation message unavailable ]")};i.fail=function(q,p,o,n){o=o||"assert.fail()";throw new l.AssertionError(o,{actual:q,expected:p,operator:n},i.fail)};i.ok=function(o,n){new h(o,n).is.ok};i.notOk=function(o,n){new h(o,n).is.not.ok};i.equal=function(n,p,o){var q=new h(n,o,i.equal);q.assert(p==j(q,"object"),"expected #{this} to equal #{exp}","expected #{this} to not equal #{act}",p,n)};i.notEqual=function(n,p,o){var q=new h(n,o,i.notEqual);q.assert(p!=j(q,"object"),"expected #{this} to not equal #{exp}","expected #{this} to equal #{act}",p,n)};i.strictEqual=function(n,p,o){new h(n,o).to.equal(p)};i.notStrictEqual=function(n,p,o){new h(n,o).to.not.equal(p)};i.deepEqual=function(n,p,o){new h(n,o).to.eql(p)};i.notDeepEqual=function(n,p,o){new h(n,o).to.not.eql(p)};i.isAbove=function(p,n,o){new h(p,o).to.be.above(n)};i.isBelow=function(p,n,o){new h(p,o).to.be.below(n)};i.isTrue=function(o,n){new h(o,n).is["true"]};i.isFalse=function(o,n){new h(o,n).is["false"]};i.isNull=function(o,n){new h(o,n).to.equal(null)};i.isNotNull=function(o,n){new h(o,n).to.not.equal(null)};i.isUndefined=function(o,n){new h(o,n).to.equal(undefined)};i.isDefined=function(o,n){new h(o,n).to.not.equal(undefined)};i.isFunction=function(o,n){new h(o,n).to.be.a("function")};i.isNotFunction=function(o,n){new h(o,n).to.not.be.a("function")};i.isObject=function(o,n){new h(o,n).to.be.a("object")};i.isNotObject=function(o,n){new h(o,n).to.not.be.a("object")};i.isArray=function(o,n){new h(o,n).to.be.an("array")};i.isNotArray=function(o,n){new h(o,n).to.not.be.an("array")};i.isString=function(o,n){new h(o,n).to.be.a("string")};i.isNotString=function(o,n){new h(o,n).to.not.be.a("string")};i.isNumber=function(o,n){new h(o,n).to.be.a("number")};i.isNotNumber=function(o,n){new h(o,n).to.not.be.a("number")};i.isBoolean=function(o,n){new h(o,n).to.be.a("boolean")};i.isNotBoolean=function(o,n){new h(o,n).to.not.be.a("boolean")};i.typeOf=function(p,n,o){new h(p,o).to.be.a(n)};i.notTypeOf=function(p,n,o){new h(p,o).to.not.be.a(n)};i.instanceOf=function(p,n,o){new h(p,o).to.be.instanceOf(n)};i.notInstanceOf=function(p,n,o){new h(p,o).to.not.be.instanceOf(n)};i.include=function(p,n,o){new h(p,o,i.include).include(n)};i.notInclude=function(p,n,o){new h(p,o,i.notInclude).not.include(n)};i.match=function(p,n,o){new h(p,o).to.match(n)};i.notMatch=function(p,n,o){new h(p,o).to.not.match(n)};i.property=function(n,p,o){new h(n,o).to.have.property(p)};i.notProperty=function(n,p,o){new h(n,o).to.not.have.property(p)};i.deepProperty=function(n,p,o){new h(n,o).to.have.deep.property(p)};i.notDeepProperty=function(n,p,o){new h(n,o).to.not.have.deep.property(p)};i.propertyVal=function(n,q,p,o){new h(n,o).to.have.property(q,p)};i.propertyNotVal=function(n,q,p,o){new h(n,o).to.not.have.property(q,p)};i.deepPropertyVal=function(n,q,p,o){new h(n,o).to.have.deep.property(q,p)};i.deepPropertyNotVal=function(n,q,p,o){new h(n,o).to.not.have.deep.property(q,p)};i.lengthOf=function(p,n,o){new h(p,o).to.have.length(n)};i.Throw=function(q,n,o,r){if("string"===typeof n||n instanceof RegExp){o=n;n=null}var p=new h(q,r).to.Throw(n,o);return j(p,"object")};i.doesNotThrow=function(o,n,p){if("string"===typeof n){p=n;n=null}new h(o,p).to.not.Throw(n)};i.operator=function(r,n,p,q){var o;switch(n){case"==":o=r==p;break;case"===":o=r===p;break;case">":o=r>p;break;case">=":o=r>=p;break;case"<":o=r<p;break;case"<=":o=r<=p;break;case"!=":o=r!=p;break;case"!==":o=r!==p;break;default:throw new Error('Invalid operator "'+n+'"')}var s=new h(o,q);s.assert(true===j(s,"object"),"expected "+k.inspect(r)+" to be "+n+" "+k.inspect(p),"expected "+k.inspect(r)+" to not be "+n+" "+k.inspect(p))};i.closeTo=function(n,p,q,o){new h(n,o).to.be.closeTo(p,q)};i.sameMembers=function(o,n,p){new h(o,p).to.have.same.members(n)};i.sameDeepMembers=function(o,n,p){new h(o,p).to.have.same.deep.members(n)};i.includeMembers=function(n,o,p){new h(n,p).to.include.members(o)};i.changes=function(n,o,p){new h(n).to.change(o,p)};i.doesNotChange=function(n,o,p){new h(n).to.not.change(o,p)};i.increases=function(n,o,p){new h(n).to.increase(o,p)};i.doesNotIncrease=function(n,o,p){new h(n).to.not.increase(o,p)};i.decreases=function(n,o,p){new h(n).to.decrease(o,p)};i.doesNotDecrease=function(n,o,p){new h(n).to.not.decrease(o,p)};
/*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's 
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @api public
   */
;i.ifError=function(n){if(n){throw (n)}};
/*!
   * Aliases.
   */
(function m(o,n){i[n]=i[o];return m})("Throw","throw")("Throw","throws")}},{}],6:[function(f,g,e){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(i,h){i.expect=function(k,j){return new i.Assertion(k,j)};i.expect.fail=function(m,l,k,j){k=k||"expect.fail()";throw new i.AssertionError(k,{actual:m,expected:l,operator:j},i.expect.fail)}}},{}],7:[function(f,g,e){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(j,i){var h=j.Assertion;function k(){function n(){if(this instanceof String||this instanceof Number||this instanceof Boolean){return new h(this.valueOf(),null,n)}return new h(this,null,n)}function m(o){Object.defineProperty(this,"should",{value:o,enumerable:true,configurable:true,writable:true})}Object.defineProperty(Object.prototype,"should",{set:m,get:n,configurable:true});var l={};l.fail=function(r,q,p,o){p=p||"should.fail()";throw new j.AssertionError(p,{actual:r,expected:q,operator:o},l.fail)};l.equal=function(p,o,q){new h(p,q).to.equal(o)};l.Throw=function(q,o,p,r){new h(q,r).to.Throw(o,p)};l.exist=function(p,o){new h(p,o).to.exist};l.not={};l.not.equal=function(p,o,q){new h(p,q).to.not.equal(o)};l.not.Throw=function(q,o,p,r){new h(q,r).to.not.Throw(o,p)};l.not.exist=function(p,o){new h(p,o).to.not.exist};l["throw"]=l.Throw;l.not["throw"]=l.not.Throw;return l}j.should=k;j.Should=k}},{}],8:[function(h,f,j){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;
/*!
 * Module dependencies
 */
;var k=h("./transferFlags");var l=h("./flag");var g=h("../config");
/*!
 * Module variables
 */
;var i="__proto__" in Object;var e=/^(?:length|name|arguments|caller)$/;var n=Function.prototype.call,m=Function.prototype.apply;f.exports=function(o,q,s,p){if(typeof p!=="function"){p=function(){}}var r={method:s,chainingBehavior:p};if(!o.__methods){o.__methods={}}o.__methods[q]=r;Object.defineProperty(o,q,{get:function(){r.chainingBehavior.call(this);var t=function t(){var x=l(this,"ssfi");if(x&&g.includeStack===false){l(this,"ssfi",t)}var w=r.method.apply(this,arguments);return w===undefined?this:w};if(i){var u=t.__proto__=Object.create(this);u.call=n;u.apply=m}else{var v=Object.getOwnPropertyNames(o);v.forEach(function(x){if(!e.test(x)){var w=Object.getOwnPropertyDescriptor(o,x);Object.defineProperty(t,x,w)}})}k(this,t);return t},configurable:true})}},{"../config":3,"./flag":11,"./transferFlags":27}],9:[function(h,i,f){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;var g=h("../config");var e=h("./flag");i.exports=function(j,k,l){j[k]=function(){var n=e(this,"ssfi");if(n&&g.includeStack===false){e(this,"ssfi",j[k])}var m=l.apply(this,arguments);return m===undefined?this:m}}},{"../config":3,"./flag":11}],10:[function(f,g,e){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(i,j,h){Object.defineProperty(i,j,{get:function(){var k=h.call(this);return k===undefined?this:k},configurable:true})}},{}],11:[function(f,g,e){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(k,i,j){var h=k.__flags||(k.__flags=Object.create(null));if(arguments.length===3){h[i]=j}else{return h[i]}}},{}],12:[function(f,g,e){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(i,h){return h.length>4?h[4]:i._obj}},{}],13:[function(f,g,e){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function h(k){var i=[];for(var j in k){i.push(j)}return i}},{}],14:[function(h,i,g){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;
/*!
 * Module dependancies
 */
;var f=h("./flag"),j=h("./getActual"),k=h("./inspect"),e=h("./objDisplay");i.exports=function(o,l){var n=f(o,"negate"),r=f(o,"object"),m=l[3],s=j(o,l),q=n?l[2]:l[1],p=f(o,"message");if(typeof q==="function"){q=q()}q=q||"";q=q.replace(/#{this}/g,e(r)).replace(/#{act}/g,e(s)).replace(/#{exp}/g,e(m));return p?p+": "+q:q}},{"./flag":11,"./getActual":12,"./inspect":21,"./objDisplay":22}],15:[function(f,g,e){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(i){if(i.name){return i.name}var h=/^\s?function ([^(]*)\(/.exec(i);return h&&h[1]?h[1]:""}},{}],16:[function(h,j,g){
/*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;var f=h("./hasProperty");j.exports=function k(p,o){var l=i(p),m=l[l.length-1];var n={parent:l.length>1?e(l,o,l.length-1):o,name:m.p||m.i,value:e(l,o)};n.exists=f(n.name,n.parent);return n};
/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */
;function i(m){var n=m.replace(/([^\\])\[/g,"$1.["),l=n.match(/(\\\.|[^.]+?)+/g);return l.map(function(p){var o=/^\[(\d+)\]$/,q=o.exec(p);if(q){return{i:parseFloat(q[1])}}else{return{p:p.replace(/\\([.\[\]])/g,"$1")}}})}
/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */
;function e(n,t,p){var s=t,r;p=(p===undefined?n.length:p);for(var q=0,m=p;q<m;q++){var o=n[q];if(s){if("undefined"!==typeof o.p){s=s[o.p]}else{if("undefined"!==typeof o.i){s=s[o.i]}}if(q==(m-1)){r=s}}else{r=undefined}}return r}},{"./hasProperty":19}],17:[function(f,g,e){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */
;var h=f("./getPathInfo");g.exports=function(k,j){var i=h(k,j);return i.value}},{"./getPathInfo":16}],18:[function(f,g,e){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function h(j){var i=Object.getOwnPropertyNames(subject);function k(m){if(i.indexOf(m)===-1){i.push(m)}}var l=Object.getPrototypeOf(subject);while(l!==null){Object.getOwnPropertyNames(l).forEach(k);l=Object.getPrototypeOf(l)}return i}},{}],19:[function(g,h,f){
/*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;var i=g("type-detect");var j={number:Number,string:String};h.exports=function e(k,m){var l=i(m);if(l==="null"||l==="undefined"){return false}if(j[l]&&typeof m!=="object"){m=new j[l](m)}return k in m}},{"type-detect":33}],20:[function(f,g,e){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;
/*!
 * Main exports
 */
;var e=g.exports={};
/*!
 * test utility
 */
;e.test=f("./test");
/*!
 * type utility
 */
;e.type=f("type-detect");
/*!
 * message utility
 */
;e.getMessage=f("./getMessage");
/*!
 * actual utility
 */
;e.getActual=f("./getActual");
/*!
 * Inspect util
 */
;e.inspect=f("./inspect");
/*!
 * Object Display util
 */
;e.objDisplay=f("./objDisplay");
/*!
 * Flag utility
 */
;e.flag=f("./flag");
/*!
 * Flag transferring utility
 */
;e.transferFlags=f("./transferFlags");
/*!
 * Deep equal utility
 */
;e.eql=f("deep-eql");
/*!
 * Deep path value
 */
;e.getPathValue=f("./getPathValue");
/*!
 * Deep path info
 */
;e.getPathInfo=f("./getPathInfo");
/*!
 * Check if a property exists
 */
;e.hasProperty=f("./hasProperty");
/*!
 * Function name
 */
;e.getName=f("./getName");
/*!
 * add Property
 */
;e.addProperty=f("./addProperty");
/*!
 * add Method
 */
;e.addMethod=f("./addMethod");
/*!
 * overwrite Property
 */
;e.overwriteProperty=f("./overwriteProperty");
/*!
 * overwrite Method
 */
;e.overwriteMethod=f("./overwriteMethod");
/*!
 * Add a chainable method
 */
;e.addChainableMethod=f("./addChainableMethod");
/*!
 * Overwrite chainable method
 */
;e.overwriteChainableMethod=f("./overwriteChainableMethod")},{"./addChainableMethod":8,"./addMethod":9,"./addProperty":10,"./flag":11,"./getActual":12,"./getMessage":14,"./getName":15,"./getPathInfo":16,"./getPathValue":17,"./hasProperty":19,"./inspect":21,"./objDisplay":22,"./overwriteChainableMethod":23,"./overwriteMethod":24,"./overwriteProperty":25,"./test":26,"./transferFlags":27,"deep-eql":29,"type-detect":33}],21:[function(k,e,w){var n=k("./getName");var p=k("./getProperties");var f=k("./getEnumerableProperties");e.exports=v;function v(A,z,B,y){var x={showHidden:z,seen:[],stylize:function(C){return C}};return h(x,A,(typeof B==="undefined"?2:B))}var o=function(x){if(typeof HTMLElement==="object"){return x instanceof HTMLElement}else{return x&&typeof x==="object"&&x.nodeType===1&&typeof x.nodeName==="string"}};function h(N,L,I){if(L&&typeof L.inspect==="function"&&L.inspect!==w.inspect&&!(L.constructor&&L.constructor.prototype===L)){var J=L.inspect(I);if(typeof J!=="string"){J=h(N,J,I)}return J}var G=m(N,L);if(G){return G}if(o(L)){if("outerHTML" in L){return L.outerHTML}else{try{if(document.xmlVersion){var x=new XMLSerializer();return x.serializeToString(L)}else{var K="http://www.w3.org/1999/xhtml";var A=document.createElementNS(K,"_");A.appendChild(L.cloneNode(false));html=A.innerHTML.replace("><",">"+L.innerHTML+"<");A.innerHTML="";return html}}catch(E){}}}var z=f(L);var M=N.showHidden?p(L):z;if(M.length===0||(r(L)&&((M.length===1&&M[0]==="stack")||(M.length===2&&M[0]==="description"&&M[1]==="stack")))){if(typeof L==="function"){var y=n(L);var F=y?": "+y:"";return N.stylize("[Function"+F+"]","special")}if(q(L)){return N.stylize(RegExp.prototype.toString.call(L),"regexp")}if(u(L)){return N.stylize(Date.prototype.toUTCString.call(L),"date")}if(r(L)){return i(L)}}var B="",H=false,D=["{","}"];if(l(L)){H=true;D=["[","]"]}if(typeof L==="function"){var y=n(L);var F=y?": "+y:"";B=" [Function"+F+"]"}if(q(L)){B=" "+RegExp.prototype.toString.call(L)}if(u(L)){B=" "+Date.prototype.toUTCString.call(L)}if(r(L)){return i(L)}if(M.length===0&&(!H||L.length==0)){return D[0]+B+D[1]}if(I<0){if(q(L)){return N.stylize(RegExp.prototype.toString.call(L),"regexp")}else{return N.stylize("[Object]","special")}}N.seen.push(L);var C;if(H){C=t(N,L,I,z,M)}else{C=M.map(function(O){return g(N,L,I,z,O,H)})}N.seen.pop();return s(C,B,D)}function m(x,y){switch(typeof y){case"undefined":return x.stylize("undefined","undefined");case"string":var z="'"+JSON.stringify(y).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return x.stylize(z,"string");case"number":if(y===0&&(1/y)===-Infinity){return x.stylize("-0","number")}return x.stylize(""+y,"number");case"boolean":return x.stylize(""+y,"boolean")}if(y===null){return x.stylize("null","null")}}function i(x){return"["+Error.prototype.toString.call(x)+"]"}function t(y,D,B,E,C){var z=[];for(var A=0,x=D.length;A<x;++A){if(Object.prototype.hasOwnProperty.call(D,String(A))){z.push(g(y,D,B,E,String(A),true))}else{z.push("")}}C.forEach(function(F){if(!F.match(/^\d+$/)){z.push(g(y,D,B,E,F,true))}});return z}function g(x,B,A,C,z,E){var y,D;if(B.__lookupGetter__){if(B.__lookupGetter__(z)){if(B.__lookupSetter__(z)){D=x.stylize("[Getter/Setter]","special")}else{D=x.stylize("[Getter]","special")}}else{if(B.__lookupSetter__(z)){D=x.stylize("[Setter]","special")}}}if(C.indexOf(z)<0){y="["+z+"]"}if(!D){if(x.seen.indexOf(B[z])<0){if(A===null){D=h(x,B[z],null)}else{D=h(x,B[z],A-1)}if(D.indexOf("\n")>-1){if(E){D=D.split("\n").map(function(F){return"  "+F}).join("\n").substr(2)}else{D="\n"+D.split("\n").map(function(F){return"   "+F}).join("\n")}}}else{D=x.stylize("[Circular]","special")}}if(typeof y==="undefined"){if(E&&z.match(/^\d+$/)){return D}y=JSON.stringify(""+z);if(y.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)){y=y.substr(1,y.length-2);y=x.stylize(y,"name")}else{y=y.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'");y=x.stylize(y,"string")}}return y+": "+D}function s(x,z,B){var A=0;var y=x.reduce(function(C,D){A++;if(D.indexOf("\n")>=0){A++}return C+D.length+1},0);if(y>60){return B[0]+(z===""?"":z+"\n ")+" "+x.join(",\n  ")+" "+B[1]}return B[0]+z+" "+x.join(", ")+" "+B[1]}function l(x){return Array.isArray(x)||(typeof x==="object"&&j(x)==="[object Array]")}function q(x){return typeof x==="object"&&j(x)==="[object RegExp]"}function u(x){return typeof x==="object"&&j(x)==="[object Date]"}function r(x){return typeof x==="object"&&j(x)==="[object Error]"}function j(x){return Object.prototype.toString.call(x)}},{"./getEnumerableProperties":13,"./getName":15,"./getProperties":18}],22:[function(g,h,e){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;
/*!
 * Module dependancies
 */
;var i=g("./inspect");var f=g("../config");h.exports=function(m){var n=i(m),j=Object.prototype.toString.call(m);if(f.truncateThreshold&&n.length>=f.truncateThreshold){if(j==="[object Function]"){return !m.name||m.name===""?"[Function]":"[Function: "+m.name+"]"}else{if(j==="[object Array]"){return"[ Array("+m.length+") ]"}else{if(j==="[object Object]"){var k=Object.keys(m),l=k.length>2?k.splice(0,2).join(", ")+", ...":k.join(", ");return"{ Object ("+l+") }"}else{return n}}}}else{return n}}},{"../config":3,"./inspect":21}],23:[function(f,g,e){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(i,l,n,k){var m=i.__methods[l];var h=m.chainingBehavior;m.chainingBehavior=function(){var o=k(h).call(this);return o===undefined?this:o};var j=m.method;m.method=function(){var o=n(j).apply(this,arguments);return o===undefined?this:o}}},{}],24:[function(f,g,e){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(h,j,l){var i=h[j],k=function(){return this};if(i&&"function"===typeof i){k=i}h[j]=function(){var m=l(k).apply(this,arguments);return m===undefined?this:m}}},{}],25:[function(f,g,e){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(i,j,h){var k=Object.getOwnPropertyDescriptor(i,j),l=function(){};if(k&&"function"===typeof k.get){l=k.get}Object.defineProperty(i,j,{get:function(){var m=h(l).call(this);return m===undefined?this:m},configurable:true})}},{}],26:[function(g,h,f){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;
/*!
 * Module dependancies
 */
;var e=g("./flag");h.exports=function(l,i){var k=e(l,"negate"),j=i[0];return k?!j:j}},{"./flag":11}],27:[function(f,g,e){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;g.exports=function(i,l,h){var k=i.__flags||(i.__flags=Object.create(null));if(!l.__flags){l.__flags=Object.create(null)}h=arguments.length===3?h:true;for(var j in k){if(h||(j!=="object"&&j!=="ssfi"&&j!="message")){l.__flags[j]=k[j]}}}},{}],28:[function(h,i,f){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */
;
/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */
;function e(){var l=[].slice.call(arguments);function j(m,n){Object.keys(n).forEach(function(o){if(!~l.indexOf(o)){m[o]=n[o]}})}return function k(){var m=[].slice.call(arguments),o=0,n={};for(;o<m.length;o++){j(n,m[o])}return n}}
/*!
 * Primary Exports
 */
;i.exports=g;function g(m,j,n){var o=e("name","message","stack","constructor","toJSON"),l=o(j||{});this.message=m||"Unspecified AssertionError";this.showDiff=false;for(var k in l){this[k]=l[k]}n=n||arguments.callee;if(n&&Error.captureStackTrace){Error.captureStackTrace(this,n)}else{this.stack=new Error().stack}}
/*!
 * Inherit from Error.prototype
 */
;g.prototype=Object.create(Error.prototype);
/*!
 * Statically set name
 */
;g.prototype.name="AssertionError";
/*!
 * Ensure correct constructor
 */
;g.prototype.constructor=g;g.prototype.toJSON=function(j){var l=e("constructor","toJSON","stack"),k=l({name:this.name},this);if(false!==j&&this.stack){k.stack=this.stack}return k}},{}],29:[function(f,g,e){g.exports=f("./lib/eql")},{"./lib/eql":30}],30:[function(h,g,l){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;
/*!
 * Module dependencies
 */
;var o=h("type-detect");
/*!
 * Buffer.isBuffer browser shim
 */
;var k;try{k=h("buffer").Buffer}catch(n){k={};k.isBuffer=function(){return false}}
/*!
 * Primary Export
 */
;g.exports=s;function s(x,w,v){if(e(x,w)){return true}else{if("date"===o(x)){return f(x,w)}else{if("regexp"===o(x)){return u(x,w)}else{if(k.isBuffer(x)){return m(x,w)}else{if("arguments"===o(x)){return j(x,w,v)}else{if(!r(x,w)){return false}else{if(("object"!==o(x)&&"object"!==o(w))&&("array"!==o(x)&&"array"!==o(w))){return e(x,w)}else{return q(x,w,v)}}}}}}}}
/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */
;function e(w,v){if(w===v){return w!==0||1/w===1/v}return w!==w&&v!==v}
/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */
;function r(w,v){return o(w)===o(v)}
/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */
;function f(w,v){if("date"!==o(v)){return false}return e(w.getTime(),v.getTime())}
/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */
;function u(w,v){if("regexp"!==o(v)){return false}return e(w.toString(),v.toString())}
/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */
;function j(x,w,v){if("arguments"!==o(w)){return false}x=[].slice.call(x);w=[].slice.call(w);return s(x,w,v)}
/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */
;function i(v){var x=[];for(var w in v){x.push(w)}return x}
/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */
;function t(w,v){if(w.length!==v.length){return false}var y=0;var x=true;for(;y<w.length;y++){if(w[y]!==v[y]){x=false;break}}return x}
/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */
;function m(w,v){if(!k.isBuffer(v)){return false}return t(w,v)}
/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */
;function p(v){return v!==null&&v!==undefined}
/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */
;function q(x,w,v){if(!p(x)||!p(w)){return false}if(x.prototype!==w.prototype){return false}var A;if(v){for(A=0;A<v.length;A++){if((v[A][0]===x&&v[A][1]===w)||(v[A][0]===w&&v[A][1]===x)){return true}}}else{v=[]}try{var C=i(x);var B=i(w)}catch(z){return false}C.sort();B.sort();if(!t(C,B)){return false}v.push([x,w]);var y;for(A=C.length-1;A>=0;A--){y=C[A];if(!s(x[y],w[y],v)){return false}}return true}},{buffer:undefined,"type-detect":31}],31:[function(f,g,e){g.exports=f("./lib/type")},{"./lib/type":32}],32:[function(g,h,f){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;
/*!
 * Primary Exports
 */
;var f=h.exports=j;
/*!
 * Detectable javascript natives
 */
;var e={"[object Array]":"array","[object RegExp]":"regexp","[object Function]":"function","[object Arguments]":"arguments","[object Date]":"date"};function j(k){var l=Object.prototype.toString.call(k);if(e[l]){return e[l]}if(k===null){return"null"}if(k===undefined){return"undefined"}if(k===Object(k)){return"object"}return typeof k}f.Library=i;function i(){this.tests={}}i.prototype.of=j;i.prototype.define=function(k,l){if(arguments.length===1){return this.tests[k]}this.tests[k]=l;return this};i.prototype.test=function(l,k){if(k===j(l)){return true}var m=this.tests[k];if(m&&"regexp"===j(m)){return m.test(l)}else{if(m&&"function"===j(m)){return m(l)}else{throw new ReferenceError('Type test "'+k+'" not defined or invalid.')}}}},{}],33:[function(f,g,e){arguments[4][31][0].apply(e,arguments)},{"./lib/type":34,dup:31}],34:[function(f,g,e){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
;
/*!
 * Primary Exports
 */
;var e=g.exports=j;var h=/^\[object (.*)\]$/;function j(l){var k=Object.prototype.toString.call(l).match(h)[1].toLowerCase();if(typeof Promise==="function"&&l instanceof Promise){return"promise"}if(l===null){return"null"}if(l===undefined){return"undefined"}return k}e.Library=i;function i(){if(!(this instanceof i)){return new i()}this.tests={}}i.prototype.of=j;i.prototype.define=function(k,l){if(arguments.length===1){return this.tests[k]}this.tests[k]=l;return this};i.prototype.test=function(l,k){if(k===j(l)){return true}var m=this.tests[k];if(m&&"regexp"===j(m)){return m.test(l)}else{if(m&&"function"===j(m)){return m(l)}else{throw new ReferenceError('Type test "'+k+'" not defined or invalid.')}}}},{}],35:[function(f,g,e){g.exports=f("./lib/chai")},{"./lib/chai":1}]},{},[35])(35)});