/*! jQuery UI Virtual Keyboard for jQuery Mobile Themes v1.4.1 */
/*
 * for Keyboard v1.18+ (updated 7/7/2015)
 *
 * By Rob Garrison (aka Mottie & Fudgey)
 * Licensed under the MIT License
 *
 * Use this extension with the Virtual Keyboard to apply
 * the necessary themes to make the keyboard compatible with
 * jQuery Mobile themes
 *
 * Requires:
 *  jQuery - http://ajax.googleapis.com/ajax/libs/jquery/1.6/jquery.min.js
 *  jQuery Mobile - http://code.jquery.com/mobile/1.0.1/jquery.mobile-1.0.1.min.js
 *  jQuery Mobile themes -  http://code.jquery.com/mobile/1.0.1/jquery.mobile-1.0.1.min.css
 *
 * Setup:
 *  $('.ui-keyboard-input')
 *   .keyboard(options)
 *   .addMobile(mobile-options);
 *
 *  // or if targeting a specific keyboard
 *  $('#keyboard1')
 *   .keyboard(options)     // keyboard plugin
 *   .addMobile(mobile-options);    // this keyboard extension
 *
 */
/*jshint browser:true, jquery:true, unused:false */
/*global require:false, define:false, module:false */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):"object"==typeof module&&"object"==typeof module.exports?module.exports=a(require("jquery")):a(jQuery)}(function(a){a.fn.addMobile=function(b){var c,d={
// keyboard wrapper theme
container:{theme:"b",cssClass:"ui-body"},
// keyboard duplicate input
input:{theme:"b",cssClass:""},
// theme added to all regular buttons
buttonMarkup:{theme:"b",cssClass:"ui-btn",shadow:"true",corners:"true"},
// theme added to all buttons when they are being hovered
buttonHover:{theme:"b",cssClass:"ui-btn-hover"},
// theme added to action buttons (e.g. tab, shift, accept, cancel);
// parameters here will override the settings in the buttonMarkup
buttonAction:{theme:"b",cssClass:"ui-btn-active"},
// theme added to button when it is active (e.g. shift is down)
// All extra parameters will be ignored
buttonActive:{theme:"b",cssClass:"ui-btn-active"},
// if more than 3 mobile themes are used, add them here
allThemes:"a b c"};return this.each(function(){var e=a(this).data("keyboard");
// Stop if no keyboard attached or if jQuery Mobile isn't loaded
e&&"undefined"!=typeof a.fn.textinput&&(e.mobile_options=c=a.extend(!0,{},d,b),
// create a list of theme class names to remove
e.mobile_themes=a.trim((" "+c.allThemes).split(" ").join(" "+c.buttonMarkup.cssClass+"-")+(" "+c.allThemes).split(" ").join(" "+c.buttonAction.cssClass+"-")+(" "+c.allThemes).split(" ").join(" "+c.buttonActive.cssClass+"-")),
// save original action class because it gets removed when this theme switches swatches
"undefined"==typeof e.options.mobile_savedActiveClass&&(e.options.mobile_savedActiveClass=""+e.options.css.buttonActive),
// Setup
e.mobile_init=function(){var b=e.namespace+"Mobile";
// Add theme to input - if not already done through the markup
a("."+a.keyboard.css.input).textinput(),
// visible event is fired before this extension is initialized, so check!
e.options.alwaysOpen&&e.isVisible&&e.mobile_setup(),e.extensionNamespace.push(b),
// Setup mobile theme on keyboard once it is visible.
// Note: There is a 10ms delay after the keyboard is displayed before it actually fires 'visible.keyboard'.
// Since we are restyling here, the user will experience FlashOfUnstyledContent (FOUC).
// This is avoided by first setting the visibility to hidden, then after the mobile styles are applied we
// set it visible.
e.$el.unbind(b).bind(a.keyboard.events.kbBeforeVisible+b,function(){e&&e.el.active&&e.$keyboard.length&&e.$keyboard.css("visibility","hidden")}).bind(a.keyboard.events.kbVisible+b,function(){e&&e.el.active&&e.$keyboard.length&&(e.mobile_setup(),e.$keyboard.css("visibility","visible"),e.$preview.focus())})},e.mobile_setup=function(){var b,d=a.keyboard.css,f=e.options,g=e.mobile_themes;e.mobile_$actionKeys=e.$keyboard.find("."+e.options.css.buttonAction),f.css.buttonActive=f.mobile_savedActiveClass+" "+e.modOptions(c.buttonActive,c.buttonMarkup),e.$keyboard.addClass(e.modOptions(c.container,c.container)).find("."+d.preview).removeClass("ui-widget ui-widget-content").addClass(e.modOptions(c.input,c.input)).end().find("button").removeClass(a.trim("ui-corner-all ui-state-default "+g)).addClass(e.modOptions(c.buttonMarkup,c.buttonMarkup)).not(e.mobile_$actionKeys).hover(function(){a(this).removeClass(g).addClass(e.modOptions(c.buttonHover,c.buttonMarkup))},function(){a(this).removeClass(g+" "+c.buttonHover.cssClass).addClass(e.modOptions(c.buttonMarkup,c.buttonMarkup))}),e.mobile_$actionKeys.removeClass(g).addClass(e.modOptions(c.buttonAction,c.buttonMarkup)),
// update keyboard width if preview is showing... after applying mobile theme
e.msie&&e.$preview[0]!==e.el&&(e.$preview.hide(),e.$keyboard.css("width",""),e.width=e.$keyboard.outerWidth(),
// add about 1em to input width for extra padding
e.$keyboard.width(e.width+parseInt(e.$preview.css("fontSize"),10)),e.$preview.width(e.width),e.$preview.show()),
// adjust keyboard position after applying mobile theme
a.ui&&a.ui.position&&(b=f.position,b.of=b.of||e.$el.data("keyboardPosition")||e.$el,b.collision=b.collision||"flipfit flipfit",e.$keyboard.position(b))},e.modOptions=function(a,b){var c=" "+(a.cssClass||"");
// Using this instead of the jQuery Mobile buttonMarkup because it is expecting <a>'s instead of <button>
// theme:'a', shadow:'true', inline:'true', corners:'false'
return c+" "+(b&&b.cssClass?b.cssClass+"-"+(a.theme||""):"")+("true"==a.shadow?" ui-shadow":"")+("true"==a.corners?" ui-corner-all":"")},e.mobile_init())})}});