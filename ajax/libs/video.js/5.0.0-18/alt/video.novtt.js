/**
 * @license
 * Video.js 5.0.0-18 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.videojs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = _dereq_('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":3}],2:[function(_dereq_,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(_dereq_,module,exports){

},{}],4:[function(_dereq_,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseClone = _dereq_('lodash._baseclone'),
    bindCallback = _dereq_('lodash._bindcallback');

/**
 * Creates a deep clone of `value`. If `customizer` is provided it is invoked
 * to produce the cloned values. If `customizer` returns `undefined` cloning
 * is handled by the method instead. The `customizer` is bound to `thisArg`
 * and invoked with two argument; (value [, index|key, object]).
 *
 * **Note:** This method is loosely based on the structured clone algorithm.
 * The enumerable properties of `arguments` objects and objects created by
 * constructors other than `Object` are cloned to plain `Object` objects. An
 * empty object is returned for uncloneable values such as functions, DOM nodes,
 * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {*} Returns the deep cloned value.
 * @example
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * var deep = _.cloneDeep(users);
 * deep[0] === users[0];
 * // => false
 *
 * // using a customizer callback
 * var el = _.cloneDeep(document.body, function(value) {
 *   return _.isElement(value) ? value.cloneNode(true) : undefined;
 * });
 *
 * body === document.body
 * // => false
 * body.nodeName
 * // => BODY
 * body.childNodes.length;
 * // => 20
 */
function cloneDeep(value, customizer, thisArg) {
  customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
  return baseClone(value, true, customizer);
}

module.exports = cloneDeep;

},{"lodash._baseclone":5,"lodash._bindcallback":15}],5:[function(_dereq_,module,exports){
(function (global){
/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var arrayCopy = _dereq_('lodash._arraycopy'),
    arrayEach = _dereq_('lodash._arrayeach'),
    baseAssign = _dereq_('lodash._baseassign'),
    baseFor = _dereq_('lodash._basefor'),
    isArray = _dereq_('lodash.isarray'),
    isNative = _dereq_('lodash.isnative'),
    keys = _dereq_('lodash.keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
cloneableTags[dateTag] = cloneableTags[float32Tag] =
cloneableTags[float64Tag] = cloneableTags[int8Tag] =
cloneableTags[int16Tag] = cloneableTags[int32Tag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[stringTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[mapTag] = cloneableTags[setTag] =
cloneableTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Native method references. */
var ArrayBuffer = isNative(ArrayBuffer = global.ArrayBuffer) && ArrayBuffer,
    bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
    floor = Math.floor,
    Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

/** Used to clone array buffers. */
var Float64Array = (function() {
  // Safari 5 errors when using an array buffer to initialize a typed array
  // where the array buffer's `byteLength` is not a multiple of the typed
  // array's `BYTES_PER_ELEMENT`.
  try {
    var func = isNative(func = global.Float64Array) && func,
        result = new func(new ArrayBuffer(10), 0, 1) && func;
  } catch(e) {}
  return result;
}());

/** Used as the size, in bytes, of each `Float64Array` element. */
var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

/**
 * The base implementation of `_.clone` without support for argument juggling
 * and `this` binding `customizer` functions.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The object `value` belongs to.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates clones with source counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return arrayCopy(value, result);
    }
  } else {
    var tag = objToString.call(value),
        isFunc = tag == funcTag;

    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return baseAssign(result, value);
      }
    } else {
      return cloneableTags[tag]
        ? initCloneByTag(value, tag, isDeep)
        : (object ? value : {});
    }
  }
  // Check for circular references and return corresponding clone.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == value) {
      return stackB[length];
    }
  }
  // Add the source value to the stack of traversed objects and associate it with its clone.
  stackA.push(value);
  stackB.push(result);

  // Recursively populate clone (susceptible to call stack limits).
  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
  });
  return result;
}

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

/**
 * Creates a clone of the given array buffer.
 *
 * @private
 * @param {ArrayBuffer} buffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function bufferClone(buffer) {
  return bufferSlice.call(buffer, 0);
}
if (!bufferSlice) {
  // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
  bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
    var byteLength = buffer.byteLength,
        floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
        offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
        result = new ArrayBuffer(byteLength);

    if (floatLength) {
      var view = new Float64Array(result, 0, floatLength);
      view.set(new Float64Array(buffer, 0, floatLength));
    }
    if (byteLength != offset) {
      view = new Uint8Array(result, offset);
      view.set(new Uint8Array(buffer, offset));
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add array properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  var Ctor = object.constructor;
  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
    Ctor = Object;
  }
  return new Ctor;
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return bufferClone(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      var buffer = object.buffer;
      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      var result = new Ctor(object.source, reFlags.exec(object));
      result.lastIndex = object.lastIndex;
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (!!value && type == 'object');
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 *
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = baseClone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash._arraycopy":6,"lodash._arrayeach":7,"lodash._baseassign":8,"lodash._basefor":10,"lodash.isarray":11,"lodash.isnative":12,"lodash.keys":13}],6:[function(_dereq_,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function arrayCopy(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = arrayCopy;

},{}],7:[function(_dereq_,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],8:[function(_dereq_,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseCopy = _dereq_('lodash._basecopy'),
    isNative = _dereq_('lodash.isnative'),
    keys = _dereq_('lodash.keys');

/** Native method references. */
var getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols;

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
var baseAssign = function(object, source) {
  return source == null
    ? object
    : baseCopy(source, getSymbols(source), baseCopy(source, keys(source), object));
};

/**
 * Creates an array of the own symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {
  return getOwnPropertySymbols(toObject(object));
};

/**
 * Converts `value` to an object if it is not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (!!value && type == 'object');
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 *
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = baseAssign;

},{"lodash._basecopy":9,"lodash.isnative":12,"lodash.keys":13}],9:[function(_dereq_,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],10:[function(_dereq_,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iterator functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * Creates a base function for `_.forIn` or `_.forInRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var iterable = toObject(object),
        props = keysFunc(object),
        length = props.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      var key = props[index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Converts `value` to an object if it is not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (!!value && type == 'object');
}

module.exports = baseFor;

},{}],11:[function(_dereq_,module,exports){
/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/**
 * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
 * In addition to special characters the forward slash is escaped to allow for
 * easier `eval` use and `Function` compilation.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Converts `value` to a string if it is not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  escapeRegExp(objToString)
  .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

/**
 * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
 * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = isArray;

},{}],12:[function(_dereq_,module,exports){
/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/**
 * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
 * In addition to special characters the forward slash is escaped to allow for
 * easier `eval` use and `Function` compilation.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Converts `value` to a string if it is not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  escapeRegExp(objToString)
  .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

/**
 * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
 * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = isNative;

},{}],13:[function(_dereq_,module,exports){
/**
 * lodash 3.0.7 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArguments = _dereq_('lodash.isarguments'),
    isArray = _dereq_('lodash.isarray'),
    isNative = _dereq_('lodash.isnative');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * An object environment feature flags.
 *
 * @static
 * @memberOf _
 * @type Object
 */
var support = {};

(function(x) {
  var Ctor = function() { this.x = x; },
      args = arguments,
      object = { '0': x, 'length': x },
      props = [];

  Ctor.prototype = { 'valueOf': x, 'y': x };
  for (var key in new Ctor) { props.push(key); }

  /**
   * Detect if `arguments` object indexes are non-enumerable.
   *
   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
   * checks for indexes that exceed the number of function parameters and
   * whose associated argument values are `0`.
   *
   * @memberOf _.support
   * @type boolean
   */
  try {
    support.nonEnumArgs = !propertyIsEnumerable.call(args, 1);
  } catch(e) {
    support.nonEnumArgs = true;
  }
}(1, 0));

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = +value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object)));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (!!value && type == 'object');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object != null && object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash.isarguments":14,"lodash.isarray":11,"lodash.isnative":12}],14:[function(_dereq_,module,exports){
/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;
}

module.exports = isArguments;

},{}],15:[function(_dereq_,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],16:[function(_dereq_,module,exports){
/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFor = _dereq_('lodash._basefor'),
    isNative = _dereq_('lodash.isnative'),
    keysIn = _dereq_('lodash.keysin');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Native method references. */
var getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf;

/**
 * The base implementation of `_.forIn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForIn(object, iteratee) {
  return baseFor(object, iteratee, keysIn);
}

/**
 * A fallback implementation of `_.isPlainObject` which checks if `value`
 * is an object created by the `Object` constructor or has a `[[Prototype]]`
 * of `null`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 */
function shimIsPlainObject(value) {
  var Ctor;

  // Exit early for non `Object` objects.
  if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
      (!hasOwnProperty.call(value, 'constructor') &&
        (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
    return false;
  }
  // IE < 9 iterates inherited properties before own properties. If the first
  // iterated property is an object's own property then there are no inherited
  // enumerable properties.
  var result;
  // In most environments an object's own properties are iterated before
  // its inherited properties. If the last iterated property is an object's
  // own property then there are no inherited enumerable properties.
  baseForIn(value, function(subValue, key) {
    result = key;
  });
  return result === undefined || hasOwnProperty.call(value, result);
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * **Note:** This method assumes objects created by the `Object` constructor
 * have no inherited enumerable properties.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
  if (!(value && objToString.call(value) == objectTag)) {
    return false;
  }
  var valueOf = value.valueOf,
      objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

  return objProto
    ? (value == objProto || getPrototypeOf(value) == objProto)
    : shimIsPlainObject(value);
};

module.exports = isPlainObject;

},{"lodash._basefor":17,"lodash.isnative":18,"lodash.keysin":19}],17:[function(_dereq_,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],18:[function(_dereq_,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12}],19:[function(_dereq_,module,exports){
/**
 * lodash 3.0.6 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArguments = _dereq_('lodash.isarguments'),
    isArray = _dereq_('lodash.isarray');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * An object environment feature flags.
 *
 * @static
 * @memberOf _
 * @type Object
 */
var support = {};

(function(x) {
  var Ctor = function() { this.x = x; },
      args = arguments,
      object = { '0': x, 'length': x },
      props = [];

  Ctor.prototype = { 'valueOf': x, 'y': x };
  for (var key in new Ctor) { props.push(key); }

  /**
   * Detect if `arguments` object indexes are non-enumerable.
   *
   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
   * checks for indexes that exceed the number of function parameters and
   * whose associated argument values are `0`.
   *
   * @memberOf _.support
   * @type boolean
   */
  try {
    support.nonEnumArgs = !propertyIsEnumerable.call(args, 1);
  } catch(e) {
    support.nonEnumArgs = true;
  }
}(1, 0));

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = +value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (!!value && type == 'object');
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"lodash.isarguments":20,"lodash.isarray":21}],20:[function(_dereq_,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],21:[function(_dereq_,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],22:[function(_dereq_,module,exports){
/**
 * lodash 3.2.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var arrayCopy = _dereq_('lodash._arraycopy'),
    arrayEach = _dereq_('lodash._arrayeach'),
    createAssigner = _dereq_('lodash._createassigner'),
    isArguments = _dereq_('lodash.isarguments'),
    isArray = _dereq_('lodash.isarray'),
    isNative = _dereq_('lodash.isnative'),
    isPlainObject = _dereq_('lodash.isplainobject'),
    isTypedArray = _dereq_('lodash.istypedarray'),
    keys = _dereq_('lodash.keys'),
    keysIn = _dereq_('lodash.keysin'),
    toPlainObject = _dereq_('lodash.toplainobject');

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var arrayProto = Array.prototype;

/** Native method references. */
var getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols,
    push = arrayProto.push;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * The base implementation of `_.merge` without support for argument juggling,
 * multiple sources, and `this` binding `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} [customizer] The function to customize merging properties.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 * @returns {Object} Returns `object`.
 */
function baseMerge(object, source, customizer, stackA, stackB) {
  if (!isObject(object)) {
    return object;
  }
  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source));
  if (!isSrcArr) {
    var props = keys(source);
    push.apply(props, getSymbols(source));
  }
  arrayEach(props || source, function(srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObjectLike(srcValue)) {
      stackA || (stackA = []);
      stackB || (stackB = []);
      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
    }
    else {
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
      }
      if ((isSrcArr || result !== undefined) &&
          (isCommon || (result === result ? (result !== value) : (value === value)))) {
        object[key] = result;
      }
    }
  });
  return object;
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize merging properties.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
  var length = stackA.length,
      srcValue = source[key];

  while (length--) {
    if (stackA[length] == srcValue) {
      object[key] = stackB[length];
      return;
    }
  }
  var value = object[key],
      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
      isCommon = result === undefined;

  if (isCommon) {
    result = srcValue;
    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
      result = isArray(value)
        ? value
        : (isArrayLike(value) ? arrayCopy(value) : []);
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      result = isArguments(value)
        ? toPlainObject(value)
        : (isPlainObject(value) ? value : {});
    }
    else {
      isCommon = false;
    }
  }
  // Add the source value to the stack of traversed objects and associate
  // it with its merged value.
  stackA.push(srcValue);
  stackB.push(result);

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
  } else if (result === result ? (result !== value) : (value === value)) {
    object[key] = result;
  }
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Creates an array of the own symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {
  return getOwnPropertySymbols(toObject(object));
};

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Converts `value` to an object if it is not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (!!value && type == 'object');
}

/**
 * Recursively merges own enumerable properties of the source object(s), that
 * don't resolve to `undefined` into the destination object. Subsequent sources
 * overwrite property assignments of previous sources. If `customizer` is
 * provided it is invoked to produce the merged values of the destination and
 * source properties. If `customizer` returns `undefined` merging is handled
 * by the method instead. The `customizer` is bound to `thisArg` and invoked
 * with five arguments: (objectValue, sourceValue, key, object, source).
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var users = {
 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 * };
 *
 * var ages = {
 *   'data': [{ 'age': 36 }, { 'age': 40 }]
 * };
 *
 * _.merge(users, ages);
 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 *
 * // using a customizer callback
 * var object = {
 *   'fruits': ['apple'],
 *   'vegetables': ['beet']
 * };
 *
 * var other = {
 *   'fruits': ['banana'],
 *   'vegetables': ['carrot']
 * };
 *
 * _.merge(object, other, function(a, b) {
 *   if (_.isArray(a)) {
 *     return a.concat(b);
 *   }
 * });
 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 */
var merge = createAssigner(baseMerge);

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 *
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = merge;

},{"lodash._arraycopy":23,"lodash._arrayeach":24,"lodash._createassigner":25,"lodash.isarguments":29,"lodash.isarray":30,"lodash.isnative":31,"lodash.isplainobject":16,"lodash.istypedarray":32,"lodash.keys":33,"lodash.keysin":34,"lodash.toplainobject":35}],23:[function(_dereq_,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],24:[function(_dereq_,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],25:[function(_dereq_,module,exports){
/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var bindCallback = _dereq_('lodash._bindcallback'),
    isIterateeCall = _dereq_('lodash._isiterateecall'),
    restParam = _dereq_('lodash.restparam');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 && sources[length - 2],
        guard = length > 2 && sources[2],
        thisArg = length > 1 && sources[length - 1];

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : null;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? null : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"lodash._bindcallback":26,"lodash._isiterateecall":27,"lodash.restparam":28}],26:[function(_dereq_,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],27:[function(_dereq_,module,exports){
/**
 * lodash 3.0.7 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = +value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (!!value && type == 'object');
}

module.exports = isIterateeCall;

},{}],28:[function(_dereq_,module,exports){
/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],29:[function(_dereq_,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],30:[function(_dereq_,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],31:[function(_dereq_,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12}],32:[function(_dereq_,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
}

module.exports = isTypedArray;

},{}],33:[function(_dereq_,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"lodash.isarguments":29,"lodash.isarray":30,"lodash.isnative":31}],34:[function(_dereq_,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19,"lodash.isarguments":29,"lodash.isarray":30}],35:[function(_dereq_,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseCopy = _dereq_('lodash._basecopy'),
    keysIn = _dereq_('lodash.keysin');

/**
 * Converts `value` to a plain object flattening inherited enumerable
 * properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return baseCopy(value, keysIn(value));
}

module.exports = toPlainObject;

},{"lodash._basecopy":36,"lodash.keysin":34}],36:[function(_dereq_,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],37:[function(_dereq_,module,exports){
'use strict';

// modified from https://github.com/es-shims/es6-shim
var keys = _dereq_('object-keys');
var canBeObject = function (obj) {
	return typeof obj !== 'undefined' && obj !== null;
};
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';
var defineProperties = _dereq_('define-properties');
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
var isEnumerableOn = function (obj) {
	return function isEnumerable(prop) {
		return propIsEnumerable.call(obj, prop);
	};
};

var assignShim = function assign(target, source1) {
	if (!canBeObject(target)) { throw new TypeError('target must be an object'); }
	var objTarget = Object(target);
	var s, source, i, props;
	for (s = 1; s < arguments.length; ++s) {
		source = Object(arguments[s]);
		props = keys(source);
		if (hasSymbols && Object.getOwnPropertySymbols) {
			props.push.apply(props, Object.getOwnPropertySymbols(source).filter(isEnumerableOn(source)));
		}
		for (i = 0; i < props.length; ++i) {
			objTarget[props[i]] = source[props[i]];
		}
	}
	return objTarget;
};

assignShim.shim = function shimObjectAssign() {
	if (Object.assign && Object.preventExtensions) {
		var assignHasPendingExceptions = (function () {
			// Firefox 37 still has "pending exception" logic in its Object.assign implementation,
			// which is 72% slower than our shim, and Firefox 40's native implementation.
			var thrower = Object.preventExtensions({ 1: 2 });
			try {
				Object.assign(thrower, 'xy');
			} catch (e) {
				return thrower[1] === 'y';
			}
		}());
		if (assignHasPendingExceptions) {
			delete Object.assign;
		}
	}
	if (!Object.assign) {
		defineProperties(Object, {
			assign: assignShim
		});
	}
	return Object.assign || assignShim;
};

module.exports = assignShim;


},{"define-properties":38,"object-keys":40}],38:[function(_dereq_,module,exports){
'use strict';

var keys = _dereq_('object-keys');
var foreach = _dereq_('foreach');

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { value: obj });
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			writable: true,
			value: value
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	foreach(keys(map), function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":39,"object-keys":40}],39:[function(_dereq_,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],40:[function(_dereq_,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var isArgs = _dereq_('./isArguments');
var hasDontEnumBug = !({ 'toString': null }).propertyIsEnumerable('toString');
var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var ctor = object.constructor;
		var skipConstructor = ctor && ctor.prototype === object;

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (!Object.keys) {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":41}],41:[function(_dereq_,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]'
			&& value !== null
			&& typeof value === 'object'
			&& typeof value.length === 'number'
			&& value.length >= 0
			&& toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],42:[function(_dereq_,module,exports){
module.exports = SafeParseTuple

function SafeParseTuple(obj, reviver) {
    var json
    var error = null

    try {
        json = JSON.parse(obj, reviver)
    } catch (err) {
        error = err
    }

    return [error, json]
}

},{}],43:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('./button.js');

var _Button3 = _interopRequireWildcard(_Button2);

var _Component = _dereq_('./component.js');

var _Component2 = _interopRequireWildcard(_Component);

/* Big Play Button
================================================================================ */
/**
 * Initial play button. Shows before the video has played. The hiding of the
 * big play button is done via CSS and player states.
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var BigPlayButton = (function (_Button) {
  function BigPlayButton() {
    _classCallCheck(this, BigPlayButton);

    if (_Button != null) {
      _Button.apply(this, arguments);
    }
  }

  _inherits(BigPlayButton, _Button);

  _createClass(BigPlayButton, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(BigPlayButton.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-big-play-button',
        innerHTML: '<span aria-hidden="true"></span>',
        'aria-label': 'play video'
      });
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      this.player_.play();
    }
  }]);

  return BigPlayButton;
})(_Button3['default']);

_Component2['default'].registerComponent('BigPlayButton', BigPlayButton);
exports['default'] = BigPlayButton;
module.exports = exports['default'];

},{"./button.js":44,"./component.js":45}],44:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('./component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _import2 = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_import2);

var _import3 = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_import3);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

/* Button - Base class for all buttons
================================================================================ */
/**
 * Base class for all buttons
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Button = (function (_Component) {
  function Button(player, options) {
    _classCallCheck(this, Button);

    _get(Object.getPrototypeOf(Button.prototype), 'constructor', this).call(this, player, options);

    this.emitTapEvents();

    this.on('tap', this.handleClick);
    this.on('click', this.handleClick);
    this.on('focus', this.handleFocus);
    this.on('blur', this.handleBlur);
  }

  _inherits(Button, _Component);

  _createClass(Button, [{
    key: 'createEl',
    value: function createEl(type, props) {
      // Add standard Aria and Tabindex info
      props = _assign2['default']({
        className: this.buildCSSClass(),
        role: 'button',
        'aria-live': 'polite', // let the screen reader user know that the text of the button may change
        tabIndex: 0
      }, props);

      var el = _get(Object.getPrototypeOf(Button.prototype), 'createEl', this).call(this, type, props);

      // if innerHTML hasn't been overridden (bigPlayButton), add content elements
      if (!props.innerHTML) {
        this.contentEl_ = Dom.createEl('div', {
          className: 'vjs-control-content'
        });

        this.controlText_ = Dom.createEl('span', {
          className: 'vjs-control-text',
          innerHTML: this.localize(this.buttonText) || 'Need Text'
        });

        this.contentEl_.appendChild(this.controlText_);
        el.appendChild(this.contentEl_);
      }

      return el;
    }
  }, {
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-control vjs-button ' + _get(Object.getPrototypeOf(Button.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleClick',

    // Click - Override with specific functionality for button
    value: function handleClick() {}
  }, {
    key: 'handleFocus',

    // Focus - Add keyboard functionality to element
    value: function handleFocus() {
      Events.on(_document2['default'], 'keydown', Fn.bind(this, this.handleKeyPress));
    }
  }, {
    key: 'handleKeyPress',

    // KeyPress (document level) - Trigger click when keys are pressed
    value: function handleKeyPress(event) {
      // Check for space bar (32) or enter (13) keys
      if (event.which === 32 || event.which === 13) {
        event.preventDefault();
        this.handleClick();
      }
    }
  }, {
    key: 'handleBlur',

    // Blur - Remove keyboard triggers
    value: function handleBlur() {
      Events.off(_document2['default'], 'keydown', Fn.bind(this, this.handleKeyPress));
    }
  }]);

  return Button;
})(_Component3['default']);

_Component3['default'].registerComponent('Button', Button);
exports['default'] = Button;
module.exports = exports['default'];

},{"./component":45,"./utils/dom.js":105,"./utils/events.js":106,"./utils/fn.js":107,"global/document":1,"object.assign":37}],45:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview Player Component - Base class for all UI objects
 *
 */

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _import = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _import2 = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_import2);

var _import3 = _dereq_('./utils/guid.js');

var Guid = _interopRequireWildcard(_import3);

var _import4 = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_import4);

var _log = _dereq_('./utils/log.js');

var _log2 = _interopRequireWildcard(_log);

var _toTitleCase = _dereq_('./utils/to-title-case.js');

var _toTitleCase2 = _interopRequireWildcard(_toTitleCase);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

var _mergeOptions = _dereq_('./utils/merge-options.js');

var _mergeOptions2 = _interopRequireWildcard(_mergeOptions);

/**
 * Base UI Component class
 *
 * Components are embeddable UI objects that are represented by both a
 * javascript object and an element in the DOM. They can be children of other
 * components, and can have many children themselves.
 *
 *     // adding a button to the player
 *     var button = player.addChild('button');
 *     button.el(); // -> button element
 *
 *     <div class="video-js">
 *       <div class="vjs-button">Button</div>
 *     </div>
 *
 * Components are also event emitters.
 *
 *     button.on('click', function(){
 *       console.log('Button Clicked!');
 *     });
 *
 *     button.trigger('customevent');
 *
 * @param {Object} player  Main Player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Component = (function () {
  function Component(player, options, ready) {
    _classCallCheck(this, Component);

    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this; // eslint-disable-line
    } else {
      this.player_ = player;
    }

    // Make a copy of prototype.options_ to protect against overriding global defaults
    this.options_ = _assign2['default']({}, this.options_);

    // Updated options with supplied options
    options = this.options(options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player && player.id && player.id() || 'no_player';

      this.id_ = '' + id + '_component_' + Guid.newGUID();
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  _createClass(Component, [{
    key: 'init',

    // Temp for ES6 class transition, remove before 5.0
    value: function init() {
      // console.log('init called on Component');
      Component.apply(this, arguments);
    }
  }, {
    key: 'dispose',

    /**
     * Dispose of the component and all child components
     */
    value: function dispose() {
      this.trigger({ type: 'dispose', bubbles: false });

      // Dispose all children.
      if (this.children_) {
        for (var i = this.children_.length - 1; i >= 0; i--) {
          if (this.children_[i].dispose) {
            this.children_[i].dispose();
          }
        }
      }

      // Delete child references
      this.children_ = null;
      this.childIndex_ = null;
      this.childNameIndex_ = null;

      // Remove all event listeners.
      this.off();

      // Remove element from DOM
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }

      Dom.removeData(this.el_);
      this.el_ = null;
    }
  }, {
    key: 'player',

    /**
     * Return the component's player
     *
     * @return {Player}
     */
    value: function player() {
      return this.player_;
    }
  }, {
    key: 'options',

    /**
     * Deep merge of options objects
     *
     * Whenever a property is an object on both options objects
     * the two properties will be merged using mergeOptions.
     *
     * This is used for merging options for child components. We
     * want it to be easy to override individual options on a child
     * component without having to rewrite all the other default options.
     *
     *     Parent.prototype.options_ = {
     *       children: {
     *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
     *         'childTwo': {},
     *         'childThree': {}
     *       }
     *     }
     *     newOptions = {
     *       children: {
     *         'childOne': { 'foo': 'baz', 'abc': '123' }
     *         'childTwo': null,
     *         'childFour': {}
     *       }
     *     }
     *
     *     this.options(newOptions);
     *
     * RESULT
     *
     *     {
     *       children: {
     *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
     *         'childTwo': null, // Disabled. Won't be initialized.
     *         'childThree': {},
     *         'childFour': {}
     *       }
     *     }
     *
     * @param  {Object} obj Object of new option values
     * @return {Object}     A NEW object of this.options_ and obj merged
     */
    value: function options(obj) {
      if (!obj) {
        return this.options_;
      }

      this.options_ = _mergeOptions2['default'](this.options_, obj);
      return this.options_;
    }
  }, {
    key: 'el',

    /**
     * Get the component's DOM element
     *
     *     var domEl = myComponent.el();
     *
     * @return {Element}
     */
    value: function el() {
      return this.el_;
    }
  }, {
    key: 'createEl',

    /**
     * Create the component's DOM element
     *
     * @param  {String=} tagName  Element's node type. e.g. 'div'
     * @param  {Object=} attributes An object of element attributes that should be set on the element
     * @return {Element}
     */
    value: function createEl(tagName, attributes) {
      return Dom.createEl(tagName, attributes);
    }
  }, {
    key: 'localize',
    value: function localize(string) {
      var lang = this.player_.language();
      var languages = this.player_.languages();

      if (languages && languages[lang] && languages[lang][string]) {
        return languages[lang][string];
      }

      return string;
    }
  }, {
    key: 'contentEl',

    /**
     * Return the component's DOM element where children are inserted.
     * Will either be the same as el() or a new element defined in createEl().
     *
     * @return {Element}
     */
    value: function contentEl() {
      return this.contentEl_ || this.el_;
    }
  }, {
    key: 'id',

    /**
     * Get the component's ID
     *
     *     var id = myComponent.id();
     *
     * @return {String}
     */
    value: function id() {
      return this.id_;
    }
  }, {
    key: 'name',

    /**
     * Get the component's name. The name is often used to reference the component.
     *
     *     var name = myComponent.name();
     *
     * @return {String}
     */
    value: function name() {
      return this.name_;
    }
  }, {
    key: 'children',

    /**
     * Get an array of all child components
     *
     *     var kids = myComponent.children();
     *
     * @return {Array} The children
     */
    value: function children() {
      return this.children_;
    }
  }, {
    key: 'getChildById',

    /**
     * Returns a child component with the provided ID
     *
     * @return {Component}
     */
    value: function getChildById(id) {
      return this.childIndex_[id];
    }
  }, {
    key: 'getChild',

    /**
     * Returns a child component with the provided name
     *
     * @return {Component}
     */
    value: function getChild(name) {
      return this.childNameIndex_[name];
    }
  }, {
    key: 'addChild',

    /**
     * Adds a child component inside this component
     *
     *     myComponent.el();
     *     // -> <div class='my-component'></div>
     *     myComponent.children();
     *     // [empty array]
     *
     *     var myButton = myComponent.addChild('MyButton');
     *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
     *     // -> myButton === myComonent.children()[0];
     *
     * Pass in options for child constructors and options for children of the child
     *
     *     var myButton = myComponent.addChild('MyButton', {
     *       text: 'Press Me',
     *       children: {
     *         buttonChildExample: {
     *           buttonChildOption: true
     *         }
     *       }
     *     });
     *
     * @param {String|Component} child The class name or instance of a child to add
     * @param {Object=} options Options, including options to be passed to children of the child.
     * @return {Component} The child component (created by this process if a string was used)
     * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}
     */
    value: function addChild(child) {
      var options = arguments[1] === undefined ? {} : arguments[1];

      var component = undefined;
      var componentName = undefined;

      // If child is a string, create nt with options
      if (typeof child === 'string') {
        componentName = child;

        // Options can also be specified as a boolean, so convert to an empty object if false.
        if (!options) {
          options = {};
        }

        // Same as above, but true is deprecated so show a warning.
        if (options === true) {
          _log2['default'].warn('Initializing a child component with `true` is deprecated. Children should be defined in an array when possible, but if necessary use an object instead of `true`.');
          options = {};
        }

        // If no componentClass in options, assume componentClass is the name lowercased
        // (e.g. playButton)
        var componentClassName = options.componentClass || _toTitleCase2['default'](componentName);

        // Set name through options
        options.name = componentName;

        // Create a new object & element for this controls set
        // If there's no .player_, this is a player
        var ComponentClass = Component.getComponent(componentClassName);

        component = new ComponentClass(this.player_ || this, options);

        // child is a component instance
      } else {
        component = child;
      }

      this.children_.push(component);

      if (typeof component.id === 'function') {
        this.childIndex_[component.id()] = component;
      }

      // If a name wasn't used to create the component, check if we can use the
      // name function of the component
      componentName = componentName || component.name && component.name();

      if (componentName) {
        this.childNameIndex_[componentName] = component;
      }

      // Add the UI object's element to the container div (box)
      // Having an element is not required
      if (typeof component.el === 'function' && component.el()) {
        this.contentEl().appendChild(component.el());
      }

      // Return so it can stored on parent object if desired.
      return component;
    }
  }, {
    key: 'removeChild',

    /**
     * Remove a child component from this component's list of children, and the
     * child component's element from this component's element
     *
     * @param  {Component} component Component to remove
     */
    value: function removeChild(component) {
      if (typeof component === 'string') {
        component = this.getChild(component);
      }

      if (!component || !this.children_) {
        return;
      }

      var childFound = false;

      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i] === component) {
          childFound = true;
          this.children_.splice(i, 1);
          break;
        }
      }

      if (!childFound) {
        return;
      }

      this.childIndex_[component.id()] = null;
      this.childNameIndex_[component.name()] = null;

      var compEl = component.el();

      if (compEl && compEl.parentNode === this.contentEl()) {
        this.contentEl().removeChild(component.el());
      }
    }
  }, {
    key: 'initChildren',

    /**
     * Add and initialize default child components from options
     *
     *     // when an instance of MyComponent is created, all children in options
     *     // will be added to the instance by their name strings and options
     *     MyComponent.prototype.options_.children = {
     *       myChildComponent: {
     *         myChildOption: true
     *       }
     *     }
     *
     *     // Or when creating the component
     *     var myComp = new MyComponent(player, {
     *       children: {
     *         myChildComponent: {
     *           myChildOption: true
     *         }
     *       }
     *     });
     *
     * The children option can also be an Array of child names or
     * child options objects (that also include a 'name' key).
     *
     *     var myComp = new MyComponent(player, {
     *       children: [
     *         'button',
     *         {
     *           name: 'button',
     *           someOtherOption: true
     *         }
     *       ]
     *     });
     *
     */
    value: function initChildren() {
      var _this = this;

      var children = this.options_.children;

      if (children) {
        (function () {
          // `this` is `parent`
          var parentOptions = _this.options();
          var handleAdd = function handleAdd(name, opts) {
            // Allow options for children to be set at the parent options
            // e.g. videojs(id, { controlBar: false });
            // instead of videojs(id, { children: { controlBar: false });
            if (parentOptions[name] !== undefined) {
              opts = parentOptions[name];
            }

            // Allow for disabling default components
            // e.g. options['children']['posterImage'] = false
            if (opts === false) {
              return;
            }

            // Create and add the child component.
            // Add a direct reference to the child by name on the parent instance.
            // If two of the same component are used, different names should be supplied
            // for each
            _this[name] = _this.addChild(name, opts);
          };

          // Allow for an array of children details to passed in the options
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              var _name = undefined;
              var opts = undefined;

              if (typeof child === 'string') {
                // ['myComponent']
                _name = child;
                opts = {};
              } else {
                // [{ name: 'myComponent', otherOption: true }]
                _name = child.name;
                opts = child;
              }

              handleAdd(_name, opts);
            }
          } else {
            Object.getOwnPropertyNames(children).forEach(function (name) {
              handleAdd(name, children[name]);
            });
          }
        })();
      }
    }
  }, {
    key: 'buildCSSClass',

    /**
     * Allows sub components to stack CSS class names
     *
     * @return {String} The constructed class name
     */
    value: function buildCSSClass() {
      // Child classes can include a function that does:
      // return 'CLASS NAME' + this._super();
      return '';
    }
  }, {
    key: 'on',

    /**
     * Add an event listener to this component's element
     *
     *     var myFunc = function(){
     *       var myComponent = this;
     *       // Do something when the event is fired
     *     };
     *
     *     myComponent.on('eventType', myFunc);
     *
     * The context of myFunc will be myComponent unless previously bound.
     *
     * Alternatively, you can add a listener to another element or component.
     *
     *     myComponent.on(otherElement, 'eventName', myFunc);
     *     myComponent.on(otherComponent, 'eventName', myFunc);
     *
     * The benefit of using this over `VjsEvents.on(otherElement, 'eventName', myFunc)`
     * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
     * will be automatically cleaned up when either component is disposed.
     * It will also bind myComponent as the context of myFunc.
     *
     * **NOTE**: When using this on elements in the page other than window
     * and document (both permanent), if you remove the element from the DOM
     * you need to call `myComponent.trigger(el, 'dispose')` on it to clean up
     * references to it and allow the browser to garbage collect it.
     *
     * @param  {String|Component} first   The event type or other component
     * @param  {Function|String}      second  The event handler or event type
     * @param  {Function}             third   The event handler
     * @return {Component}        self
     */
    value: function on(first, second, third) {
      var _this2 = this;

      if (typeof first === 'string' || Array.isArray(first)) {
        Events.on(this.el_, first, Fn.bind(this, second));

        // Targeting another component or element
      } else {
        (function () {
          var target = first;
          var type = second;
          var fn = Fn.bind(_this2, third);

          // When this component is disposed, remove the listener from the other component
          var removeOnDispose = function removeOnDispose() {
            return _this2.off(target, type, fn);
          };

          // Use the same function ID so we can remove it later it using the ID
          // of the original listener
          removeOnDispose.guid = fn.guid;
          _this2.on('dispose', removeOnDispose);

          // If the other component is disposed first we need to clean the reference
          // to the other component in this component's removeOnDispose listener
          // Otherwise we create a memory leak.
          var cleanRemover = function cleanRemover() {
            return _this2.off('dispose', removeOnDispose);
          };

          // Add the same function ID so we can easily remove it later
          cleanRemover.guid = fn.guid;

          // Check if this is a DOM node
          if (first.nodeName) {
            // Add the listener to the other element
            Events.on(target, type, fn);
            Events.on(target, 'dispose', cleanRemover);

            // Should be a component
            // Not using `instanceof Component` because it makes mock players difficult
          } else if (typeof first.on === 'function') {
            // Add the listener to the other component
            target.on(type, fn);
            target.on('dispose', cleanRemover);
          }
        })();
      }

      return this;
    }
  }, {
    key: 'off',

    /**
     * Remove an event listener from this component's element
     *
     *     myComponent.off('eventType', myFunc);
     *
     * If myFunc is excluded, ALL listeners for the event type will be removed.
     * If eventType is excluded, ALL listeners will be removed from the component.
     *
     * Alternatively you can use `off` to remove listeners that were added to other
     * elements or components using `myComponent.on(otherComponent...`.
     * In this case both the event type and listener function are REQUIRED.
     *
     *     myComponent.off(otherElement, 'eventType', myFunc);
     *     myComponent.off(otherComponent, 'eventType', myFunc);
     *
     * @param  {String=|Component}  first  The event type or other component
     * @param  {Function=|String}       second The listener function or event type
     * @param  {Function=}              third  The listener for other component
     * @return {Component}
     */
    value: function off(first, second, third) {
      if (!first || typeof first === 'string' || Array.isArray(first)) {
        Events.off(this.el_, first, second);
      } else {
        var target = first;
        var type = second;
        // Ensure there's at least a guid, even if the function hasn't been used
        var fn = Fn.bind(this, third);

        // Remove the dispose listener on this component,
        // which was given the same guid as the event listener
        this.off('dispose', fn);

        if (first.nodeName) {
          // Remove the listener
          Events.off(target, type, fn);
          // Remove the listener for cleaning the dispose listener
          Events.off(target, 'dispose', fn);
        } else {
          target.off(type, fn);
          target.off('dispose', fn);
        }
      }

      return this;
    }
  }, {
    key: 'one',

    /**
     * Add an event listener to be triggered only once and then removed
     *
     *     myComponent.one('eventName', myFunc);
     *
     * Alternatively you can add a listener to another element or component
     * that will be triggered only once.
     *
     *     myComponent.one(otherElement, 'eventName', myFunc);
     *     myComponent.one(otherComponent, 'eventName', myFunc);
     *
     * @param  {String|Component}  first   The event type or other component
     * @param  {Function|String}       second  The listener function or event type
     * @param  {Function=}             third   The listener function for other component
     * @return {Component}
     */
    value: function one(first, second, third) {
      var _this3 = this;

      var _arguments = arguments;

      if (typeof first === 'string' || Array.isArray(first)) {
        Events.one(this.el_, first, Fn.bind(this, second));
      } else {
        (function () {
          var target = first;
          var type = second;
          var fn = Fn.bind(_this3, third);

          var newFunc = (function (_newFunc) {
            function newFunc() {
              return _newFunc.apply(this, arguments);
            }

            newFunc.toString = function () {
              return _newFunc.toString();
            };

            return newFunc;
          })(function () {
            _this3.off(target, type, newFunc);
            fn.apply(null, _arguments);
          });

          // Keep the same function ID so we can remove it later
          newFunc.guid = fn.guid;

          _this3.on(target, type, newFunc);
        })();
      }

      return this;
    }
  }, {
    key: 'trigger',

    /**
     * Trigger an event on an element
     *
     *     myComponent.trigger('eventName');
     *     myComponent.trigger({'type':'eventName'});
     *
     * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
     * @return {Component}       self
     */
    value: function trigger(event) {
      Events.trigger(this.el_, event);
      return this;
    }
  }, {
    key: 'ready',

    /**
     * Bind a listener to the component's ready state
     *
     * Different from event listeners in that if the ready event has already happened
     * it will trigger the function immediately.
     *
     * @param  {Function} fn Ready listener
     * @return {Component}
     */
    value: function ready(fn) {
      if (fn) {
        if (this.isReady_) {
          fn.call(this);
        } else {
          this.readyQueue_ = this.readyQueue_ || [];
          this.readyQueue_.push(fn);
        }
      }
      return this;
    }
  }, {
    key: 'triggerReady',

    /**
     * Trigger the ready listeners
     *
     * @return {Component}
     */
    value: function triggerReady() {
      this.isReady_ = true;

      var readyQueue = this.readyQueue_;

      if (readyQueue && readyQueue.length > 0) {

        for (var i = 0; i < readyQueue.length; i++) {
          readyQueue[i].call(this);
        }

        // Reset Ready Queue
        this.readyQueue_ = [];

        // Allow for using event listeners also, in case you want to do something everytime a source is ready.
        this.trigger('ready');
      }
    }
  }, {
    key: 'hasClass',

    /**
     * Check if a component's element has a CSS class name
     *
     * @param {String} classToCheck Classname to check
     * @return {Component}
     */
    value: function hasClass(classToCheck) {
      return Dom.hasClass(this.el_, classToCheck);
    }
  }, {
    key: 'addClass',

    /**
     * Add a CSS class name to the component's element
     *
     * @param {String} classToAdd Classname to add
     * @return {Component}
     */
    value: function addClass(classToAdd) {
      Dom.addClass(this.el_, classToAdd);
      return this;
    }
  }, {
    key: 'removeClass',

    /**
     * Remove a CSS class name from the component's element
     *
     * @param {String} classToRemove Classname to remove
     * @return {Component}
     */
    value: function removeClass(classToRemove) {
      Dom.removeClass(this.el_, classToRemove);
      return this;
    }
  }, {
    key: 'show',

    /**
     * Show the component element if hidden
     *
     * @return {Component}
     */
    value: function show() {
      this.removeClass('vjs-hidden');
      return this;
    }
  }, {
    key: 'hide',

    /**
     * Hide the component element if currently showing
     *
     * @return {Component}
     */
    value: function hide() {
      this.addClass('vjs-hidden');
      return this;
    }
  }, {
    key: 'lockShowing',

    /**
     * Lock an item in its visible state
     * To be used with fadeIn/fadeOut.
     *
     * @return {Component}
     * @private
     */
    value: function lockShowing() {
      this.addClass('vjs-lock-showing');
      return this;
    }
  }, {
    key: 'unlockShowing',

    /**
     * Unlock an item to be hidden
     * To be used with fadeIn/fadeOut.
     *
     * @return {Component}
     * @private
     */
    value: function unlockShowing() {
      this.removeClass('vjs-lock-showing');
      return this;
    }
  }, {
    key: 'width',

    /**
     * Set or get the width of the component (CSS values)
     *
     * Setting the video tag dimension values only works with values in pixels.
     * Percent values will not work.
     * Some percents can be used, but width()/height() will return the number + %,
     * not the actual computed width/height.
     *
     * @param  {Number|String=} num   Optional width number
     * @param  {Boolean} skipListeners Skip the 'resize' event trigger
     * @return {Component} This component, when setting the width
     * @return {Number|String} The width, when getting
     */
    value: function width(num, skipListeners) {
      return this.dimension('width', num, skipListeners);
    }
  }, {
    key: 'height',

    /**
     * Get or set the height of the component (CSS values)
     *
     * Setting the video tag dimension values only works with values in pixels.
     * Percent values will not work.
     * Some percents can be used, but width()/height() will return the number + %,
     * not the actual computed width/height.
     *
     * @param  {Number|String=} num     New component height
     * @param  {Boolean=} skipListeners Skip the resize event trigger
     * @return {Component} This component, when setting the height
     * @return {Number|String} The height, when getting
     */
    value: function height(num, skipListeners) {
      return this.dimension('height', num, skipListeners);
    }
  }, {
    key: 'dimensions',

    /**
     * Set both width and height at the same time
     *
     * @param  {Number|String} width
     * @param  {Number|String} height
     * @return {Component} The component
     */
    value: function dimensions(width, height) {
      // Skip resize listeners on width for optimization
      return this.width(width, true).height(height);
    }
  }, {
    key: 'dimension',

    /**
     * Get or set width or height
     *
     * This is the shared code for the width() and height() methods.
     * All for an integer, integer + 'px' or integer + '%';
     *
     * Known issue: Hidden elements officially have a width of 0. We're defaulting
     * to the style.width value and falling back to computedStyle which has the
     * hidden element issue. Info, but probably not an efficient fix:
     * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
     *
     * @param  {String} widthOrHeight  'width' or 'height'
     * @param  {Number|String=} num     New dimension
     * @param  {Boolean=} skipListeners Skip resize event trigger
     * @return {Component} The component if a dimension was set
     * @return {Number|String} The dimension if nothing was set
     * @private
     */
    value: function dimension(widthOrHeight, num, skipListeners) {
      if (num !== undefined) {
        // Set to zero if null or literally NaN (NaN !== NaN)
        if (num === null || num !== num) {
          num = 0;
        }

        // Check if using css width/height (% or px) and adjust
        if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
          this.el_.style[widthOrHeight] = num;
        } else if (num === 'auto') {
          this.el_.style[widthOrHeight] = '';
        } else {
          this.el_.style[widthOrHeight] = num + 'px';
        }

        // skipListeners allows us to avoid triggering the resize event when setting both width and height
        if (!skipListeners) {
          this.trigger('resize');
        }

        // Return component
        return this;
      }

      // Not setting a value, so getting it
      // Make sure element exists
      if (!this.el_) {
        return 0;
      }

      // Get dimension value from style
      var val = this.el_.style[widthOrHeight];
      var pxIndex = val.indexOf('px');

      if (pxIndex !== -1) {
        // Return the pixel value with no 'px'
        return parseInt(val.slice(0, pxIndex), 10);
      }

      // No px so using % or no style was set, so falling back to offsetWidth/height
      // If component has display:none, offset will return 0
      // TODO: handle display:none and no dimension style using px
      return parseInt(this.el_['offset' + _toTitleCase2['default'](widthOrHeight)], 10);

      // ComputedStyle version.
      // Only difference is if the element is hidden it will return
      // the percent value (e.g. '100%'')
      // instead of zero like offsetWidth returns.
      // var val = Dom.getComputedStyleValue(this.el_, widthOrHeight);
      // var pxIndex = val.indexOf('px');

      // if (pxIndex !== -1) {
      //   return val.slice(0, pxIndex);
      // } else {
      //   return val;
      // }
    }
  }, {
    key: 'emitTapEvents',

    /**
     * Emit 'tap' events when touch events are supported
     *
     * This is used to support toggling the controls through a tap on the video.
     *
     * We're requiring them to be enabled because otherwise every component would
     * have this extra overhead unnecessarily, on mobile devices where extra
     * overhead is especially bad.
     * @private
     */
    value: function emitTapEvents() {
      // Track the start time so we can determine how long the touch lasted
      var touchStart = 0;
      var firstTouch = null;

      // Maximum movement allowed during a touch event to still be considered a tap
      // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.
      var tapMovementThreshold = 10;

      // The maximum length a touch can be while still being considered a tap
      var touchTimeThreshold = 200;

      var couldBeTap = undefined;

      this.on('touchstart', function (event) {
        // If more than one finger, don't consider treating this as a click
        if (event.touches.length === 1) {
          // Copy the touches object to prevent modifying the original
          firstTouch = _assign2['default']({}, event.touches[0]);
          // Record start time so we can detect a tap vs. "touch and hold"
          touchStart = new Date().getTime();
          // Reset couldBeTap tracking
          couldBeTap = true;
        }
      });

      this.on('touchmove', function (event) {
        // If more than one finger, don't consider treating this as a click
        if (event.touches.length > 1) {
          couldBeTap = false;
        } else if (firstTouch) {
          // Some devices will throw touchmoves for all but the slightest of taps.
          // So, if we moved only a small distance, this could still be a tap
          var xdiff = event.touches[0].pageX - firstTouch.pageX;
          var ydiff = event.touches[0].pageY - firstTouch.pageY;
          var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);

          if (touchDistance > tapMovementThreshold) {
            couldBeTap = false;
          }
        }
      });

      var noTap = function noTap() {
        couldBeTap = false;
      };

      // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
      this.on('touchleave', noTap);
      this.on('touchcancel', noTap);

      // When the touch ends, measure how long it took and trigger the appropriate
      // event
      this.on('touchend', function (event) {
        firstTouch = null;
        // Proceed only if the touchmove/leave/cancel event didn't happen
        if (couldBeTap === true) {
          // Measure how long the touch lasted
          var touchTime = new Date().getTime() - touchStart;

          // Make sure the touch was less than the threshold to be considered a tap
          if (touchTime < touchTimeThreshold) {
            // Don't let browser turn this into a click
            event.preventDefault();
            this.trigger('tap');
            // It may be good to copy the touchend event object and change the
            // type to tap, if the other event properties aren't exact after
            // Events.fixEvent runs (e.g. event.target)
          }
        }
      });
    }
  }, {
    key: 'enableTouchActivity',

    /**
     * Report user touch activity when touch events occur
     *
     * User activity is used to determine when controls should show/hide. It's
     * relatively simple when it comes to mouse events, because any mouse event
     * should show the controls. So we capture mouse events that bubble up to the
     * player and report activity when that happens.
     *
     * With touch events it isn't as easy. We can't rely on touch events at the
     * player level, because a tap (touchstart + touchend) on the video itself on
     * mobile devices is meant to turn controls off (and on). User activity is
     * checked asynchronously, so what could happen is a tap event on the video
     * turns the controls off, then the touchend event bubbles up to the player,
     * which if it reported user activity, would turn the controls right back on.
     * (We also don't want to completely block touch events from bubbling up)
     *
     * Also a touchmove, touch+hold, and anything other than a tap is not supposed
     * to turn the controls back on on a mobile device.
     *
     * Here we're setting the default component behavior to report user activity
     * whenever touch events happen, and this can be turned off by components that
     * want touch events to act differently.
     */
    value: function enableTouchActivity() {
      // Don't continue if the root player doesn't support reporting user activity
      if (!this.player() || !this.player().reportUserActivity) {
        return;
      }

      // listener for reporting that the user is active
      var report = Fn.bind(this.player(), this.player().reportUserActivity);

      var touchHolding = undefined;

      this.on('touchstart', function () {
        report();
        // For as long as the they are touching the device or have their mouse down,
        // we consider them active even if they're not moving their finger or mouse.
        // So we want to continue to update that they are active
        this.clearInterval(touchHolding);
        // report at the same interval as activityCheck
        touchHolding = this.setInterval(report, 250);
      });

      var touchEnd = function touchEnd(event) {
        report();
        // stop the interval that maintains activity if the touch is holding
        this.clearInterval(touchHolding);
      };

      this.on('touchmove', report);
      this.on('touchend', touchEnd);
      this.on('touchcancel', touchEnd);
    }
  }, {
    key: 'setTimeout',

    /**
     * Creates timeout and sets up disposal automatically.
     * @param {Function} fn The function to run after the timeout.
     * @param {Number} timeout Number of ms to delay before executing specified function.
     * @return {Number} Returns the timeout ID
     */
    value: function setTimeout(fn, timeout) {
      fn = Fn.bind(this, fn);

      // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.
      var timeoutId = _window2['default'].setTimeout(fn, timeout);

      var disposeFn = function disposeFn() {
        this.clearTimeout(timeoutId);
      };

      disposeFn.guid = 'vjs-timeout-' + timeoutId;

      this.on('dispose', disposeFn);

      return timeoutId;
    }
  }, {
    key: 'clearTimeout',

    /**
     * Clears a timeout and removes the associated dispose listener
     * @param {Number} timeoutId The id of the timeout to clear
     * @return {Number} Returns the timeout ID
     */
    value: function clearTimeout(timeoutId) {
      _window2['default'].clearTimeout(timeoutId);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-timeout-' + timeoutId;

      this.off('dispose', disposeFn);

      return timeoutId;
    }
  }, {
    key: 'setInterval',

    /**
     * Creates an interval and sets up disposal automatically.
     * @param {Function} fn The function to run every N seconds.
     * @param {Number} interval Number of ms to delay before executing specified function.
     * @return {Number} Returns the interval ID
     */
    value: function setInterval(fn, interval) {
      fn = Fn.bind(this, fn);

      var intervalId = _window2['default'].setInterval(fn, interval);

      var disposeFn = function disposeFn() {
        this.clearInterval(intervalId);
      };

      disposeFn.guid = 'vjs-interval-' + intervalId;

      this.on('dispose', disposeFn);

      return intervalId;
    }
  }, {
    key: 'clearInterval',

    /**
     * Clears an interval and removes the associated dispose listener
     * @param {Number} intervalId The id of the interval to clear
     * @return {Number} Returns the interval ID
     */
    value: function clearInterval(intervalId) {
      _window2['default'].clearInterval(intervalId);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-interval-' + intervalId;

      this.off('dispose', disposeFn);

      return intervalId;
    }
  }], [{
    key: 'registerComponent',
    value: function registerComponent(name, comp) {
      if (!Component.components_) {
        Component.components_ = {};
      }

      Component.components_[name] = comp;
      return comp;
    }
  }, {
    key: 'getComponent',
    value: function getComponent(name) {
      if (Component.components_ && Component.components_[name]) {
        return Component.components_[name];
      }

      if (_window2['default'] && _window2['default'].videojs && _window2['default'].videojs[name]) {
        _log2['default'].warn('The ' + name + ' component was added to the videojs object when it should be registered using videojs.registerComponent(name, component)');
        return _window2['default'].videojs[name];
      }
    }
  }, {
    key: 'extend',
    value: function extend(props) {
      props = props || {};
      // Set up the constructor using the supplied init method
      // or using the init of the parent object
      // Make sure to check the unobfuscated version for external libs
      var init = props.init || props.init || this.prototype.init || this.prototype.init || function () {};
      // In Resig's simple class inheritance (previously used) the constructor
      //  is a function that calls `this.init.apply(arguments)`
      // However that would prevent us from using `ParentObject.call(this);`
      //  in a Child constructor because the `this` in `this.init`
      //  would still refer to the Child and cause an infinite loop.
      // We would instead have to do
      //    `ParentObject.prototype.init.apply(this, arguments);`
      //  Bleh. We're not creating a _super() function, so it's good to keep
      //  the parent constructor reference simple.
      var subObj = function subObj() {
        init.apply(this, arguments);
      };

      // Inherit from this object's prototype
      subObj.prototype = Object.create(this.prototype);
      // Reset the constructor property for subObj otherwise
      // instances of subObj would have the constructor of the parent Object
      subObj.prototype.constructor = subObj;

      // Make the class extendable
      subObj.extend = Component.extend;
      // Make a function for creating instances
      // subObj.create = CoreObject.create;

      // Extend subObj's prototype with functions and other properties from props
      for (var _name2 in props) {
        if (props.hasOwnProperty(_name2)) {
          subObj.prototype[_name2] = props[_name2];
        }
      }

      return subObj;
    }
  }]);

  return Component;
})();

Component.registerComponent('Component', Component);
exports['default'] = Component;
module.exports = exports['default'];

},{"./utils/dom.js":105,"./utils/events.js":106,"./utils/fn.js":107,"./utils/guid.js":109,"./utils/log.js":110,"./utils/merge-options.js":111,"./utils/to-title-case.js":114,"global/window":2,"object.assign":37}],46:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

// Required children

var _PlayToggle = _dereq_('./play-toggle.js');

var _PlayToggle2 = _interopRequireWildcard(_PlayToggle);

var _CurrentTimeDisplay = _dereq_('./time-controls/current-time-display.js');

var _CurrentTimeDisplay2 = _interopRequireWildcard(_CurrentTimeDisplay);

var _DurationDisplay = _dereq_('./time-controls/duration-display.js');

var _DurationDisplay2 = _interopRequireWildcard(_DurationDisplay);

var _TimeDivider = _dereq_('./time-controls/time-divider.js');

var _TimeDivider2 = _interopRequireWildcard(_TimeDivider);

var _RemainingTimeDisplay = _dereq_('./time-controls/remaining-time-display.js');

var _RemainingTimeDisplay2 = _interopRequireWildcard(_RemainingTimeDisplay);

var _LiveDisplay = _dereq_('./live-display.js');

var _LiveDisplay2 = _interopRequireWildcard(_LiveDisplay);

var _ProgressControl = _dereq_('./progress-control/progress-control.js');

var _ProgressControl2 = _interopRequireWildcard(_ProgressControl);

var _FullscreenToggle = _dereq_('./fullscreen-toggle.js');

var _FullscreenToggle2 = _interopRequireWildcard(_FullscreenToggle);

var _VolumeControl = _dereq_('./volume-control/volume-control.js');

var _VolumeControl2 = _interopRequireWildcard(_VolumeControl);

var _VolumeMenuButton = _dereq_('./volume-menu-button.js');

var _VolumeMenuButton2 = _interopRequireWildcard(_VolumeMenuButton);

var _MuteToggle = _dereq_('./mute-toggle.js');

var _MuteToggle2 = _interopRequireWildcard(_MuteToggle);

var _ChaptersButton = _dereq_('./text-track-controls/chapters-button.js');

var _ChaptersButton2 = _interopRequireWildcard(_ChaptersButton);

var _SubtitlesButton = _dereq_('./text-track-controls/subtitles-button.js');

var _SubtitlesButton2 = _interopRequireWildcard(_SubtitlesButton);

var _CaptionsButton = _dereq_('./text-track-controls/captions-button.js');

var _CaptionsButton2 = _interopRequireWildcard(_CaptionsButton);

var _PlaybackRateMenuButton = _dereq_('./playback-rate-menu/playback-rate-menu-button.js');

var _PlaybackRateMenuButton2 = _interopRequireWildcard(_PlaybackRateMenuButton);

var _CustomControlSpacer = _dereq_('./spacer-controls/custom-control-spacer.js');

var _CustomControlSpacer2 = _interopRequireWildcard(_CustomControlSpacer);

/**
 * Container of main controls
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 * @extends Component
 */

var ControlBar = (function (_Component) {
  function ControlBar() {
    _classCallCheck(this, ControlBar);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(ControlBar, _Component);

  _createClass(ControlBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(ControlBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-control-bar'
      });
    }
  }]);

  return ControlBar;
})(_Component3['default']);

ControlBar.prototype.options_ = {
  loadEvent: 'play',
  children: ['playToggle', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'muteToggle', 'volumeControl', 'chaptersButton', 'subtitlesButton', 'captionsButton', 'volumeMenuButton', 'fullscreenToggle']
};

_Component3['default'].registerComponent('ControlBar', ControlBar);
exports['default'] = ControlBar;
module.exports = exports['default'];

},{"../component.js":45,"./fullscreen-toggle.js":47,"./live-display.js":48,"./mute-toggle.js":49,"./play-toggle.js":50,"./playback-rate-menu/playback-rate-menu-button.js":51,"./progress-control/progress-control.js":55,"./spacer-controls/custom-control-spacer.js":58,"./text-track-controls/captions-button.js":61,"./text-track-controls/chapters-button.js":62,"./text-track-controls/subtitles-button.js":65,"./time-controls/current-time-display.js":68,"./time-controls/duration-display.js":69,"./time-controls/remaining-time-display.js":70,"./time-controls/time-divider.js":71,"./volume-control/volume-control.js":73,"./volume-menu-button.js":76}],47:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button.js');

var _Button3 = _interopRequireWildcard(_Button2);

var _Component = _dereq_('../component.js');

var _Component2 = _interopRequireWildcard(_Component);

/**
 * Toggle fullscreen video
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @extends vjs.Button
 */

var FullscreenToggle = (function (_Button) {
  function FullscreenToggle() {
    _classCallCheck(this, FullscreenToggle);

    if (_Button != null) {
      _Button.apply(this, arguments);
    }
  }

  _inherits(FullscreenToggle, _Button);

  _createClass(FullscreenToggle, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-fullscreen-control ' + _get(Object.getPrototypeOf(FullscreenToggle.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      if (!this.player_.isFullscreen()) {
        this.player_.requestFullscreen();
        this.controlText_.innerHTML = this.localize('Non-Fullscreen');
      } else {
        this.player_.exitFullscreen();
        this.controlText_.innerHTML = this.localize('Fullscreen');
      }
    }
  }]);

  return FullscreenToggle;
})(_Button3['default']);

FullscreenToggle.prototype.buttonText = 'Fullscreen';

_Component2['default'].registerComponent('FullscreenToggle', FullscreenToggle);
exports['default'] = FullscreenToggle;
module.exports = exports['default'];

},{"../button.js":44,"../component.js":45}],48:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

/**
 * Displays the live indicator
 * TODO - Future make it click to snap to live
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var LiveDisplay = (function (_Component) {
  function LiveDisplay() {
    _classCallCheck(this, LiveDisplay);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(LiveDisplay, _Component);

  _createClass(LiveDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(LiveDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-live-control vjs-control'
      });

      this.contentEl_ = Dom.createEl('div', {
        className: 'vjs-live-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE'),
        'aria-live': 'off'
      });

      el.appendChild(this.contentEl_);

      return el;
    }
  }]);

  return LiveDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('LiveDisplay', LiveDisplay);
exports['default'] = LiveDisplay;
module.exports = exports['default'];

},{"../component":45,"../utils/dom.js":105}],49:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button');

var _Button3 = _interopRequireWildcard(_Button2);

var _Component = _dereq_('../component');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

/**
 * A button component for muting the audio
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var MuteToggle = (function (_Button) {
  function MuteToggle(player, options) {
    _classCallCheck(this, MuteToggle);

    _get(Object.getPrototypeOf(MuteToggle.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'volumechange', this.update);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech && player.tech.featuresVolumeControl === false) {
      this.addClass('vjs-hidden');
    }

    this.on(player, 'loadstart', function () {
      if (player.tech.featuresVolumeControl === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }

  _inherits(MuteToggle, _Button);

  _createClass(MuteToggle, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(MuteToggle.prototype), 'createEl', this).call(this, 'div', {
        className: this.buildCSSClass(),
        innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
      });
    }
  }, {
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-mute-control ' + _get(Object.getPrototypeOf(MuteToggle.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  }, {
    key: 'update',
    value: function update() {
      var vol = this.player_.volume(),
          level = 3;

      if (vol === 0 || this.player_.muted()) {
        level = 0;
      } else if (vol < 0.33) {
        level = 1;
      } else if (vol < 0.67) {
        level = 2;
      }

      // Don't rewrite the button text if the actual text doesn't change.
      // This causes unnecessary and confusing information for screen reader users.
      // This check is needed because this function gets called every time the volume level is changed.
      var toMute = this.player_.muted() ? 'Unmute' : 'Mute';
      var localizedMute = this.localize(toMute);
      if (this.el_.children[0].children[0].innerHTML !== localizedMute) {
        this.el_.children[0].children[0].innerHTML = localizedMute;
      }

      /* TODO improve muted icon classes */
      for (var i = 0; i < 4; i++) {
        Dom.removeClass(this.el_, 'vjs-vol-' + i);
      }
      Dom.addClass(this.el_, 'vjs-vol-' + level);
    }
  }]);

  return MuteToggle;
})(_Button3['default']);

_Component2['default'].registerComponent('MuteToggle', MuteToggle);
exports['default'] = MuteToggle;
module.exports = exports['default'];

},{"../button":44,"../component":45,"../utils/dom.js":105}],50:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button.js');

var _Button3 = _interopRequireWildcard(_Button2);

var _Component = _dereq_('../component.js');

var _Component2 = _interopRequireWildcard(_Component);

/**
 * Button to toggle between play and pause
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var PlayToggle = (function (_Button) {
  function PlayToggle(player, options) {
    _classCallCheck(this, PlayToggle);

    _get(Object.getPrototypeOf(PlayToggle.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'play', this.handlePlay);
    this.on(player, 'pause', this.handlePause);
  }

  _inherits(PlayToggle, _Button);

  _createClass(PlayToggle, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-play-control ' + _get(Object.getPrototypeOf(PlayToggle.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleClick',

    // handleClick - Toggle between play and pause
    value: function handleClick() {
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }
  }, {
    key: 'handlePlay',

    // handlePlay - Add the vjs-playing class to the element so it can change appearance
    value: function handlePlay() {
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');
      this.el_.children[0].children[0].innerHTML = this.localize('Pause'); // change the button text to "Pause"
    }
  }, {
    key: 'handlePause',

    // handlePause - Add the vjs-paused class to the element so it can change appearance
    value: function handlePause() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.el_.children[0].children[0].innerHTML = this.localize('Play'); // change the button text to "Play"
    }
  }]);

  return PlayToggle;
})(_Button3['default']);

PlayToggle.prototype.buttonText = 'Play';

_Component2['default'].registerComponent('PlayToggle', PlayToggle);
exports['default'] = PlayToggle;
module.exports = exports['default'];

},{"../button.js":44,"../component.js":45}],51:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuButton2 = _dereq_('../../menu/menu-button.js');

var _MenuButton3 = _interopRequireWildcard(_MenuButton2);

var _Menu = _dereq_('../../menu/menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _PlaybackRateMenuItem = _dereq_('./playback-rate-menu-item.js');

var _PlaybackRateMenuItem2 = _interopRequireWildcard(_PlaybackRateMenuItem);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

/**
 * The component for controlling the playback rate
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PlaybackRateMenuButton = (function (_MenuButton) {
  function PlaybackRateMenuButton(player, options) {
    _classCallCheck(this, PlaybackRateMenuButton);

    _get(Object.getPrototypeOf(PlaybackRateMenuButton.prototype), 'constructor', this).call(this, player, options);

    this.updateVisibility();
    this.updateLabel();

    this.on(player, 'loadstart', this.updateVisibility);
    this.on(player, 'ratechange', this.updateLabel);
  }

  _inherits(PlaybackRateMenuButton, _MenuButton);

  _createClass(PlaybackRateMenuButton, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(PlaybackRateMenuButton.prototype), 'createEl', this).call(this);

      this.labelEl_ = Dom.createEl('div', {
        className: 'vjs-playback-rate-value',
        innerHTML: 1
      });

      el.appendChild(this.labelEl_);

      return el;
    }
  }, {
    key: 'createMenu',

    // Menu creation
    value: function createMenu() {
      var menu = new _Menu2['default'](this.player());
      var rates = this.player().options().playbackRates;

      if (rates) {
        for (var i = rates.length - 1; i >= 0; i--) {
          menu.addChild(new _PlaybackRateMenuItem2['default'](this.player(), { rate: rates[i] + 'x' }));
        }
      }

      return menu;
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Current playback rate
      this.el().setAttribute('aria-valuenow', this.player().playbackRate());
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      // select next rate option
      var currentRate = this.player().playbackRate();
      var rates = this.player().options().playbackRates;
      // this will select first one if the last one currently selected
      var newRate = rates[0];
      for (var i = 0; i < rates.length; i++) {
        if (rates[i] > currentRate) {
          newRate = rates[i];
          break;
        }
      }
      this.player().playbackRate(newRate);
    }
  }, {
    key: 'playbackRateSupported',
    value: function playbackRateSupported() {
      return this.player().tech && this.player().tech.featuresPlaybackRate && this.player().options().playbackRates && this.player().options().playbackRates.length > 0;
    }
  }, {
    key: 'updateVisibility',

    /**
     * Hide playback rate controls when they're no playback rate options to select
     */
    value: function updateVisibility() {
      if (this.playbackRateSupported()) {
        this.removeClass('vjs-hidden');
      } else {
        this.addClass('vjs-hidden');
      }
    }
  }, {
    key: 'updateLabel',

    /**
     * Update button label when rate changed
     */
    value: function updateLabel() {
      if (this.playbackRateSupported()) {
        this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
      }
    }
  }]);

  return PlaybackRateMenuButton;
})(_MenuButton3['default']);

PlaybackRateMenuButton.prototype.buttonText = 'Playback Rate';
PlaybackRateMenuButton.prototype.className = 'vjs-playback-rate';

_Component2['default'].registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);
exports['default'] = PlaybackRateMenuButton;
module.exports = exports['default'];

},{"../../component.js":45,"../../menu/menu-button.js":83,"../../menu/menu.js":85,"../../utils/dom.js":105,"./playback-rate-menu-item.js":52}],52:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuItem2 = _dereq_('../../menu/menu-item.js');

var _MenuItem3 = _interopRequireWildcard(_MenuItem2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

/**
 * The specific menu item type for selecting a playback rate
 *
 * @constructor
 */

var PlaybackRateMenuItem = (function (_MenuItem) {
  function PlaybackRateMenuItem(player, options) {
    _classCallCheck(this, PlaybackRateMenuItem);

    var label = options.rate;
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options.label = label;
    options.selected = rate === 1;
    _get(Object.getPrototypeOf(PlaybackRateMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.label = label;
    this.rate = rate;

    this.on(player, 'ratechange', this.update);
  }

  _inherits(PlaybackRateMenuItem, _MenuItem);

  _createClass(PlaybackRateMenuItem, [{
    key: 'handleClick',
    value: function handleClick() {
      _get(Object.getPrototypeOf(PlaybackRateMenuItem.prototype), 'handleClick', this).call(this);
      this.player().playbackRate(this.rate);
    }
  }, {
    key: 'update',
    value: function update() {
      this.selected(this.player().playbackRate() === this.rate);
    }
  }]);

  return PlaybackRateMenuItem;
})(_MenuItem3['default']);

PlaybackRateMenuItem.prototype.contentElType = 'button';

_Component2['default'].registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);
exports['default'] = PlaybackRateMenuItem;
module.exports = exports['default'];

},{"../../component.js":45,"../../menu/menu-item.js":84}],53:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

/**
 * Shows load progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var LoadProgressBar = (function (_Component) {
  function LoadProgressBar(player, options) {
    _classCallCheck(this, LoadProgressBar);

    _get(Object.getPrototypeOf(LoadProgressBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'progress', this.update);
  }

  _inherits(LoadProgressBar, _Component);

  _createClass(LoadProgressBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(LoadProgressBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-load-progress',
        innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
      });
    }
  }, {
    key: 'update',
    value: function update() {
      var buffered = this.player_.buffered();
      var duration = this.player_.duration();
      var bufferedEnd = this.player_.bufferedEnd();
      var children = this.el_.children;

      // get the percent width of a time compared to the total end
      var percentify = function percentify(time, end) {
        var percent = time / end || 0; // no NaN
        return (percent >= 1 ? 1 : percent) * 100 + '%';
      };

      // update the width of the progress bar
      this.el_.style.width = percentify(bufferedEnd, duration);

      // add child elements to represent the individual buffered time ranges
      for (var i = 0; i < buffered.length; i++) {
        var start = buffered.start(i);
        var end = buffered.end(i);
        var part = children[i];

        if (!part) {
          part = this.el_.appendChild(Dom.createEl());
        }

        // set the percent based on the width of the progress bar (bufferedEnd)
        part.style.left = percentify(start, bufferedEnd);
        part.style.width = percentify(end - start, bufferedEnd);
      }

      // remove unused buffered range elements
      for (var i = children.length; i > buffered.length; i--) {
        this.el_.removeChild(children[i - 1]);
      }
    }
  }]);

  return LoadProgressBar;
})(_Component3['default']);

_Component3['default'].registerComponent('LoadProgressBar', LoadProgressBar);
exports['default'] = LoadProgressBar;
module.exports = exports['default'];

},{"../../component.js":45,"../../utils/dom.js":105}],54:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

/**
 * Shows play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PlayProgressBar = (function (_Component) {
  function PlayProgressBar() {
    _classCallCheck(this, PlayProgressBar);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(PlayProgressBar, _Component);

  _createClass(PlayProgressBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(PlayProgressBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-play-progress',
        innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
      });
    }
  }]);

  return PlayProgressBar;
})(_Component3['default']);

_Component3['default'].registerComponent('PlayProgressBar', PlayProgressBar);
exports['default'] = PlayProgressBar;
module.exports = exports['default'];

},{"../../component.js":45}],55:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _SeekBar = _dereq_('./seek-bar.js');

var _SeekBar2 = _interopRequireWildcard(_SeekBar);

/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var ProgressControl = (function (_Component) {
  function ProgressControl() {
    _classCallCheck(this, ProgressControl);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(ProgressControl, _Component);

  _createClass(ProgressControl, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(ProgressControl.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-progress-control vjs-control'
      });
    }
  }]);

  return ProgressControl;
})(_Component3['default']);

ProgressControl.prototype.options_ = {
  children: {
    seekBar: {}
  }
};

_Component3['default'].registerComponent('ProgressControl', ProgressControl);
exports['default'] = ProgressControl;
module.exports = exports['default'];

},{"../../component.js":45,"./seek-bar.js":56}],56:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Slider2 = _dereq_('../../slider/slider.js');

var _Slider3 = _interopRequireWildcard(_Slider2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _LoadProgressBar = _dereq_('./load-progress-bar.js');

var _LoadProgressBar2 = _interopRequireWildcard(_LoadProgressBar);

var _PlayProgressBar = _dereq_('./play-progress-bar.js');

var _PlayProgressBar2 = _interopRequireWildcard(_PlayProgressBar);

var _SeekHandle = _dereq_('./seek-handle.js');

var _SeekHandle2 = _interopRequireWildcard(_SeekHandle);

var _import = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _formatTime = _dereq_('../../utils/format-time.js');

var _formatTime2 = _interopRequireWildcard(_formatTime);

var _roundFloat = _dereq_('../../utils/round-float.js');

var _roundFloat2 = _interopRequireWildcard(_roundFloat);

/**
 * Seek Bar and holder for the progress bars
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SeekBar = (function (_Slider) {
  function SeekBar(player, options) {
    _classCallCheck(this, SeekBar);

    _get(Object.getPrototypeOf(SeekBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'timeupdate', this.updateARIAAttributes);
    player.ready(Fn.bind(this, this.updateARIAAttributes));
  }

  _inherits(SeekBar, _Slider);

  _createClass(SeekBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(SeekBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-progress-holder',
        'aria-label': 'video progress bar'
      });
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Allows for smooth scrubbing, when player can't keep up.
      var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.el_.setAttribute('aria-valuenow', _roundFloat2['default'](this.getPercent() * 100, 2)); // machine readable value of progress bar (percentage complete)
      this.el_.setAttribute('aria-valuetext', _formatTime2['default'](time, this.player_.duration())); // human readable value of progress bar (time complete)
    }
  }, {
    key: 'getPercent',
    value: function getPercent() {
      var percent = this.player_.currentTime() / this.player_.duration();
      return percent >= 1 ? 1 : percent;
    }
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      _get(Object.getPrototypeOf(SeekBar.prototype), 'handleMouseDown', this).call(this, event);

      this.player_.scrubbing(true);

      this.videoWasPlaying = !this.player_.paused();
      this.player_.pause();
    }
  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      var newTime = this.calculateDistance(event) * this.player_.duration();

      // Don't let video end while scrubbing.
      if (newTime === this.player_.duration()) {
        newTime = newTime - 0.1;
      }

      // Set new time (tell player to seek to new time)
      this.player_.currentTime(newTime);
    }
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp(event) {
      _get(Object.getPrototypeOf(SeekBar.prototype), 'handleMouseUp', this).call(this, event);

      this.player_.scrubbing(false);
      if (this.videoWasPlaying) {
        this.player_.play();
      }
    }
  }, {
    key: 'stepForward',
    value: function stepForward() {
      this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
    }
  }, {
    key: 'stepBack',
    value: function stepBack() {
      this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users
    }
  }]);

  return SeekBar;
})(_Slider3['default']);

SeekBar.prototype.options_ = {
  children: {
    loadProgressBar: {},
    playProgressBar: {},
    seekHandle: {}
  },
  barName: 'playProgressBar',
  handleName: 'seekHandle'
};

SeekBar.prototype.playerEvent = 'timeupdate';

_Component2['default'].registerComponent('SeekBar', SeekBar);
exports['default'] = SeekBar;
module.exports = exports['default'];

},{"../../component.js":45,"../../slider/slider.js":92,"../../utils/fn.js":107,"../../utils/format-time.js":108,"../../utils/round-float.js":112,"./load-progress-bar.js":53,"./play-progress-bar.js":54,"./seek-handle.js":57}],57:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _SliderHandle2 = _dereq_('../../slider/slider-handle.js');

var _SliderHandle3 = _interopRequireWildcard(_SliderHandle2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _formatTime = _dereq_('../../utils/format-time.js');

var _formatTime2 = _interopRequireWildcard(_formatTime);

/**
 * The Seek Handle shows the current position of the playhead during playback,
 * and can be dragged to adjust the playhead.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SeekHandle = (function (_SliderHandle) {
  function SeekHandle(player, options) {
    _classCallCheck(this, SeekHandle);

    _get(Object.getPrototypeOf(SeekHandle.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(SeekHandle, _SliderHandle);

  _createClass(SeekHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl() {
      return _get(Object.getPrototypeOf(SeekHandle.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-seek-handle',
        'aria-live': 'off'
      });
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      var time = this.player_.scrubbing ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.el_.innerHTML = '<span class="vjs-control-text">' + _formatTime2['default'](time, this.player_.duration()) + '</span>';
    }
  }]);

  return SeekHandle;
})(_SliderHandle3['default']);

/**
 * The default value for the handle content, which may be read by screen readers
 *
 * @type {String}
 * @private
 */
SeekHandle.prototype.defaultValue = '00:00';

_Component2['default'].registerComponent('SeekHandle', SeekHandle);
exports['default'] = SeekHandle;
module.exports = exports['default'];

},{"../../component.js":45,"../../slider/slider-handle.js":91,"../../utils/format-time.js":108}],58:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Spacer2 = _dereq_('./spacer.js');

var _Spacer3 = _interopRequireWildcard(_Spacer2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

/**
 * Spacer specifically meant to be used as an insertion point for new plugins, etc.
 *
 * @param {Player|Object} player
 * @param {Obect=} options
 */

var CustomControlSpacer = (function (_Spacer) {
  function CustomControlSpacer() {
    _classCallCheck(this, CustomControlSpacer);

    if (_Spacer != null) {
      _Spacer.apply(this, arguments);
    }
  }

  _inherits(CustomControlSpacer, _Spacer);

  _createClass(CustomControlSpacer, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-custom-control-spacer ' + _get(Object.getPrototypeOf(CustomControlSpacer.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(CustomControlSpacer.prototype), 'createEl', this).call(this, {
        className: this.buildCSSClass()
      });
    }
  }]);

  return CustomControlSpacer;
})(_Spacer3['default']);

_Component2['default'].registerComponent('CustomControlSpacer', CustomControlSpacer);
exports['default'] = CustomControlSpacer;
module.exports = exports['default'];

},{"../../component.js":45,"./spacer.js":59}],59:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

/**
 * Just an empty spacer element that can be used as an append point for plugins, etc.
 * Also can be used to create space between elements when necessary.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 */

var Spacer = (function (_Component) {
  function Spacer() {
    _classCallCheck(this, Spacer);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(Spacer, _Component);

  _createClass(Spacer, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-spacer ' + _get(Object.getPrototypeOf(Spacer.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl(props) {
      return _get(Object.getPrototypeOf(Spacer.prototype), 'createEl', this).call(this, 'div', {
        className: this.buildCSSClass()
      });
    }
  }]);

  return Spacer;
})(_Component3['default']);

_Component3['default'].registerComponent('Spacer', Spacer);

exports['default'] = Spacer;
module.exports = exports['default'];

},{"../../component.js":45}],60:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackMenuItem2 = _dereq_('./text-track-menu-item.js');

var _TextTrackMenuItem3 = _interopRequireWildcard(_TextTrackMenuItem2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var CaptionSettingsMenuItem = (function (_TextTrackMenuItem) {
  function CaptionSettingsMenuItem(player, options) {
    _classCallCheck(this, CaptionSettingsMenuItem);

    options.track = {
      kind: options.kind,
      player: player,
      label: options.kind + ' settings',
      'default': false,
      mode: 'disabled'
    };

    _get(Object.getPrototypeOf(CaptionSettingsMenuItem.prototype), 'constructor', this).call(this, player, options);
    this.addClass('vjs-texttrack-settings');
  }

  _inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  _createClass(CaptionSettingsMenuItem, [{
    key: 'handleClick',
    value: function handleClick() {
      this.player().getChild('textTrackSettings').show();
    }
  }]);

  return CaptionSettingsMenuItem;
})(_TextTrackMenuItem3['default']);

_Component2['default'].registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);
exports['default'] = CaptionSettingsMenuItem;
module.exports = exports['default'];

},{"../../component.js":45,"./text-track-menu-item.js":67}],61:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackButton2 = _dereq_('./text-track-button.js');

var _TextTrackButton3 = _interopRequireWildcard(_TextTrackButton2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _CaptionSettingsMenuItem = _dereq_('./caption-settings-menu-item.js');

var _CaptionSettingsMenuItem2 = _interopRequireWildcard(_CaptionSettingsMenuItem);

/**
 * The button component for toggling and selecting captions
 *
 * @constructor
 */

var CaptionsButton = (function (_TextTrackButton) {
  function CaptionsButton(player, options, ready) {
    _classCallCheck(this, CaptionsButton);

    _get(Object.getPrototypeOf(CaptionsButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Captions Menu');
  }

  _inherits(CaptionsButton, _TextTrackButton);

  _createClass(CaptionsButton, [{
    key: 'update',
    value: function update() {
      var threshold = 2;
      _get(Object.getPrototypeOf(CaptionsButton.prototype), 'update', this).call(this);

      // if native, then threshold is 1 because no settings button
      if (this.player().tech && this.player().tech.featuresNativeTextTracks) {
        threshold = 1;
      }

      if (this.items && this.items.length > threshold) {
        this.show();
      } else {
        this.hide();
      }
    }
  }, {
    key: 'createItems',
    value: function createItems() {
      var items = [];

      if (!(this.player().tech && this.player().tech.featuresNativeTextTracks)) {
        items.push(new _CaptionSettingsMenuItem2['default'](this.player_, { kind: this.kind_ }));
      }

      return _get(Object.getPrototypeOf(CaptionsButton.prototype), 'createItems', this).call(this, items);
    }
  }]);

  return CaptionsButton;
})(_TextTrackButton3['default']);

CaptionsButton.prototype.kind_ = 'captions';
CaptionsButton.prototype.buttonText = 'Captions';
CaptionsButton.prototype.className = 'vjs-captions-button';

_Component2['default'].registerComponent('CaptionsButton', CaptionsButton);
exports['default'] = CaptionsButton;
module.exports = exports['default'];

},{"../../component.js":45,"./caption-settings-menu-item.js":60,"./text-track-button.js":66}],62:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackButton2 = _dereq_('./text-track-button.js');

var _TextTrackButton3 = _interopRequireWildcard(_TextTrackButton2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _TextTrackMenuItem = _dereq_('./text-track-menu-item.js');

var _TextTrackMenuItem2 = _interopRequireWildcard(_TextTrackMenuItem);

var _ChaptersTrackMenuItem = _dereq_('./chapters-track-menu-item.js');

var _ChaptersTrackMenuItem2 = _interopRequireWildcard(_ChaptersTrackMenuItem);

var _Menu = _dereq_('../../menu/menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _import = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _import2 = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_import2);

var _toTitleCase = _dereq_('../../utils/to-title-case.js');

var _toTitleCase2 = _interopRequireWildcard(_toTitleCase);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

// Chapters act much differently than other text tracks
// Cues are navigation vs. other tracks of alternative languages
/**
 * The button component for toggling and selecting chapters
 *
 * @constructor
 */

var ChaptersButton = (function (_TextTrackButton) {
  function ChaptersButton(player, options, ready) {
    _classCallCheck(this, ChaptersButton);

    _get(Object.getPrototypeOf(ChaptersButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Chapters Menu');
  }

  _inherits(ChaptersButton, _TextTrackButton);

  _createClass(ChaptersButton, [{
    key: 'createItems',

    // Create a menu item for each text track
    value: function createItems() {
      var items = [];

      var tracks = this.player_.textTracks();

      if (!tracks) {
        return items;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track.kind === this.kind_) {
          items.push(new _TextTrackMenuItem2['default'](this.player_, {
            track: track
          }));
        }
      }

      return items;
    }
  }, {
    key: 'createMenu',
    value: function createMenu() {
      var tracks = this.player_.textTracks() || [];
      var chaptersTrack = undefined;
      var items = this.items = [];

      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (track.kind === this.kind_) {
          if (!track.cues) {
            track.mode = 'hidden';
            /* jshint loopfunc:true */
            // TODO see if we can figure out a better way of doing this https://github.com/videojs/video.js/issues/1864
            _window2['default'].setTimeout(Fn.bind(this, function () {
              this.createMenu();
            }), 100);
            /* jshint loopfunc:false */
          } else {
            chaptersTrack = track;
            break;
          }
        }
      }

      var menu = this.menu;
      if (menu === undefined) {
        menu = new _Menu2['default'](this.player_);
        menu.contentEl().appendChild(Dom.createEl('li', {
          className: 'vjs-menu-title',
          innerHTML: _toTitleCase2['default'](this.kind_),
          tabindex: -1
        }));
      }

      if (chaptersTrack) {
        var cues = chaptersTrack.cues,
            cue = undefined;

        for (var i = 0, l = cues.length; i < l; i++) {
          cue = cues[i];

          var mi = new _ChaptersTrackMenuItem2['default'](this.player_, {
            track: chaptersTrack,
            cue: cue
          });

          items.push(mi);

          menu.addChild(mi);
        }
        this.addChild(menu);
      }

      if (this.items.length > 0) {
        this.show();
      }

      return menu;
    }
  }]);

  return ChaptersButton;
})(_TextTrackButton3['default']);

ChaptersButton.prototype.kind_ = 'chapters';
ChaptersButton.prototype.buttonText = 'Chapters';
ChaptersButton.prototype.className = 'vjs-chapters-button';

_Component2['default'].registerComponent('ChaptersButton', ChaptersButton);
exports['default'] = ChaptersButton;
module.exports = exports['default'];

},{"../../component.js":45,"../../menu/menu.js":85,"../../utils/dom.js":105,"../../utils/fn.js":107,"../../utils/to-title-case.js":114,"./chapters-track-menu-item.js":63,"./text-track-button.js":66,"./text-track-menu-item.js":67,"global/window":2}],63:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuItem2 = _dereq_('../../menu/menu-item.js');

var _MenuItem3 = _interopRequireWildcard(_MenuItem2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

/**
 * @constructor
 */

var ChaptersTrackMenuItem = (function (_MenuItem) {
  function ChaptersTrackMenuItem(player, options) {
    _classCallCheck(this, ChaptersTrackMenuItem);

    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
    _get(Object.getPrototypeOf(ChaptersTrackMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.track = track;
    this.cue = cue;
    track.addEventListener('cuechange', Fn.bind(this, this.update));
  }

  _inherits(ChaptersTrackMenuItem, _MenuItem);

  _createClass(ChaptersTrackMenuItem, [{
    key: 'handleClick',
    value: function handleClick() {
      _get(Object.getPrototypeOf(ChaptersTrackMenuItem.prototype), 'handleClick', this).call(this);
      this.player_.currentTime(this.cue.startTime);
      this.update(this.cue.startTime);
    }
  }, {
    key: 'update',
    value: function update() {
      var cue = this.cue;
      var currentTime = this.player_.currentTime();

      // vjs.log(currentTime, cue.startTime);
      this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
    }
  }]);

  return ChaptersTrackMenuItem;
})(_MenuItem3['default']);

_Component2['default'].registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);
exports['default'] = ChaptersTrackMenuItem;
module.exports = exports['default'];

},{"../../component.js":45,"../../menu/menu-item.js":84,"../../utils/fn.js":107}],64:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackMenuItem2 = _dereq_('./text-track-menu-item.js');

var _TextTrackMenuItem3 = _interopRequireWildcard(_TextTrackMenuItem2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

/**
 * A special menu item for turning of a specific type of text track
 *
 * @constructor
 */

var OffTextTrackMenuItem = (function (_TextTrackMenuItem) {
  function OffTextTrackMenuItem(player, options) {
    _classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options.track = {
      kind: options.kind,
      player: player,
      label: options.kind + ' off',
      'default': false,
      mode: 'disabled'
    };

    _get(Object.getPrototypeOf(OffTextTrackMenuItem.prototype), 'constructor', this).call(this, player, options);
    this.selected(true);
  }

  _inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  _createClass(OffTextTrackMenuItem, [{
    key: 'handleTracksChange',
    value: function handleTracksChange(event) {
      var tracks = this.player().textTracks();
      var selected = true;

      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (track.kind === this.track.kind && track.mode === 'showing') {
          selected = false;
          break;
        }
      }

      this.selected(selected);
    }
  }]);

  return OffTextTrackMenuItem;
})(_TextTrackMenuItem3['default']);

_Component2['default'].registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);
exports['default'] = OffTextTrackMenuItem;
module.exports = exports['default'];

},{"../../component.js":45,"./text-track-menu-item.js":67}],65:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackButton2 = _dereq_('./text-track-button.js');

var _TextTrackButton3 = _interopRequireWildcard(_TextTrackButton2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

/**
 * The button component for toggling and selecting subtitles
 *
 * @constructor
 */

var SubtitlesButton = (function (_TextTrackButton) {
  function SubtitlesButton(player, options, ready) {
    _classCallCheck(this, SubtitlesButton);

    _get(Object.getPrototypeOf(SubtitlesButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Subtitles Menu');
  }

  _inherits(SubtitlesButton, _TextTrackButton);

  return SubtitlesButton;
})(_TextTrackButton3['default']);

SubtitlesButton.prototype.kind_ = 'subtitles';
SubtitlesButton.prototype.buttonText = 'Subtitles';
SubtitlesButton.prototype.className = 'vjs-subtitles-button';

_Component2['default'].registerComponent('SubtitlesButton', SubtitlesButton);
exports['default'] = SubtitlesButton;
module.exports = exports['default'];

},{"../../component.js":45,"./text-track-button.js":66}],66:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuButton2 = _dereq_('../../menu/menu-button.js');

var _MenuButton3 = _interopRequireWildcard(_MenuButton2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _TextTrackMenuItem = _dereq_('./text-track-menu-item.js');

var _TextTrackMenuItem2 = _interopRequireWildcard(_TextTrackMenuItem);

var _OffTextTrackMenuItem = _dereq_('./off-text-track-menu-item.js');

var _OffTextTrackMenuItem2 = _interopRequireWildcard(_OffTextTrackMenuItem);

/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @constructor
 */

var TextTrackButton = (function (_MenuButton) {
  function TextTrackButton(player, options) {
    _classCallCheck(this, TextTrackButton);

    _get(Object.getPrototypeOf(TextTrackButton.prototype), 'constructor', this).call(this, player, options);

    var tracks = this.player_.textTracks();

    if (this.items.length <= 1) {
      this.hide();
    }

    if (!tracks) {
      return;
    }

    var updateHandler = Fn.bind(this, this.update);
    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);

    this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
  }

  _inherits(TextTrackButton, _MenuButton);

  _createClass(TextTrackButton, [{
    key: 'createItems',

    // Create a menu item for each text track
    value: function createItems() {
      var items = arguments[0] === undefined ? [] : arguments[0];

      // Add an OFF menu item to turn all tracks off
      items.push(new _OffTextTrackMenuItem2['default'](this.player_, { kind: this.kind_ }));

      var tracks = this.player_.textTracks();

      if (!tracks) {
        return items;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        // only add tracks that are of the appropriate kind and have a label
        if (track.kind === this.kind_) {
          items.push(new _TextTrackMenuItem2['default'](this.player_, {
            track: track
          }));
        }
      }

      return items;
    }
  }]);

  return TextTrackButton;
})(_MenuButton3['default']);

_Component2['default'].registerComponent('TextTrackButton', TextTrackButton);
exports['default'] = TextTrackButton;
module.exports = exports['default'];

},{"../../component.js":45,"../../menu/menu-button.js":83,"../../utils/fn.js":107,"./off-text-track-menu-item.js":64,"./text-track-menu-item.js":67}],67:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuItem2 = _dereq_('../../menu/menu-item.js');

var _MenuItem3 = _interopRequireWildcard(_MenuItem2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * The specific menu item type for selecting a language within a text track kind
 *
 * @constructor
 */

var TextTrackMenuItem = (function (_MenuItem) {
  function TextTrackMenuItem(player, options) {
    var _this = this;

    _classCallCheck(this, TextTrackMenuItem);

    var track = options.track;
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track['default'] || track.mode === 'showing';
    _get(Object.getPrototypeOf(TextTrackMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.track = track;

    if (tracks) {
      (function () {
        var changeHandler = Fn.bind(_this, _this.handleTracksChange);

        tracks.addEventListener('change', changeHandler);
        _this.on('dispose', function () {
          tracks.removeEventListener('change', changeHandler);
        });
      })();
    }

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks && tracks.onchange === undefined) {
      (function () {
        var event = undefined;

        _this.on(['tap', 'click'], function () {
          if (typeof _window2['default'].Event !== 'object') {
            // Android 2.3 throws an Illegal Constructor error for window.Event
            try {
              event = new _window2['default'].Event('change');
            } catch (err) {}
          }

          if (!event) {
            event = _document2['default'].createEvent('Event');
            event.initEvent('change', true, true);
          }

          tracks.dispatchEvent(event);
        });
      })();
    }
  }

  _inherits(TextTrackMenuItem, _MenuItem);

  _createClass(TextTrackMenuItem, [{
    key: 'handleClick',
    value: function handleClick(event) {
      var kind = this.track.kind;
      var tracks = this.player_.textTracks();

      _get(Object.getPrototypeOf(TextTrackMenuItem.prototype), 'handleClick', this).call(this, event);

      if (!tracks) {
        return;
      }for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        if (track.kind !== kind) {
          continue;
        }

        if (track === this.track) {
          track.mode = 'showing';
        } else {
          track.mode = 'disabled';
        }
      }
    }
  }, {
    key: 'handleTracksChange',
    value: function handleTracksChange(event) {
      this.selected(this.track.mode === 'showing');
    }
  }]);

  return TextTrackMenuItem;
})(_MenuItem3['default']);

_Component2['default'].registerComponent('TextTrackMenuItem', TextTrackMenuItem);
exports['default'] = TextTrackMenuItem;
module.exports = exports['default'];

},{"../../component.js":45,"../../menu/menu-item.js":84,"../../utils/fn.js":107,"global/document":1,"global/window":2}],68:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _formatTime = _dereq_('../../utils/format-time.js');

var _formatTime2 = _interopRequireWildcard(_formatTime);

/**
 * Displays the current time
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var CurrentTimeDisplay = (function (_Component) {
  function CurrentTimeDisplay(player, options) {
    _classCallCheck(this, CurrentTimeDisplay);

    _get(Object.getPrototypeOf(CurrentTimeDisplay.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(CurrentTimeDisplay, _Component);

  _createClass(CurrentTimeDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(CurrentTimeDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-current-time vjs-time-control vjs-control'
      });

      this.contentEl_ = Dom.createEl('div', {
        className: 'vjs-current-time-display',
        innerHTML: '<span class="vjs-control-text">Current Time </span>' + '0:00', // label the current time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      // Allows for smooth scrubbing, when player can't keep up.
      var time = this.player_.scrubbing ? this.player_.getCache().currentTime : this.player_.currentTime();
      var localizedText = this.localize('Current Time');
      var formattedTime = _formatTime2['default'](time, this.player_.duration());
      this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> ' + formattedTime;
    }
  }]);

  return CurrentTimeDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);
exports['default'] = CurrentTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":45,"../../utils/dom.js":105,"../../utils/format-time.js":108}],69:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _formatTime = _dereq_('../../utils/format-time.js');

var _formatTime2 = _interopRequireWildcard(_formatTime);

/**
 * Displays the duration
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var DurationDisplay = (function (_Component) {
  function DurationDisplay(player, options) {
    _classCallCheck(this, DurationDisplay);

    _get(Object.getPrototypeOf(DurationDisplay.prototype), 'constructor', this).call(this, player, options);

    // this might need to be changed to 'durationchange' instead of 'timeupdate' eventually,
    // however the durationchange event fires before this.player_.duration() is set,
    // so the value cannot be written out using this method.
    // Once the order of durationchange and this.player_.duration() being set is figured out,
    // this can be updated.
    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(DurationDisplay, _Component);

  _createClass(DurationDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(DurationDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-duration vjs-time-control vjs-control'
      });

      this.contentEl_ = Dom.createEl('div', {
        className: 'vjs-duration-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> 0:00', // label the duration time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      var duration = this.player_.duration();
      if (duration) {
        var localizedText = this.localize('Duration Time');
        var formattedTime = _formatTime2['default'](duration);
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> ' + formattedTime; // label the duration time for screen reader users
      }
    }
  }]);

  return DurationDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('DurationDisplay', DurationDisplay);
exports['default'] = DurationDisplay;
module.exports = exports['default'];

},{"../../component.js":45,"../../utils/dom.js":105,"../../utils/format-time.js":108}],70:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _formatTime = _dereq_('../../utils/format-time.js');

var _formatTime2 = _interopRequireWildcard(_formatTime);

/**
 * Displays the time left in the video
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var RemainingTimeDisplay = (function (_Component) {
  function RemainingTimeDisplay(player, options) {
    _classCallCheck(this, RemainingTimeDisplay);

    _get(Object.getPrototypeOf(RemainingTimeDisplay.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(RemainingTimeDisplay, _Component);

  _createClass(RemainingTimeDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(RemainingTimeDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-remaining-time vjs-time-control vjs-control'
      });

      this.contentEl_ = Dom.createEl('div', {
        className: 'vjs-remaining-time-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> -0:00', // label the remaining time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      if (this.player_.duration()) {
        var localizedText = this.localize('Remaining Time');
        var formattedTime = _formatTime2['default'](this.player_.remainingTime());
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> -' + formattedTime;
      }

      // Allows for smooth scrubbing, when player can't keep up.
      // var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
      // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());
    }
  }]);

  return RemainingTimeDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);
exports['default'] = RemainingTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":45,"../../utils/dom.js":105,"../../utils/format-time.js":108}],71:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

/**
 * The separator between the current time and duration
 *
 * Can be hidden if it's not needed in the design.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var TimeDivider = (function (_Component) {
  function TimeDivider() {
    _classCallCheck(this, TimeDivider);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(TimeDivider, _Component);

  _createClass(TimeDivider, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TimeDivider.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-time-control vjs-time-divider',
        innerHTML: '<div><span>/</span></div>'
      });
    }
  }]);

  return TimeDivider;
})(_Component3['default']);

_Component3['default'].registerComponent('TimeDivider', TimeDivider);
exports['default'] = TimeDivider;
module.exports = exports['default'];

},{"../../component.js":45}],72:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Slider2 = _dereq_('../../slider/slider.js');

var _Slider3 = _interopRequireWildcard(_Slider2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _roundFloat = _dereq_('../../utils/round-float.js');

var _roundFloat2 = _interopRequireWildcard(_roundFloat);

// Required children

var _VolumeHandle = _dereq_('./volume-handle.js');

var _VolumeHandle2 = _interopRequireWildcard(_VolumeHandle);

var _VolumeLevel = _dereq_('./volume-level.js');

var _VolumeLevel2 = _interopRequireWildcard(_VolumeLevel);

/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeBar = (function (_Slider) {
  function VolumeBar(player, options) {
    _classCallCheck(this, VolumeBar);

    _get(Object.getPrototypeOf(VolumeBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'volumechange', this.updateARIAAttributes);
    player.ready(Fn.bind(this, this.updateARIAAttributes));
  }

  _inherits(VolumeBar, _Slider);

  _createClass(VolumeBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-bar',
        'aria-label': 'volume level'
      });
    }
  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      if (this.player_.muted()) {
        this.player_.muted(false);
      }

      this.player_.volume(this.calculateDistance(event));
    }
  }, {
    key: 'getPercent',
    value: function getPercent() {
      if (this.player_.muted()) {
        return 0;
      } else {
        return this.player_.volume();
      }
    }
  }, {
    key: 'stepForward',
    value: function stepForward() {
      this.player_.volume(this.player_.volume() + 0.1);
    }
  }, {
    key: 'stepBack',
    value: function stepBack() {
      this.player_.volume(this.player_.volume() - 0.1);
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Current value of volume bar as a percentage
      this.el_.setAttribute('aria-valuenow', _roundFloat2['default'](this.player_.volume() * 100, 2));
      this.el_.setAttribute('aria-valuetext', _roundFloat2['default'](this.player_.volume() * 100, 2) + '%');
    }
  }]);

  return VolumeBar;
})(_Slider3['default']);

VolumeBar.prototype.options_ = {
  children: {
    volumeLevel: {},
    volumeHandle: {}
  },
  barName: 'volumeLevel',
  handleName: 'volumeHandle'
};

VolumeBar.prototype.playerEvent = 'volumechange';

_Component2['default'].registerComponent('VolumeBar', VolumeBar);
exports['default'] = VolumeBar;
module.exports = exports['default'];

},{"../../component.js":45,"../../slider/slider.js":92,"../../utils/fn.js":107,"../../utils/round-float.js":112,"./volume-handle.js":74,"./volume-level.js":75}],73:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

// Required children

var _VolumeBar = _dereq_('./volume-bar.js');

var _VolumeBar2 = _interopRequireWildcard(_VolumeBar);

/**
 * The component for controlling the volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeControl = (function (_Component) {
  function VolumeControl(player, options) {
    _classCallCheck(this, VolumeControl);

    _get(Object.getPrototypeOf(VolumeControl.prototype), 'constructor', this).call(this, player, options);

    // hide volume controls when they're not supported by the current tech
    if (player.tech && player.tech.featuresVolumeControl === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function () {
      if (player.tech.featuresVolumeControl === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }

  _inherits(VolumeControl, _Component);

  _createClass(VolumeControl, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeControl.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-control vjs-control'
      });
    }
  }]);

  return VolumeControl;
})(_Component3['default']);

VolumeControl.prototype.options_ = {
  children: {
    volumeBar: {}
  }
};

_Component3['default'].registerComponent('VolumeControl', VolumeControl);
exports['default'] = VolumeControl;
module.exports = exports['default'];

},{"../../component.js":45,"./volume-bar.js":72}],74:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _SliderHandle2 = _dereq_('../../slider/slider-handle.js');

var _SliderHandle3 = _interopRequireWildcard(_SliderHandle2);

var _Component = _dereq_('../../component.js');

var _Component2 = _interopRequireWildcard(_Component);

/**
 * The volume handle can be dragged to adjust the volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeHandle = (function (_SliderHandle) {
  function VolumeHandle() {
    _classCallCheck(this, VolumeHandle);

    if (_SliderHandle != null) {
      _SliderHandle.apply(this, arguments);
    }
  }

  _inherits(VolumeHandle, _SliderHandle);

  _createClass(VolumeHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeHandle.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-handle'
      });
    }
  }]);

  return VolumeHandle;
})(_SliderHandle3['default']);

VolumeHandle.prototype.defaultValue = '00:00';

_Component2['default'].registerComponent('VolumeHandle', VolumeHandle);
exports['default'] = VolumeHandle;
module.exports = exports['default'];

},{"../../component.js":45,"../../slider/slider-handle.js":91}],75:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

/**
 * Shows volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeLevel = (function (_Component) {
  function VolumeLevel() {
    _classCallCheck(this, VolumeLevel);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(VolumeLevel, _Component);

  _createClass(VolumeLevel, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeLevel.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-level',
        innerHTML: '<span class="vjs-control-text"></span>'
      });
    }
  }]);

  return VolumeLevel;
})(_Component3['default']);

_Component3['default'].registerComponent('VolumeLevel', VolumeLevel);
exports['default'] = VolumeLevel;
module.exports = exports['default'];

},{"../../component.js":45}],76:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button = _dereq_('../button.js');

var _Button2 = _interopRequireWildcard(_Button);

var _Component = _dereq_('../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _Menu = _dereq_('../menu/menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _MenuButton2 = _dereq_('../menu/menu-button.js');

var _MenuButton3 = _interopRequireWildcard(_MenuButton2);

var _MuteToggle = _dereq_('./mute-toggle.js');

var _MuteToggle2 = _interopRequireWildcard(_MuteToggle);

var _VolumeBar = _dereq_('./volume-control/volume-bar.js');

var _VolumeBar2 = _interopRequireWildcard(_VolumeBar);

/**
 * Menu button with a popup for showing the volume slider.
 * @constructor
 */

var VolumeMenuButton = (function (_MenuButton) {
  function VolumeMenuButton(player, options) {
    _classCallCheck(this, VolumeMenuButton);

    _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'constructor', this).call(this, player, options);

    // Same listeners as MuteToggle
    this.on(player, 'volumechange', this.volumeUpdate);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech && player.tech.featuresVolumeControl === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function () {
      if (player.tech.featuresVolumeControl === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
    this.addClass('vjs-menu-button');
  }

  _inherits(VolumeMenuButton, _MenuButton);

  _createClass(VolumeMenuButton, [{
    key: 'createMenu',
    value: function createMenu() {
      var menu = new _Menu2['default'](this.player_, {
        contentElType: 'div'
      });

      // The volumeBar is vertical by default in the base theme when used with a VolumeMenuButton
      var options = this.options_.volumeBar || {};
      options.vertical = options.vertical || true;

      var vc = new _VolumeBar2['default'](this.player_, options);

      vc.on('focus', function () {
        menu.lockShowing();
      });
      vc.on('blur', function () {
        menu.unlockShowing();
      });
      menu.addChild(vc);
      return menu;
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      _MuteToggle2['default'].prototype.handleClick.call(this);
      _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'handleClick', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-menu-button vjs-menu-button vjs-control vjs-button',
        innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
      });
    }
  }]);

  return VolumeMenuButton;
})(_MenuButton3['default']);

VolumeMenuButton.prototype.volumeUpdate = _MuteToggle2['default'].prototype.update;

_Component2['default'].registerComponent('VolumeMenuButton', VolumeMenuButton);
exports['default'] = VolumeMenuButton;
module.exports = exports['default'];

},{"../button.js":44,"../component.js":45,"../menu/menu-button.js":83,"../menu/menu.js":85,"./mute-toggle.js":49,"./volume-control/volume-bar.js":72}],77:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('./component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_import);

/**
 * Display that an error has occurred making the video unplayable
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var ErrorDisplay = (function (_Component) {
  function ErrorDisplay(player, options) {
    _classCallCheck(this, ErrorDisplay);

    _get(Object.getPrototypeOf(ErrorDisplay.prototype), 'constructor', this).call(this, player, options);

    this.update();
    this.on(player, 'error', this.update);
  }

  _inherits(ErrorDisplay, _Component);

  _createClass(ErrorDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(ErrorDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-error-display'
      });

      this.contentEl_ = Dom.createEl('div');
      el.appendChild(this.contentEl_);

      return el;
    }
  }, {
    key: 'update',
    value: function update() {
      if (this.player().error()) {
        this.contentEl_.innerHTML = this.localize(this.player().error().message);
      }
    }
  }]);

  return ErrorDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('ErrorDisplay', ErrorDisplay);
exports['default'] = ErrorDisplay;
module.exports = exports['default'];

},{"./component":45,"./utils/dom.js":105}],78:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_import);

var EventEmitter = function EventEmitter() {};

EventEmitter.prototype.allowedEvents_ = {};

EventEmitter.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;
  this.addEventListener = Function.prototype;
  Events.on(this, type, fn);
  this.addEventListener = ael;
};
EventEmitter.prototype.addEventListener = EventEmitter.prototype.on;

EventEmitter.prototype.off = function (type, fn) {
  Events.off(this, type, fn);
};
EventEmitter.prototype.removeEventListener = EventEmitter.prototype.off;

EventEmitter.prototype.one = function (type, fn) {
  Events.one(this, type, fn);
};

EventEmitter.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = {
      type: type
    };
  }
  event = Events.fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  Events.trigger(this, event);
};
// The standard DOM EventTarget.dispatchEvent() is aliased to trigger()
EventEmitter.prototype.dispatchEvent = EventEmitter.prototype.trigger;

exports['default'] = EventEmitter;
module.exports = exports['default'];

},{"./utils/events.js":106}],79:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/**
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 *
 * ```
 * var Button = videojs.getComponent('Button');
 *
 * var MyButton = videojs.extends(Button, {
 *   constructor: function(player, options) {
 *     Button.call(this, player, options);
 *   },
 *
 *   onClick: function() {
 *     // doSomething
 *   }
 * });
 * ```
 */
var extendsFn = function extendsFn(superClass) {
  var subClassMethods = arguments[1] === undefined ? {} : arguments[1];

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };
  var methods = {};

  if (subClassMethods.constructor !== Object.prototype.constructor) {
    subClass = subClassMethods.constructor;
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

exports['default'] = extendsFn;
module.exports = exports['default'];

},{}],80:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * Store the browser-specific methods for the fullscreen API
 * @type {Object|undefined}
 * @private
 */
var FullscreenApi = {};

// browser API methods
// map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
var apiMap = [
// Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = undefined;

// determine the supported set of functions
for (var i = 0; i < apiMap.length; i++) {
  // check for exitFullscreen function
  if (apiMap[i][1] in _document2['default']) {
    browserApi = apiMap[i];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var i = 0; i < browserApi.length; i++) {
    FullscreenApi[specApi[i]] = browserApi[i];
  }
}

exports['default'] = FullscreenApi;
module.exports = exports['default'];

},{"global/document":1}],81:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('./component');

var _Component3 = _interopRequireWildcard(_Component2);

/* Loading Spinner
================================================================================ */
/**
 * Loading spinner for waiting events
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var LoadingSpinner = (function (_Component) {
  function LoadingSpinner() {
    _classCallCheck(this, LoadingSpinner);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(LoadingSpinner, _Component);

  _createClass(LoadingSpinner, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(LoadingSpinner.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-loading-spinner'
      });
    }
  }]);

  return LoadingSpinner;
})(_Component3['default']);

_Component3['default'].registerComponent('LoadingSpinner', LoadingSpinner);
exports['default'] = LoadingSpinner;
module.exports = exports['default'];

},{"./component":45}],82:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

/**
 * Custom MediaError to mimic the HTML5 MediaError
 * @param {Number} code The media error code
 */
var MediaError = (function (_MediaError) {
  function MediaError(_x) {
    return _MediaError.apply(this, arguments);
  }

  MediaError.toString = function () {
    return _MediaError.toString();
  };

  return MediaError;
})(function (code) {
  if (typeof code === 'number') {
    this.code = code;
  } else if (typeof code === 'string') {
    // default code is zero, so this is a custom error
    this.message = code;
  } else if (typeof code === 'object') {
    // object
    _assign2['default'](this, code);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
});

/**
 * The error code that refers two one of the defined
 * MediaError types
 * @type {Number}
 */
MediaError.prototype.code = 0;

/**
 * An optional message to be shown with the error.
 * Message is not part of the HTML5 video spec
 * but allows for more informative custom errors.
 * @type {String}
 */
MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins
 * to allow even more detail about the error.
 * For example the HLS plugin might provide the specific
 * HTTP status code that was returned when the error
 * occurred, then allowing a custom error overlay
 * to display more information.
 * @type {[type]}
 */
MediaError.prototype.status = null;

MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', // = 0
'MEDIA_ERR_ABORTED', // = 1
'MEDIA_ERR_NETWORK', // = 2
'MEDIA_ERR_DECODE', // = 3
'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
'MEDIA_ERR_ENCRYPTED' // = 5
];

MediaError.defaultMessages = {
  1: 'You aborted the video playback',
  2: 'A network error caused the video download to fail part-way.',
  3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
  4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The video is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

exports['default'] = MediaError;
module.exports = exports['default'];

},{"object.assign":37}],83:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button.js');

var _Button3 = _interopRequireWildcard(_Button2);

var _Component = _dereq_('../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _Menu = _dereq_('./menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _import = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _import2 = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_import2);

var _toTitleCase = _dereq_('../utils/to-title-case.js');

var _toTitleCase2 = _interopRequireWildcard(_toTitleCase);

/**
 * A button class with a popup menu
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var MenuButton = (function (_Button) {
  function MenuButton(player, options) {
    _classCallCheck(this, MenuButton);

    _get(Object.getPrototypeOf(MenuButton.prototype), 'constructor', this).call(this, player, options);

    this.update();

    this.on('keydown', this.handleKeyPress);
    this.el_.setAttribute('aria-haspopup', true);
    this.el_.setAttribute('role', 'button');
  }

  _inherits(MenuButton, _Button);

  _createClass(MenuButton, [{
    key: 'update',
    value: function update() {
      var menu = this.createMenu();

      if (this.menu) {
        this.removeChild(this.menu);
      }

      this.menu = menu;
      this.addChild(menu);

      /**
       * Track the state of the menu button
       * @type {Boolean}
       * @private
       */
      this.buttonPressed_ = false;

      if (this.items && this.items.length === 0) {
        this.hide();
      } else if (this.items && this.items.length > 1) {
        this.show();
      }
    }
  }, {
    key: 'createMenu',
    value: function createMenu() {
      var menu = new _Menu2['default'](this.player_);

      // Add a title list item to the top
      if (this.options().title) {
        menu.contentEl().appendChild(Dom.createEl('li', {
          className: 'vjs-menu-title',
          innerHTML: _toTitleCase2['default'](this.options().title),
          tabindex: -1
        }));
      }

      this.items = this.createItems();

      if (this.items) {
        // Add menu items to the menu
        for (var i = 0; i < this.items.length; i++) {
          menu.addItem(this.items[i]);
        }
      }

      return menu;
    }
  }, {
    key: 'createItems',

    /**
     * Create the list of menu items. Specific to each subclass.
     */
    value: function createItems() {}
  }, {
    key: 'buildCSSClass',

    /** @inheritDoc */
    value: function buildCSSClass() {
      return '' + this.className + ' vjs-menu-button ' + _get(Object.getPrototypeOf(MenuButton.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleFocus',

    // Focus - Add keyboard functionality to element
    // This function is not needed anymore. Instead, the keyboard functionality is handled by
    // treating the button as triggering a submenu. When the button is pressed, the submenu
    // appears. Pressing the button again makes the submenu disappear.
    value: function handleFocus() {}
  }, {
    key: 'handleBlur',

    // Can't turn off list display that we turned on with focus, because list would go away.
    value: function handleBlur() {}
  }, {
    key: 'handleClick',
    value: function handleClick() {
      // When you click the button it adds focus, which will show the menu indefinitely.
      // So we'll remove focus when the mouse leaves the button.
      // Focus is needed for tab navigation.
      this.one('mouseout', Fn.bind(this, function () {
        this.menu.unlockShowing();
        this.el_.blur();
      }));
      if (this.buttonPressed_) {
        this.unpressButton();
      } else {
        this.pressButton();
      }
    }
  }, {
    key: 'handleKeyPress',
    value: function handleKeyPress(event) {

      // Check for space bar (32) or enter (13) keys
      if (event.which === 32 || event.which === 13) {
        if (this.buttonPressed_) {
          this.unpressButton();
        } else {
          this.pressButton();
        }
        event.preventDefault();
        // Check for escape (27) key
      } else if (event.which === 27) {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        event.preventDefault();
      }
    }
  }, {
    key: 'pressButton',
    value: function pressButton() {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.el_.setAttribute('aria-pressed', true);
      if (this.items && this.items.length > 0) {
        this.items[0].el().focus(); // set the focus to the title of the submenu
      }
    }
  }, {
    key: 'unpressButton',
    value: function unpressButton() {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.el_.setAttribute('aria-pressed', false);
    }
  }]);

  return MenuButton;
})(_Button3['default']);

_Component2['default'].registerComponent('MenuButton', MenuButton);
exports['default'] = MenuButton;
module.exports = exports['default'];

},{"../button.js":44,"../component.js":45,"../utils/dom.js":105,"../utils/fn.js":107,"../utils/to-title-case.js":114,"./menu.js":85}],84:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button.js');

var _Button3 = _interopRequireWildcard(_Button2);

var _Component = _dereq_('../component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

/**
 * The component for a menu item. `<li>`
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var MenuItem = (function (_Button) {
  function MenuItem(player, options) {
    _classCallCheck(this, MenuItem);

    _get(Object.getPrototypeOf(MenuItem.prototype), 'constructor', this).call(this, player, options);
    this.selected(options.selected);
  }

  _inherits(MenuItem, _Button);

  _createClass(MenuItem, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl(type, props) {
      return _get(Object.getPrototypeOf(MenuItem.prototype), 'createEl', this).call(this, 'li', _assign2['default']({
        className: 'vjs-menu-item',
        innerHTML: this.localize(this.options_.label)
      }, props));
    }
  }, {
    key: 'handleClick',

    /**
     * Handle a click on the menu item, and set it to selected
     */
    value: function handleClick() {
      this.selected(true);
    }
  }, {
    key: 'selected',

    /**
     * Set this menu item as selected or not
     * @param  {Boolean} selected
     */
    value: (function (_selected) {
      function selected(_x) {
        return _selected.apply(this, arguments);
      }

      selected.toString = function () {
        return _selected.toString();
      };

      return selected;
    })(function (selected) {
      if (selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-selected', true);
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-selected', false);
      }
    })
  }]);

  return MenuItem;
})(_Button3['default']);

_Component2['default'].registerComponent('MenuItem', MenuItem);
exports['default'] = MenuItem;
module.exports = exports['default'];

},{"../button.js":44,"../component.js":45,"object.assign":37}],85:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _import2 = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_import2);

var _import3 = _dereq_('../utils/events.js');

var Events = _interopRequireWildcard(_import3);

/* Menu
================================================================================ */
/**
 * The Menu component is used to build pop up menus, including subtitle and
 * captions selection menus.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Menu = (function (_Component) {
  function Menu() {
    _classCallCheck(this, Menu);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(Menu, _Component);

  _createClass(Menu, [{
    key: 'addItem',

    /**
     * Add a menu item to the menu
     * @param {Object|String} component Component or component type to add
     */
    value: function addItem(component) {
      this.addChild(component);
      component.on('click', Fn.bind(this, function () {
        this.unlockShowing();
      }));
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var contentElType = this.options().contentElType || 'ul';
      this.contentEl_ = Dom.createEl(contentElType, {
        className: 'vjs-menu-content'
      });
      var el = _get(Object.getPrototypeOf(Menu.prototype), 'createEl', this).call(this, 'div', {
        append: this.contentEl_,
        className: 'vjs-menu'
      });
      el.appendChild(this.contentEl_);

      // Prevent clicks from bubbling up. Needed for Menu Buttons,
      // where a click on the parent is significant
      Events.on(el, 'click', function (event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      });

      return el;
    }
  }]);

  return Menu;
})(_Component3['default']);

_Component3['default'].registerComponent('Menu', Menu);
exports['default'] = Menu;
module.exports = exports['default'];

},{"../component.js":45,"../utils/dom.js":105,"../utils/events.js":106,"../utils/fn.js":107}],86:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var navigator = _window2['default'].navigator;

/**
 * Global Player instance options, surfaced from Player.prototype.options_
 * options = Player.prototype.options_
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 */
exports['default'] = {
  // Default order of fallback technology
  techOrder: ['html5', 'flash'],
  // techOrder: ['flash','html5'],

  html5: {},
  flash: {},

  // defaultVolume: 0.85,
  defaultVolume: 0, // The freakin seaguls are driving me crazy!

  // default inactivity timeout
  inactivityTimeout: 2000,

  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  children: {
    mediaLoader: {},
    posterImage: {},
    textTrackDisplay: {},
    loadingSpinner: {},
    bigPlayButton: {},
    controlBar: {},
    errorDisplay: {},
    textTrackSettings: {}
  },

  language: _document2['default'].getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

  // locales and their language translations
  languages: {},

  // Default message to show when a video cannot be played.
  notSupportedMessage: 'No compatible source was found for this video.'
};
module.exports = exports['default'];

},{"global/document":1,"global/window":2}],87:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('./component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_import);

var _import2 = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_import2);

var _import3 = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_import3);

var _import4 = _dereq_('./utils/guid.js');

var Guid = _interopRequireWildcard(_import4);

var _import5 = _dereq_('./utils/browser.js');

var browser = _interopRequireWildcard(_import5);

var _log = _dereq_('./utils/log.js');

var _log2 = _interopRequireWildcard(_log);

var _toTitleCase = _dereq_('./utils/to-title-case.js');

var _toTitleCase2 = _interopRequireWildcard(_toTitleCase);

var _createTimeRange = _dereq_('./utils/time-ranges.js');

var _FullscreenApi = _dereq_('./fullscreen-api.js');

var _FullscreenApi2 = _interopRequireWildcard(_FullscreenApi);

var _MediaError = _dereq_('./media-error.js');

var _MediaError2 = _interopRequireWildcard(_MediaError);

var _Options = _dereq_('./options.js');

var _Options2 = _interopRequireWildcard(_Options);

var _safeParseTuple3 = _dereq_('safe-json-parse/tuple');

var _safeParseTuple4 = _interopRequireWildcard(_safeParseTuple3);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

var _mergeOptions = _dereq_('./utils/merge-options.js');

var _mergeOptions2 = _interopRequireWildcard(_mergeOptions);

// Include required child components

var _MediaLoader = _dereq_('./tech/loader.js');

var _MediaLoader2 = _interopRequireWildcard(_MediaLoader);

var _Poster = _dereq_('./poster-image.js');

var _Poster2 = _interopRequireWildcard(_Poster);

var _TextTrackDisplay = _dereq_('./tracks/text-track-display.js');

var _TextTrackDisplay2 = _interopRequireWildcard(_TextTrackDisplay);

var _LoadingSpinner = _dereq_('./loading-spinner.js');

var _LoadingSpinner2 = _interopRequireWildcard(_LoadingSpinner);

var _BigPlayButton = _dereq_('./big-play-button.js');

var _BigPlayButton2 = _interopRequireWildcard(_BigPlayButton);

var _controlBar = _dereq_('./control-bar/control-bar.js');

var _controlBar2 = _interopRequireWildcard(_controlBar);

var _ErrorDisplay = _dereq_('./error-display.js');

var _ErrorDisplay2 = _interopRequireWildcard(_ErrorDisplay);

var _TextTrackSettings = _dereq_('./tracks/text-track-settings.js');

var _TextTrackSettings2 = _interopRequireWildcard(_TextTrackSettings);

// Require html5 for disposing the original video tag

var _Html5 = _dereq_('./tech/html5.js');

var _Html52 = _interopRequireWildcard(_Html5);

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods are used to initialize a video.
 *
 * ```js
 * var myPlayer = videojs('example_video_1');
 * ```
 *
 * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
 *
 * ```html
 * <video id="example_video_1" data-setup='{}' controls>
 *   <source src="my-source.mp4" type="video/mp4">
 * </video>
 * ```
 *
 * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
 *
 * @class
 * @extends Component
 */

var Player = (function (_Component) {

  /**
   * player's constructor function
   *
   * @constructs
   * @method init
   * @param {Element} tag        The original video tag used for configuring options
   * @param {Object=} options    Player options
   * @param {Function=} ready    Ready callback function
   */

  function Player(tag, options, ready) {
    var _this = this;

    _classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + Guid.newGUID();

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = _assign2['default'](Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // Run base component initializing with new options
    _get(Object.getPrototypeOf(Player.prototype), 'constructor', this).call(this, null, options, ready);

    // if the global option object was accidentally blown away by
    // someone, bail early with an informative error
    if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {
      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
    }

    this.tag = tag; // Store the original tag used to set options

    // Store the tag attributes used to restore html5 element
    this.tagAttributes = tag && Dom.getElementAttributes(tag);

    // Update Current Language
    this.language_ = options.language || _Options2['default'].language;

    // Update Supported Languages
    this.languages_ = options.languages || _Options2['default'].languages;

    // Cache for video property values.
    this.cache_ = {};

    // Set poster
    this.poster_ = options.poster || '';

    // Set controls
    this.controls_ = !!options.controls;
    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    /**
    * Store the internal state of scrubbing
    * @private
    * @return {Boolean} True if the user is scrubbing
    */
    this.scrubbing_ = false;

    this.el_ = this.createEl();

    // Load plugins
    if (options.plugins) {
      (function () {
        var plugins = options.plugins;

        Object.getOwnPropertyNames(plugins).forEach(function (name) {
          this[name](plugins[name]);
        }, _this);
      })();
    }

    this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (this.controls()) {
      this.addClass('vjs-controls-enabled');
    } else {
      this.addClass('vjs-controls-disabled');
    }

    if (this.isAudio()) {
      this.addClass('vjs-audio');
    }

    if (this.flexNotSupported_()) {
      this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (browser.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // Make player easily findable by ID
    Player.players[this.id_] = this;

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    this.userActive_ = true;
    this.reportUserActivity();
    this.listenForUserActivity();

    this.on('fullscreenchange', this.handleFullscreenChange);
    this.on('stageclick', this.handleStageClick);
  }

  _inherits(Player, _Component);

  _createClass(Player, [{
    key: 'dispose',

    /**
     * Destroys the video player and does any necessary cleanup
     *
     *     myPlayer.dispose();
     *
     * This is especially helpful if you are dynamically adding and removing videos
     * to/from the DOM.
     */
    value: function dispose() {
      this.trigger('dispose');
      // prevent dispose from being called twice
      this.off('dispose');

      // Kill reference to this player
      Player.players[this.id_] = null;
      if (this.tag && this.tag.player) {
        this.tag.player = null;
      }
      if (this.el_ && this.el_.player) {
        this.el_.player = null;
      }

      if (this.tech) {
        this.tech.dispose();
      }

      _get(Object.getPrototypeOf(Player.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var el = this.el_ = _get(Object.getPrototypeOf(Player.prototype), 'createEl', this).call(this, 'div');
      var tag = this.tag;

      // Remove width/height attrs from tag so CSS can make it 100% width/height
      tag.removeAttribute('width');
      tag.removeAttribute('height');

      // Copy over all the attributes from the tag, including ID and class
      // ID will now reference player box, not the video tag
      var attrs = Dom.getElementAttributes(tag);

      Object.getOwnPropertyNames(attrs).forEach(function (attr) {
        // workaround so we don't totally break IE7
        // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
        if (attr === 'class') {
          el.className = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      });

      // Update tag id/class for use as HTML5 playback tech
      // Might think we should do this after embedding in container so .vjs-tech class
      // doesn't flash 100% width/height, but class only applies with .video-js parent
      tag.id += '_html5_api';
      tag.className = 'vjs-tech';

      // Make player findable on elements
      tag.player = el.player = this;
      // Default state of video is paused
      this.addClass('vjs-paused');

      // Add a style element in the player that we'll use to set the width/height
      // of the player in a way that's still overrideable by CSS, just like the
      // video element
      this.styleEl_ = _document2['default'].createElement('style');
      el.appendChild(this.styleEl_);

      // Pass in the width/height/aspectRatio options which will update the style el
      this.width(this.options_.width);
      this.height(this.options_.height);
      this.fluid(this.options_.fluid);
      this.aspectRatio(this.options_.aspectRatio);

      // insertFirst seems to cause the networkState to flicker from 3 to 2, so
      // keep track of the original for later so we can know if the source originally failed
      tag.initNetworkState_ = tag.networkState;

      // Wrap video tag in div (el/box) container
      if (tag.parentNode) {
        tag.parentNode.insertBefore(el, tag);
      }
      Dom.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.

      this.el_ = el;

      return el;
    }
  }, {
    key: 'width',
    value: function width(value) {
      return this.dimension('width', value);
    }
  }, {
    key: 'height',
    value: function height(value) {
      return this.dimension('height', value);
    }
  }, {
    key: 'dimension',
    value: (function (_dimension) {
      function dimension(_x, _x2) {
        return _dimension.apply(this, arguments);
      }

      dimension.toString = function () {
        return _dimension.toString();
      };

      return dimension;
    })(function (dimension, value) {
      var privDimension = dimension + '_';

      if (value === undefined) {
        return this[privDimension] || 0;
      }

      if (value === '') {
        // If an empty string is given, reset the dimension to be automatic
        this[privDimension] = undefined;
      } else {
        var parsedVal = parseFloat(value);

        if (isNaN(parsedVal)) {
          _log2['default'].error('Improper value "' + value + '" supplied for for ' + dimension);
          return this;
        }

        this[privDimension] = parsedVal;
      }

      this.updateStyleEl_();
      return this;
    })
  }, {
    key: 'fluid',
    value: function fluid(bool) {
      if (bool === undefined) {
        return !!this.fluid_;
      }

      this.fluid_ = !!bool;

      if (bool) {
        this.addClass('vjs-fluid');
      } else {
        this.removeClass('vjs-fluid');
      }
    }
  }, {
    key: 'aspectRatio',
    value: function aspectRatio(ratio) {
      if (ratio === undefined) {
        return this.aspectRatio_;
      }

      // Check for width:height format
      if (!/^\d+\:\d+$/.test(ratio)) {
        throw new Error('Improper value suplied for aspect ratio. The format should be width:height, for example 16:9.');
      }
      this.aspectRatio_ = ratio;

      // We're assuming if you set an aspect ratio you want fluid mode,
      // because in fixed mode you could calculate width and height yourself.
      this.fluid(true);

      this.updateStyleEl_();
    }
  }, {
    key: 'updateStyleEl_',
    value: function updateStyleEl_() {
      var width = undefined;
      var height = undefined;
      var aspectRatio = undefined;

      // The aspect ratio is either used directly or to calculate width and height.
      if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
        // Use any aspectRatio that's been specifically set
        aspectRatio = this.aspectRatio_;
      } else if (this.videoWidth()) {
        // Otherwise try to get the aspect ratio from the video metadata
        aspectRatio = this.videoWidth() + ':' + this.videoHeight();
      } else {
        // Or use a default. The video element's is 2:1, but 16:9 is more common.
        aspectRatio = '16:9';
      }

      // Get the ratio as a decimal we can use to calculate dimensions
      var ratioParts = aspectRatio.split(':');
      var ratioMultiplier = ratioParts[1] / ratioParts[0];

      if (this.width_ !== undefined) {
        // Use any width that's been specifically set
        width = this.width_;
      } else if (this.height_ !== undefined) {
        // Or calulate the width from the aspect ratio if a height has been set
        width = this.height_ / ratioMultiplier;
      } else {
        // Or use the video's metadata, or use the video el's default of 300
        width = this.videoWidth() || 300;
      }

      if (this.height_ !== undefined) {
        // Use any height that's been specifically set
        height = this.height_;
      } else {
        // Otherwise calculate the height from the ratio and the width
        height = width * ratioMultiplier;
      }

      var idClass = this.id() + '-dimensions';

      // Ensure the right class is still on the player for the style element
      this.addClass(idClass);

      // Create the width/height CSS
      var css = '.' + idClass + ' { width: ' + width + 'px; height: ' + height + 'px; }';
      // Add the aspect ratio CSS for when using a fluid layout
      css += '.' + idClass + '.vjs-fluid { padding-top: ' + ratioMultiplier * 100 + '%; }';

      // Update the style el
      if (this.styleEl_.styleSheet) {
        this.styleEl_.styleSheet.cssText = css;
      } else {
        this.styleEl_.innerHTML = css;
      }
    }
  }, {
    key: 'loadTech',

    /**
     * Load the Media Playback Technology (tech)
     * Load/Create an instance of playback technology including element and API methods
     * And append playback element in player div.
     */
    value: function loadTech(techName, source) {

      // Pause and remove current playback technology
      if (this.tech) {
        this.unloadTech();
      }

      // get rid of the HTML5 video tag as soon as we are using another tech
      if (techName !== 'Html5' && this.tag) {
        _Component3['default'].getComponent('Html5').disposeMediaElement(this.tag);
        this.tag.player = null;
        this.tag = null;
      }

      this.techName = techName;

      // Turn off API access because we're loading a new tech that might load asynchronously
      this.isReady_ = false;

      var techReady = Fn.bind(this, function () {
        this.triggerReady();
      });

      // Grab tech-specific options from player options and add source and parent element to use.
      var techOptions = _assign2['default']({
        source: source,
        playerId: this.id(),
        textTracks: this.textTracks_
      }, this.options_[techName.toLowerCase()]);

      if (this.tag) {
        techOptions.tag = this.tag;
      }

      if (source) {
        this.currentType_ = source.type;
        if (source.src === this.cache_.src && this.cache_.currentTime > 0) {
          techOptions.startTime = this.cache_.currentTime;
        }

        this.cache_.src = source.src;
      }

      // Initialize tech instance
      var techComponent = _Component3['default'].getComponent(techName);
      this.tech = new techComponent(techOptions);

      this.on(this.tech, 'ready', this.handleTechReady);
      this.on(this.tech, 'usenativecontrols', this.handleTechUseNativeControls);

      // Listen to every HTML5 events and trigger them back on the player for the plugins
      this.on(this.tech, 'loadstart', this.handleTechLoadStart);
      this.on(this.tech, 'waiting', this.handleTechWaiting);
      this.on(this.tech, 'canplay', this.handleTechCanPlay);
      this.on(this.tech, 'canplaythrough', this.handleTechCanPlayThrough);
      this.on(this.tech, 'playing', this.handleTechPlaying);
      this.on(this.tech, 'ended', this.handleTechEnded);
      this.on(this.tech, 'seeking', this.handleTechSeeking);
      this.on(this.tech, 'seeked', this.handleTechSeeked);
      this.on(this.tech, 'play', this.handleTechPlay);
      this.on(this.tech, 'firstplay', this.handleTechFirstPlay);
      this.on(this.tech, 'pause', this.handleTechPause);
      this.on(this.tech, 'progress', this.handleTechProgress);
      this.on(this.tech, 'durationchange', this.handleTechDurationChange);
      this.on(this.tech, 'fullscreenchange', this.handleTechFullscreenChange);
      this.on(this.tech, 'error', this.handleTechError);
      this.on(this.tech, 'suspend', this.handleTechSuspend);
      this.on(this.tech, 'abort', this.handleTechAbort);
      this.on(this.tech, 'emptied', this.handleTechEmptied);
      this.on(this.tech, 'stalled', this.handleTechStalled);
      this.on(this.tech, 'loadedmetadata', this.handleTechLoadedMetaData);
      this.on(this.tech, 'loadeddata', this.handleTechLoadedData);
      this.on(this.tech, 'timeupdate', this.handleTechTimeUpdate);
      this.on(this.tech, 'ratechange', this.handleTechRateChange);
      this.on(this.tech, 'volumechange', this.handleTechVolumeChange);
      this.on(this.tech, 'texttrackchange', this.onTextTrackChange);
      this.on(this.tech, 'loadedmetadata', this.updateStyleEl_);

      if (this.controls() && !this.usingNativeControls()) {
        this.addTechControlsListeners();
      }

      // Add the tech element in the DOM if it was not already there
      // Make sure to not insert the original video element if using Html5
      if (this.tech.el().parentNode !== this.el() && (techName !== 'Html5' || !this.tag)) {
        Dom.insertFirst(this.tech.el(), this.el());
      }

      // Get rid of the original video tag reference after the first tech is loaded
      if (this.tag) {
        this.tag.player = null;
        this.tag = null;
      }

      this.tech.ready(techReady);
    }
  }, {
    key: 'unloadTech',
    value: function unloadTech() {
      // Save the current text tracks so that we can reuse the same text tracks with the next tech
      this.textTracks_ = this.textTracks();

      this.isReady_ = false;

      this.tech.dispose();

      this.tech = false;
    }
  }, {
    key: 'addTechControlsListeners',
    value: function addTechControlsListeners() {
      // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
      // trigger mousedown/up.
      // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
      // Any touch events are set to block the mousedown event from happening
      this.on(this.tech, 'mousedown', this.handleTechClick);

      // If the controls were hidden we don't want that to change without a tap event
      // so we'll check if the controls were already showing before reporting user
      // activity
      this.on(this.tech, 'touchstart', this.handleTechTouchStart);
      this.on(this.tech, 'touchmove', this.handleTechTouchMove);
      this.on(this.tech, 'touchend', this.handleTechTouchEnd);

      // Turn on component tap events
      this.tech.emitTapEvents();

      // The tap listener needs to come after the touchend listener because the tap
      // listener cancels out any reportedUserActivity when setting userActive(false)
      this.on(this.tech, 'tap', this.handleTechTap);
    }
  }, {
    key: 'removeTechControlsListeners',

    /**
     * Remove the listeners used for click and tap controls. This is needed for
     * toggling to controls disabled, where a tap/touch should do nothing.
     */
    value: function removeTechControlsListeners() {
      // We don't want to just use `this.off()` because there might be other needed
      // listeners added by techs that extend this.
      this.off(this.tech, 'tap', this.handleTechTap);
      this.off(this.tech, 'touchstart', this.handleTechTouchStart);
      this.off(this.tech, 'touchmove', this.handleTechTouchMove);
      this.off(this.tech, 'touchend', this.handleTechTouchEnd);
      this.off(this.tech, 'mousedown', this.handleTechClick);
    }
  }, {
    key: 'handleTechReady',

    /**
     * Player waits for the tech to be ready
     * @private
     */
    value: function handleTechReady() {
      this.triggerReady();

      // Chrome and Safari both have issues with autoplay.
      // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
      // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
      // This fixes both issues. Need to wait for API, so it updates displays correctly
      if (this.tag && this.options_.autoplay && this.paused()) {
        delete this.tag.poster; // Chrome Fix. Fixed in Chrome v16.
        this.play();
      }
    }
  }, {
    key: 'handleTechUseNativeControls',

    /**
     * Fired when the native controls are used
     * @private
     */
    value: function handleTechUseNativeControls() {
      this.usingNativeControls(true);
    }
  }, {
    key: 'handleTechLoadStart',

    /**
     * Fired when the user agent begins looking for media data
     * @event loadstart
     */
    value: function handleTechLoadStart() {
      // TODO: Update to use `emptied` event instead. See #1277.

      this.removeClass('vjs-ended');

      // reset the error state
      this.error(null);

      // If it's already playing we want to trigger a firstplay event now.
      // The firstplay event relies on both the play and loadstart events
      // which can happen in any order for a new source
      if (!this.paused()) {
        this.trigger('loadstart');
        this.trigger('firstplay');
      } else {
        // reset the hasStarted state
        this.hasStarted(false);
        this.trigger('loadstart');
      }
    }
  }, {
    key: 'hasStarted',
    value: (function (_hasStarted) {
      function hasStarted(_x3) {
        return _hasStarted.apply(this, arguments);
      }

      hasStarted.toString = function () {
        return _hasStarted.toString();
      };

      return hasStarted;
    })(function (hasStarted) {
      if (hasStarted !== undefined) {
        // only update if this is a new value
        if (this.hasStarted_ !== hasStarted) {
          this.hasStarted_ = hasStarted;
          if (hasStarted) {
            this.addClass('vjs-has-started');
            // trigger the firstplay event if this newly has played
            this.trigger('firstplay');
          } else {
            this.removeClass('vjs-has-started');
          }
        }
        return this;
      }
      return !!this.hasStarted_;
    })
  }, {
    key: 'handleTechPlay',

    /**
     * Fired whenever the media begins or resumes playback
     * @event play
     */
    value: function handleTechPlay() {
      this.removeClass('vjs-ended');
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');

      // hide the poster when the user hits play
      // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play
      this.hasStarted(true);

      this.trigger('play');
    }
  }, {
    key: 'handleTechWaiting',

    /**
     * Fired whenever the media begins waiting
     * @event waiting
     */
    value: function handleTechWaiting() {
      this.addClass('vjs-waiting');
      this.trigger('waiting');
    }
  }, {
    key: 'handleTechCanPlay',

    /**
     * A handler for events that signal that waiting has ended
     * which is not consistent between browsers. See #1351
     * @event canplay
     */
    value: function handleTechCanPlay() {
      this.removeClass('vjs-waiting');
      this.trigger('canplay');
    }
  }, {
    key: 'handleTechCanPlayThrough',

    /**
     * A handler for events that signal that waiting has ended
     * which is not consistent between browsers. See #1351
     * @event canplaythrough
     */
    value: function handleTechCanPlayThrough() {
      this.removeClass('vjs-waiting');
      this.trigger('canplaythrough');
    }
  }, {
    key: 'handleTechPlaying',

    /**
     * A handler for events that signal that waiting has ended
     * which is not consistent between browsers. See #1351
     * @event playing
     */
    value: function handleTechPlaying() {
      this.removeClass('vjs-waiting');
      this.trigger('playing');
    }
  }, {
    key: 'handleTechSeeking',

    /**
     * Fired whenever the player is jumping to a new time
     * @event seeking
     */
    value: function handleTechSeeking() {
      this.addClass('vjs-seeking');
      this.trigger('seeking');
    }
  }, {
    key: 'handleTechSeeked',

    /**
     * Fired when the player has finished jumping to a new time
     * @event seeked
     */
    value: function handleTechSeeked() {
      this.removeClass('vjs-seeking');
      this.trigger('seeked');
    }
  }, {
    key: 'handleTechFirstPlay',

    /**
     * Fired the first time a video is played
     *
     * Not part of the HLS spec, and we're not sure if this is the best
     * implementation yet, so use sparingly. If you don't have a reason to
     * prevent playback, use `myPlayer.one('play');` instead.
     *
     * @event firstplay
     */
    value: function handleTechFirstPlay() {
      //If the first starttime attribute is specified
      //then we will start at the given offset in seconds
      if (this.options_.starttime) {
        this.currentTime(this.options_.starttime);
      }

      this.addClass('vjs-has-started');
      this.trigger('firstplay');
    }
  }, {
    key: 'handleTechPause',

    /**
     * Fired whenever the media has been paused
     * @event pause
     */
    value: function handleTechPause() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.trigger('pause');
    }
  }, {
    key: 'handleTechProgress',

    /**
     * Fired while the user agent is downloading media data
     * @event progress
     */
    value: function handleTechProgress() {
      this.trigger('progress');

      // Add custom event for when source is finished downloading.
      if (this.bufferedPercent() === 1) {
        this.trigger('loadedalldata');
      }
    }
  }, {
    key: 'handleTechEnded',

    /**
     * Fired when the end of the media resource is reached (currentTime == duration)
     * @event ended
     */
    value: function handleTechEnded() {
      this.addClass('vjs-ended');
      if (this.options_.loop) {
        this.currentTime(0);
        this.play();
      } else if (!this.paused()) {
        this.pause();
      }

      this.trigger('ended');
    }
  }, {
    key: 'handleTechDurationChange',

    /**
     * Fired when the duration of the media resource is first known or changed
     * @event durationchange
     */
    value: function handleTechDurationChange() {
      this.updateDuration();
      this.trigger('durationchange');
    }
  }, {
    key: 'handleTechClick',

    /**
     * Handle a click on the media element to play/pause
     */
    value: function handleTechClick(event) {
      // We're using mousedown to detect clicks thanks to Flash, but mousedown
      // will also be triggered with right-clicks, so we need to prevent that
      if (event.button !== 0) {
        return;
      } // When controls are disabled a click should not toggle playback because
      // the click is considered a control
      if (this.controls()) {
        if (this.paused()) {
          this.play();
        } else {
          this.pause();
        }
      }
    }
  }, {
    key: 'handleTechTap',

    /**
     * Handle a tap on the media element. It will toggle the user
     * activity state, which hides and shows the controls.
     */
    value: function handleTechTap() {
      this.userActive(!this.userActive());
    }
  }, {
    key: 'handleTechTouchStart',
    value: function handleTechTouchStart() {
      this.userWasActive = this.userActive();
    }
  }, {
    key: 'handleTechTouchMove',
    value: function handleTechTouchMove() {
      if (this.userWasActive) {
        this.reportUserActivity();
      }
    }
  }, {
    key: 'handleTechTouchEnd',
    value: function handleTechTouchEnd(event) {
      // Stop the mouse events from also happening
      event.preventDefault();
    }
  }, {
    key: 'updateDuration',

    /**
     * Update the duration of the player using the tech
     * @private
     */
    value: function updateDuration() {
      // Allows for caching value instead of asking player each time.
      // We need to get the techGet response and check for a value so we don't
      // accidentally cause the stack to blow up.
      var duration = this.techGet('duration');
      if (duration) {
        if (duration < 0) {
          duration = Infinity;
        }
        this.duration(duration);
        // Determine if the stream is live and propagate styles down to UI.
        if (duration === Infinity) {
          this.addClass('vjs-live');
        } else {
          this.removeClass('vjs-live');
        }
      }
    }
  }, {
    key: 'handleFullscreenChange',

    /**
     * Fired when the player switches in or out of fullscreen mode
     * @event fullscreenchange
     */
    value: function handleFullscreenChange() {
      if (this.isFullscreen()) {
        this.addClass('vjs-fullscreen');
      } else {
        this.removeClass('vjs-fullscreen');
      }
    }
  }, {
    key: 'handleStageClick',

    /**
     * native click events on the SWF aren't triggered on IE11, Win8.1RT
     * use stageclick events triggered from inside the SWF instead
     * @private
     */
    value: function handleStageClick() {
      this.reportUserActivity();
    }
  }, {
    key: 'handleTechFullscreenChange',
    value: function handleTechFullscreenChange() {
      this.trigger('fullscreenchange');
    }
  }, {
    key: 'handleTechError',

    /**
     * Fires when an error occurred during the loading of an audio/video
     * @event error
     */
    value: function handleTechError() {
      this.error(this.tech.error().code);
    }
  }, {
    key: 'handleTechSuspend',

    /**
     * Fires when the browser is intentionally not getting media data
     * @event suspend
     */
    value: function handleTechSuspend() {
      this.trigger('suspend');
    }
  }, {
    key: 'handleTechAbort',

    /**
     * Fires when the loading of an audio/video is aborted
     * @event abort
     */
    value: function handleTechAbort() {
      this.trigger('abort');
    }
  }, {
    key: 'handleTechEmptied',

    /**
     * Fires when the current playlist is empty
     * @event emptied
     */
    value: function handleTechEmptied() {
      this.trigger('emptied');
    }
  }, {
    key: 'handleTechStalled',

    /**
     * Fires when the browser is trying to get media data, but data is not available
     * @event stalled
     */
    value: function handleTechStalled() {
      this.trigger('stalled');
    }
  }, {
    key: 'handleTechLoadedMetaData',

    /**
     * Fires when the browser has loaded meta data for the audio/video
     * @event loadedmetadata
     */
    value: function handleTechLoadedMetaData() {
      this.trigger('loadedmetadata');
    }
  }, {
    key: 'handleTechLoadedData',

    /**
     * Fires when the browser has loaded the current frame of the audio/video
     * @event loaddata
     */
    value: function handleTechLoadedData() {
      this.trigger('loadeddata');
    }
  }, {
    key: 'handleTechTimeUpdate',

    /**
     * Fires when the current playback position has changed
     * @event timeupdate
     */
    value: function handleTechTimeUpdate() {
      this.trigger('timeupdate');
    }
  }, {
    key: 'handleTechRateChange',

    /**
     * Fires when the playing speed of the audio/video is changed
     * @event ratechange
     */
    value: function handleTechRateChange() {
      this.trigger('ratechange');
    }
  }, {
    key: 'handleTechVolumeChange',

    /**
     * Fires when the volume has been changed
     * @event volumechange
     */
    value: function handleTechVolumeChange() {
      this.trigger('volumechange');
    }
  }, {
    key: 'onTextTrackChange',

    /**
     * Fires when the text track has been changed
     * @event texttrackchange
     */
    value: function onTextTrackChange() {
      this.trigger('texttrackchange');
    }
  }, {
    key: 'getCache',

    /**
     * Object for cached values.
     */
    value: function getCache() {
      return this.cache_;
    }
  }, {
    key: 'techCall',

    // Pass values to the playback tech
    value: function techCall(method, arg) {
      // If it's not ready yet, call method when it is
      if (this.tech && !this.tech.isReady_) {
        this.tech.ready(function () {
          this[method](arg);
        });

        // Otherwise call method now
      } else {
        try {
          this.tech[method](arg);
        } catch (e) {
          _log2['default'](e);
          throw e;
        }
      }
    }
  }, {
    key: 'techGet',

    // Get calls can't wait for the tech, and sometimes don't need to.
    value: function techGet(method) {
      if (this.tech && this.tech.isReady_) {

        // Flash likes to die and reload when you hide or reposition it.
        // In these cases the object methods go away and we get errors.
        // When that happens we'll catch the errors and inform tech that it's not ready any more.
        try {
          return this.tech[method]();
        } catch (e) {
          // When building additional tech libs, an expected method may not be defined yet
          if (this.tech[method] === undefined) {
            _log2['default']('Video.js: ' + method + ' method not defined for ' + this.techName + ' playback technology.', e);
          } else {
            // When a method isn't available on the object it throws a TypeError
            if (e.name === 'TypeError') {
              _log2['default']('Video.js: ' + method + ' unavailable on ' + this.techName + ' playback technology element.', e);
              this.tech.isReady_ = false;
            } else {
              _log2['default'](e);
            }
          }
          throw e;
        }
      }

      return;
    }
  }, {
    key: 'play',

    /**
     * start media playback
     *
     *     myPlayer.play();
     *
     * @return {Player} self
     */
    value: function play() {
      this.techCall('play');
      return this;
    }
  }, {
    key: 'pause',

    /**
     * Pause the video playback
     *
     *     myPlayer.pause();
     *
     * @return {Player} self
     */
    value: function pause() {
      this.techCall('pause');
      return this;
    }
  }, {
    key: 'paused',

    /**
     * Check if the player is paused
     *
     *     var isPaused = myPlayer.paused();
     *     var isPlaying = !myPlayer.paused();
     *
     * @return {Boolean} false if the media is currently playing, or true otherwise
     */
    value: function paused() {
      // The initial state of paused should be true (in Safari it's actually false)
      return this.techGet('paused') === false ? false : true;
    }
  }, {
    key: 'scrubbing',

    /**
    * Returns whether or not the user is "scrubbing". Scrubbing is when the user
    * has clicked the progress bar handle and is dragging it along the progress bar.
    * @param  {Boolean} isScrubbing   True/false the user is scrubbing
    * @return {Boolean}               The scrubbing status when getting
    * @return {Object}                The player when setting
    */
    value: function scrubbing(isScrubbing) {
      if (isScrubbing !== undefined) {
        this.scrubbing_ = !!isScrubbing;

        if (isScrubbing) {
          this.addClass('vjs-scrubbing');
        } else {
          this.removeClass('vjs-scrubbing');
        }

        return this;
      }

      return this.scrubbing_;
    }
  }, {
    key: 'currentTime',

    /**
     * Get or set the current time (in seconds)
     *
     *     // get
     *     var whereYouAt = myPlayer.currentTime();
     *
     *     // set
     *     myPlayer.currentTime(120); // 2 minutes into the video
     *
     * @param  {Number|String=} seconds The time to seek to
     * @return {Number}        The time in seconds, when not setting
     * @return {Player}    self, when the current time is set
     */
    value: function currentTime(seconds) {
      if (seconds !== undefined) {

        this.techCall('setCurrentTime', seconds);

        return this;
      }

      // cache last currentTime and return. default to 0 seconds
      //
      // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
      // currentTime when scrubbing, but may not provide much performance benefit afterall.
      // Should be tested. Also something has to read the actual current time or the cache will
      // never get updated.
      return this.cache_.currentTime = this.techGet('currentTime') || 0;
    }
  }, {
    key: 'duration',

    /**
     * Get the length in time of the video in seconds
     *
     *     var lengthOfVideo = myPlayer.duration();
     *
     * **NOTE**: The video must have started loading before the duration can be
     * known, and in the case of Flash, may not be known until the video starts
     * playing.
     *
     * @return {Number} The duration of the video in seconds
     */
    value: function duration(seconds) {
      if (seconds !== undefined) {

        // cache the last set value for optimized scrubbing (esp. Flash)
        this.cache_.duration = parseFloat(seconds);

        return this;
      }

      if (this.cache_.duration === undefined) {
        this.updateDuration();
      }

      return this.cache_.duration || 0;
    }
  }, {
    key: 'remainingTime',

    /**
     * Calculates how much time is left.
     *
     *     var timeLeft = myPlayer.remainingTime();
     *
     * Not a native video element function, but useful
     * @return {Number} The time remaining in seconds
     */
    value: function remainingTime() {
      return this.duration() - this.currentTime();
    }
  }, {
    key: 'buffered',

    // http://dev.w3.org/html5/spec/video.html#dom-media-buffered
    // Buffered returns a timerange object.
    // Kind of like an array of portions of the video that have been downloaded.

    /**
     * Get a TimeRange object with the times of the video that have been downloaded
     *
     * If you just want the percent of the video that's been downloaded,
     * use bufferedPercent.
     *
     *     // Number of different ranges of time have been buffered. Usually 1.
     *     numberOfRanges = bufferedTimeRange.length,
     *
     *     // Time in seconds when the first range starts. Usually 0.
     *     firstRangeStart = bufferedTimeRange.start(0),
     *
     *     // Time in seconds when the first range ends
     *     firstRangeEnd = bufferedTimeRange.end(0),
     *
     *     // Length in seconds of the first time range
     *     firstRangeLength = firstRangeEnd - firstRangeStart;
     *
     * @return {Object} A mock TimeRange object (following HTML spec)
     */
    value: (function (_buffered) {
      function buffered() {
        return _buffered.apply(this, arguments);
      }

      buffered.toString = function () {
        return _buffered.toString();
      };

      return buffered;
    })(function () {
      var buffered = this.techGet('buffered');

      if (!buffered || !buffered.length) {
        buffered = _createTimeRange.createTimeRange(0, 0);
      }

      return buffered;
    })
  }, {
    key: 'bufferedPercent',

    /**
     * Get the percent (as a decimal) of the video that's been downloaded
     *
     *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
     *
     * 0 means none, 1 means all.
     * (This method isn't in the HTML5 spec, but it's very convenient)
     *
     * @return {Number} A decimal between 0 and 1 representing the percent
     */
    value: function bufferedPercent() {
      var duration = this.duration(),
          buffered = this.buffered(),
          bufferedDuration = 0,
          start,
          end;

      if (!duration) {
        return 0;
      }

      for (var i = 0; i < buffered.length; i++) {
        start = buffered.start(i);
        end = buffered.end(i);

        // buffered end can be bigger than duration by a very small fraction
        if (end > duration) {
          end = duration;
        }

        bufferedDuration += end - start;
      }

      return bufferedDuration / duration;
    }
  }, {
    key: 'bufferedEnd',

    /**
     * Get the ending time of the last buffered time range
     *
     * This is used in the progress bar to encapsulate all time ranges.
     * @return {Number} The end of the last buffered time range
     */
    value: function bufferedEnd() {
      var buffered = this.buffered(),
          duration = this.duration(),
          end = buffered.end(buffered.length - 1);

      if (end > duration) {
        end = duration;
      }

      return end;
    }
  }, {
    key: 'volume',

    /**
     * Get or set the current volume of the media
     *
     *     // get
     *     var howLoudIsIt = myPlayer.volume();
     *
     *     // set
     *     myPlayer.volume(0.5); // Set volume to half
     *
     * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
     *
     * @param  {Number} percentAsDecimal The new volume as a decimal percent
     * @return {Number}                  The current volume, when getting
     * @return {Player}              self, when setting
     */
    value: function volume(percentAsDecimal) {
      var vol = undefined;

      if (percentAsDecimal !== undefined) {
        vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
        this.cache_.volume = vol;
        this.techCall('setVolume', vol);

        return this;
      }

      // Default to 1 when returning current volume.
      vol = parseFloat(this.techGet('volume'));
      return isNaN(vol) ? 1 : vol;
    }
  }, {
    key: 'muted',

    /**
     * Get the current muted state, or turn mute on or off
     *
     *     // get
     *     var isVolumeMuted = myPlayer.muted();
     *
     *     // set
     *     myPlayer.muted(true); // mute the volume
     *
     * @param  {Boolean=} muted True to mute, false to unmute
     * @return {Boolean} True if mute is on, false if not, when getting
     * @return {Player} self, when setting mute
     */
    value: (function (_muted) {
      function muted(_x4) {
        return _muted.apply(this, arguments);
      }

      muted.toString = function () {
        return _muted.toString();
      };

      return muted;
    })(function (muted) {
      if (muted !== undefined) {
        this.techCall('setMuted', muted);
        return this;
      }
      return this.techGet('muted') || false; // Default to false
    })
  }, {
    key: 'supportsFullScreen',

    // Check if current tech can support native fullscreen
    // (e.g. with built in controls like iOS, so not our flash swf)
    value: function supportsFullScreen() {
      return this.techGet('supportsFullScreen') || false;
    }
  }, {
    key: 'isFullscreen',

    /**
     * Check if the player is in fullscreen mode
     *
     *     // get
     *     var fullscreenOrNot = myPlayer.isFullscreen();
     *
     *     // set
     *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
     *
     * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
     * property and instead document.fullscreenElement is used. But isFullscreen is
     * still a valuable property for internal player workings.
     *
     * @param  {Boolean=} isFS Update the player's fullscreen state
     * @return {Boolean} true if fullscreen, false if not
     * @return {Player} self, when setting
     */
    value: function isFullscreen(isFS) {
      if (isFS !== undefined) {
        this.isFullscreen_ = !!isFS;
        return this;
      }
      return !!this.isFullscreen_;
    }
  }, {
    key: 'isFullScreen',

    /**
     * Old naming for isFullscreen()
     * @deprecated for lowercase 's' version
     */
    value: function isFullScreen(isFS) {
      _log2['default'].warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
      return this.isFullscreen(isFS);
    }
  }, {
    key: 'requestFullscreen',

    /**
     * Increase the size of the video to full screen
     *
     *     myPlayer.requestFullscreen();
     *
     * In some browsers, full screen is not supported natively, so it enters
     * "full window mode", where the video fills the browser window.
     * In browsers and devices that support native full screen, sometimes the
     * browser's default controls will be shown, and not the Video.js custom skin.
     * This includes most mobile devices (iOS, Android) and older versions of
     * Safari.
     *
     * @return {Player} self
     */
    value: function requestFullscreen() {
      var fsApi = _FullscreenApi2['default'];

      this.isFullscreen(true);

      if (fsApi) {
        // the browser supports going fullscreen at the element level so we can
        // take the controls fullscreen as well as the video

        // Trigger fullscreenchange event after change
        // We have to specifically add this each time, and remove
        // when canceling fullscreen. Otherwise if there's multiple
        // players on a page, they would all be reacting to the same fullscreen
        // events
        Events.on(_document2['default'], fsApi.fullscreenchange, Fn.bind(this, function documentFullscreenChange(e) {
          this.isFullscreen(_document2['default'][fsApi.fullscreenElement]);

          // If cancelling fullscreen, remove event listener.
          if (this.isFullscreen() === false) {
            Events.off(_document2['default'], fsApi.fullscreenchange, documentFullscreenChange);
          }

          this.trigger('fullscreenchange');
        }));

        this.el_[fsApi.requestFullscreen]();
      } else if (this.tech.supportsFullScreen()) {
        // we can't take the video.js controls fullscreen but we can go fullscreen
        // with native controls
        this.techCall('enterFullScreen');
      } else {
        // fullscreen isn't supported so we'll just stretch the video element to
        // fill the viewport
        this.enterFullWindow();
        this.trigger('fullscreenchange');
      }

      return this;
    }
  }, {
    key: 'requestFullScreen',

    /**
     * Old naming for requestFullscreen
     * @deprecated for lower case 's' version
     */
    value: function requestFullScreen() {
      _log2['default'].warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
      return this.requestFullscreen();
    }
  }, {
    key: 'exitFullscreen',

    /**
     * Return the video to its normal size after having been in full screen mode
     *
     *     myPlayer.exitFullscreen();
     *
     * @return {Player} self
     */
    value: function exitFullscreen() {
      var fsApi = _FullscreenApi2['default'];
      this.isFullscreen(false);

      // Check for browser element fullscreen support
      if (fsApi) {
        _document2['default'][fsApi.exitFullscreen]();
      } else if (this.tech.supportsFullScreen()) {
        this.techCall('exitFullScreen');
      } else {
        this.exitFullWindow();
        this.trigger('fullscreenchange');
      }

      return this;
    }
  }, {
    key: 'cancelFullScreen',

    /**
     * Old naming for exitFullscreen
     * @deprecated for exitFullscreen
     */
    value: function cancelFullScreen() {
      _log2['default'].warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
      return this.exitFullscreen();
    }
  }, {
    key: 'enterFullWindow',

    // When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
    value: function enterFullWindow() {
      this.isFullWindow = true;

      // Storing original doc overflow value to return to when fullscreen is off
      this.docOrigOverflow = _document2['default'].documentElement.style.overflow;

      // Add listener for esc key to exit fullscreen
      Events.on(_document2['default'], 'keydown', Fn.bind(this, this.fullWindowOnEscKey));

      // Hide any scroll bars
      _document2['default'].documentElement.style.overflow = 'hidden';

      // Apply fullscreen styles
      Dom.addClass(_document2['default'].body, 'vjs-full-window');

      this.trigger('enterFullWindow');
    }
  }, {
    key: 'fullWindowOnEscKey',
    value: function fullWindowOnEscKey(event) {
      if (event.keyCode === 27) {
        if (this.isFullscreen() === true) {
          this.exitFullscreen();
        } else {
          this.exitFullWindow();
        }
      }
    }
  }, {
    key: 'exitFullWindow',
    value: function exitFullWindow() {
      this.isFullWindow = false;
      Events.off(_document2['default'], 'keydown', this.fullWindowOnEscKey);

      // Unhide scroll bars.
      _document2['default'].documentElement.style.overflow = this.docOrigOverflow;

      // Remove fullscreen styles
      Dom.removeClass(_document2['default'].body, 'vjs-full-window');

      // Resize the box, controller, and poster to original sizes
      // this.positionAll();
      this.trigger('exitFullWindow');
    }
  }, {
    key: 'selectSource',
    value: function selectSource(sources) {
      // Loop through each playback technology in the options order
      for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
        var techName = _toTitleCase2['default'](j[i]);
        var tech = _Component3['default'].getComponent(techName);

        // Check if the current tech is defined before continuing
        if (!tech) {
          _log2['default'].error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
          continue;
        }

        // Check if the browser supports this technology
        if (tech.isSupported()) {
          // Loop through each source object
          for (var a = 0, b = sources; a < b.length; a++) {
            var source = b[a];

            // Check if source can be played with this technology
            if (tech.canPlaySource(source)) {
              return { source: source, tech: techName };
            }
          }
        }
      }

      return false;
    }
  }, {
    key: 'src',

    /**
     * The source function updates the video source
     *
     * There are three types of variables you can pass as the argument.
     *
     * **URL String**: A URL to the the video file. Use this method if you are sure
     * the current playback technology (HTML5/Flash) can support the source you
     * provide. Currently only MP4 files can be used in both HTML5 and Flash.
     *
     *     myPlayer.src("http://www.example.com/path/to/video.mp4");
     *
     * **Source Object (or element):** A javascript object containing information
     * about the source file. Use this method if you want the player to determine if
     * it can support the file using the type information.
     *
     *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
     *
     * **Array of Source Objects:** To provide multiple versions of the source so
     * that it can be played using HTML5 across browsers you can use an array of
     * source objects. Video.js will detect which version is supported and load that
     * file.
     *
     *     myPlayer.src([
     *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
     *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
     *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
     *     ]);
     *
     * @param  {String|Object|Array=} source The source URL, object, or array of sources
     * @return {String} The current video source when getting
     * @return {String} The player when setting
     */
    value: function src() {
      var source = arguments[0] === undefined ? this.techGet('src') : arguments[0];

      var currentTech = _Component3['default'].getComponent(this.techName);

      // case: Array of source objects to choose from and pick the best to play
      if (Array.isArray(source)) {
        this.sourceList_(source);

        // case: URL String (http://myvideo...)
      } else if (typeof source === 'string') {
        // create a source object from the string
        this.src({ src: source });

        // case: Source object { src: '', type: '' ... }
      } else if (source instanceof Object) {
        // check if the source has a type and the loaded tech cannot play the source
        // if there's no type we'll just try the current tech
        if (source.type && !currentTech.canPlaySource(source)) {
          // create a source list with the current source and send through
          // the tech loop to check for a compatible technology
          this.sourceList_([source]);
        } else {
          this.cache_.src = source.src;
          this.currentType_ = source.type || '';

          // wait until the tech is ready to set the source
          this.ready(function () {

            // The setSource tech method was added with source handlers
            // so older techs won't support it
            // We need to check the direct prototype for the case where subclasses
            // of the tech do not support source handlers
            if (currentTech.prototype.hasOwnProperty('setSource')) {
              this.techCall('setSource', source);
            } else {
              this.techCall('src', source.src);
            }

            if (this.options_.preload === 'auto') {
              this.load();
            }

            if (this.options_.autoplay) {
              this.play();
            }
          });
        }
      }

      return this;
    }
  }, {
    key: 'sourceList_',

    /**
     * Handle an array of source objects
     * @param  {[type]} sources Array of source objects
     * @private
     */
    value: function sourceList_(sources) {
      var sourceTech = this.selectSource(sources);

      if (sourceTech) {
        if (sourceTech.tech === this.techName) {
          // if this technology is already loaded, set the source
          this.src(sourceTech.source);
        } else {
          // load this technology with the chosen source
          this.loadTech(sourceTech.tech, sourceTech.source);
        }
      } else {
        // We need to wrap this in a timeout to give folks a chance to add error event handlers
        this.setTimeout(function () {
          this.error({ code: 4, message: this.localize(this.options().notSupportedMessage) });
        }, 0);

        // we could not find an appropriate tech, but let's still notify the delegate that this is it
        // this needs a better comment about why this is needed
        this.triggerReady();
      }
    }
  }, {
    key: 'load',

    /**
     * Begin loading the src data.
     * @return {Player} Returns the player
     */
    value: function load() {
      this.techCall('load');
      return this;
    }
  }, {
    key: 'currentSrc',

    /**
     * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
     * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
     * @return {String} The current source
     */
    value: function currentSrc() {
      return this.techGet('currentSrc') || this.cache_.src || '';
    }
  }, {
    key: 'currentType',

    /**
     * Get the current source type e.g. video/mp4
     * This can allow you rebuild the current source object so that you could load the same
     * source and tech later
     * @return {String} The source MIME type
     */
    value: function currentType() {
      return this.currentType_ || '';
    }
  }, {
    key: 'preload',

    /**
     * Get or set the preload attribute.
     * @return {String} The preload attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function preload(value) {
      if (value !== undefined) {
        this.techCall('setPreload', value);
        this.options_.preload = value;
        return this;
      }
      return this.techGet('preload');
    }
  }, {
    key: 'autoplay',

    /**
     * Get or set the autoplay attribute.
     * @return {String} The autoplay attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function autoplay(value) {
      if (value !== undefined) {
        this.techCall('setAutoplay', value);
        this.options_.autoplay = value;
        return this;
      }
      return this.techGet('autoplay', value);
    }
  }, {
    key: 'loop',

    /**
     * Get or set the loop attribute on the video element.
     * @return {String} The loop attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function loop(value) {
      if (value !== undefined) {
        this.techCall('setLoop', value);
        this.options_.loop = value;
        return this;
      }
      return this.techGet('loop');
    }
  }, {
    key: 'poster',

    /**
     * get or set the poster image source url
     *
     * ##### EXAMPLE:
     *
     *     // getting
     *     var currentPoster = myPlayer.poster();
     *
     *     // setting
     *     myPlayer.poster('http://example.com/myImage.jpg');
     *
     * @param  {String=} [src] Poster image source URL
     * @return {String} poster URL when getting
     * @return {Player} self when setting
     */
    value: function poster(src) {
      if (src === undefined) {
        return this.poster_;
      }

      // The correct way to remove a poster is to set as an empty string
      // other falsey values will throw errors
      if (!src) {
        src = '';
      }

      // update the internal poster variable
      this.poster_ = src;

      // update the tech's poster
      this.techCall('setPoster', src);

      // alert components that the poster has been set
      this.trigger('posterchange');

      return this;
    }
  }, {
    key: 'controls',

    /**
     * Get or set whether or not the controls are showing.
     * @param  {Boolean} controls Set controls to showing or not
     * @return {Boolean}    Controls are showing
     */
    value: function controls(bool) {
      if (bool !== undefined) {
        bool = !!bool; // force boolean
        // Don't trigger a change event unless it actually changed
        if (this.controls_ !== bool) {
          this.controls_ = bool;

          if (this.usingNativeControls()) {
            this.techCall('setControls', bool);
          }

          if (bool) {
            this.removeClass('vjs-controls-disabled');
            this.addClass('vjs-controls-enabled');
            this.trigger('controlsenabled');

            if (!this.usingNativeControls()) {
              this.addTechControlsListeners();
            }
          } else {
            this.removeClass('vjs-controls-enabled');
            this.addClass('vjs-controls-disabled');
            this.trigger('controlsdisabled');

            if (!this.usingNativeControls()) {
              this.removeTechControlsListeners();
            }
          }
        }
        return this;
      }
      return !!this.controls_;
    }
  }, {
    key: 'usingNativeControls',

    /**
     * Toggle native controls on/off. Native controls are the controls built into
     * devices (e.g. default iPhone controls), Flash, or other techs
     * (e.g. Vimeo Controls)
     *
     * **This should only be set by the current tech, because only the tech knows
     * if it can support native controls**
     *
     * @param  {Boolean} bool    True signals that native controls are on
     * @return {Player}      Returns the player
     * @private
     */
    value: function usingNativeControls(bool) {
      if (bool !== undefined) {
        bool = !!bool; // force boolean
        // Don't trigger a change event unless it actually changed
        if (this.usingNativeControls_ !== bool) {
          this.usingNativeControls_ = bool;
          if (bool) {
            this.addClass('vjs-using-native-controls');

            /**
             * player is using the native device controls
             *
             * @event usingnativecontrols
             * @memberof Player
             * @instance
             * @private
             */
            this.trigger('usingnativecontrols');
          } else {
            this.removeClass('vjs-using-native-controls');

            /**
             * player is using the custom HTML controls
             *
             * @event usingcustomcontrols
             * @memberof Player
             * @instance
             * @private
             */
            this.trigger('usingcustomcontrols');
          }
        }
        return this;
      }
      return !!this.usingNativeControls_;
    }
  }, {
    key: 'error',

    /**
     * Set or get the current MediaError
     * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
     * @return {MediaError|null}     when getting
     * @return {Player}              when setting
     */
    value: function error(err) {
      if (err === undefined) {
        return this.error_ || null;
      }

      // restoring to default
      if (err === null) {
        this.error_ = err;
        this.removeClass('vjs-error');
        return this;
      }

      // error instance
      if (err instanceof _MediaError2['default']) {
        this.error_ = err;
      } else {
        this.error_ = new _MediaError2['default'](err);
      }

      // fire an error event on the player
      this.trigger('error');

      // add the vjs-error classname to the player
      this.addClass('vjs-error');

      // log the name of the error type and any message
      // ie8 just logs "[object object]" if you just log the error object
      _log2['default'].error('(CODE:' + this.error_.code + ' ' + _MediaError2['default'].errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

      return this;
    }
  }, {
    key: 'ended',

    /**
     * Returns whether or not the player is in the "ended" state.
     * @return {Boolean} True if the player is in the ended state, false if not.
     */
    value: function ended() {
      return this.techGet('ended');
    }
  }, {
    key: 'seeking',

    /**
     * Returns whether or not the player is in the "seeking" state.
     * @return {Boolean} True if the player is in the seeking state, false if not.
     */
    value: function seeking() {
      return this.techGet('seeking');
    }
  }, {
    key: 'reportUserActivity',
    value: function reportUserActivity(event) {
      this.userActivity_ = true;
    }
  }, {
    key: 'userActive',
    value: function userActive(bool) {
      if (bool !== undefined) {
        bool = !!bool;
        if (bool !== this.userActive_) {
          this.userActive_ = bool;
          if (bool) {
            // If the user was inactive and is now active we want to reset the
            // inactivity timer
            this.userActivity_ = true;
            this.removeClass('vjs-user-inactive');
            this.addClass('vjs-user-active');
            this.trigger('useractive');
          } else {
            // We're switching the state to inactive manually, so erase any other
            // activity
            this.userActivity_ = false;

            // Chrome/Safari/IE have bugs where when you change the cursor it can
            // trigger a mousemove event. This causes an issue when you're hiding
            // the cursor when the user is inactive, and a mousemove signals user
            // activity. Making it impossible to go into inactive mode. Specifically
            // this happens in fullscreen when we really need to hide the cursor.
            //
            // When this gets resolved in ALL browsers it can be removed
            // https://code.google.com/p/chromium/issues/detail?id=103041
            if (this.tech) {
              this.tech.one('mousemove', function (e) {
                e.stopPropagation();
                e.preventDefault();
              });
            }

            this.removeClass('vjs-user-active');
            this.addClass('vjs-user-inactive');
            this.trigger('userinactive');
          }
        }
        return this;
      }
      return this.userActive_;
    }
  }, {
    key: 'listenForUserActivity',
    value: function listenForUserActivity() {
      var mouseInProgress = undefined,
          lastMoveX = undefined,
          lastMoveY = undefined;

      var handleActivity = Fn.bind(this, this.reportUserActivity);

      var handleMouseMove = function handleMouseMove(e) {
        // #1068 - Prevent mousemove spamming
        // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
        if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
          lastMoveX = e.screenX;
          lastMoveY = e.screenY;
          handleActivity();
        }
      };

      var handleMouseDown = function handleMouseDown() {
        handleActivity();
        // For as long as the they are touching the device or have their mouse down,
        // we consider them active even if they're not moving their finger or mouse.
        // So we want to continue to update that they are active
        this.clearInterval(mouseInProgress);
        // Setting userActivity=true now and setting the interval to the same time
        // as the activityCheck interval (250) should ensure we never miss the
        // next activityCheck
        mouseInProgress = this.setInterval(handleActivity, 250);
      };

      var handleMouseUp = function handleMouseUp(event) {
        handleActivity();
        // Stop the interval that maintains activity if the mouse/touch is down
        this.clearInterval(mouseInProgress);
      };

      // Any mouse movement will be considered user activity
      this.on('mousedown', handleMouseDown);
      this.on('mousemove', handleMouseMove);
      this.on('mouseup', handleMouseUp);

      // Listen for keyboard navigation
      // Shouldn't need to use inProgress interval because of key repeat
      this.on('keydown', handleActivity);
      this.on('keyup', handleActivity);

      // Run an interval every 250 milliseconds instead of stuffing everything into
      // the mousemove/touchmove function itself, to prevent performance degradation.
      // `this.reportUserActivity` simply sets this.userActivity_ to true, which
      // then gets picked up by this loop
      // http://ejohn.org/blog/learning-from-twitter/
      var activityCheck = this.setInterval(function () {
        var inactivityTimeout = undefined;

        // Check to see if mouse/touch activity has happened
        if (this.userActivity_) {
          // Reset the activity tracker
          this.userActivity_ = false;

          // If the user state was inactive, set the state to active
          this.userActive(true);

          // Clear any existing inactivity timeout to start the timer over
          this.clearTimeout(inactivityTimeout);

          var timeout = this.options().inactivityTimeout;
          if (timeout > 0) {
            // In <timeout> milliseconds, if no more activity has occurred the
            // user will be considered inactive
            inactivityTimeout = this.setTimeout(function () {
              // Protect against the case where the inactivityTimeout can trigger just
              // before the next user activity is picked up by the activityCheck loop
              // causing a flicker
              if (!this.userActivity_) {
                this.userActive(false);
              }
            }, timeout);
          }
        }
      }, 250);
    }
  }, {
    key: 'playbackRate',

    /**
     * Gets or sets the current playback rate.  A playback rate of
     * 1.0 represents normal speed and 0.5 would indicate half-speed
     * playback, for instance.
     * @param  {Number} rate    New playback rate to set.
     * @return {Number}         Returns the new playback rate when setting
     * @return {Number}         Returns the current playback rate when getting
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
     */
    value: function playbackRate(rate) {
      if (rate !== undefined) {
        this.techCall('setPlaybackRate', rate);
        return this;
      }

      if (this.tech && this.tech.featuresPlaybackRate) {
        return this.techGet('playbackRate');
      } else {
        return 1;
      }
    }
  }, {
    key: 'isAudio',

    /**
     * Gets or sets the audio flag
     *
     * @param  {Boolean} bool    True signals that this is an audio player.
     * @return {Boolean}         Returns true if player is audio, false if not when getting
     * @return {Player}      Returns the player if setting
     * @private
     */
    value: function isAudio(bool) {
      if (bool !== undefined) {
        this.isAudio_ = !!bool;
        return this;
      }

      return !!this.isAudio_;
    }
  }, {
    key: 'networkState',

    /**
     * Returns the current state of network activity for the element, from
     * the codes in the list below.
     * - NETWORK_EMPTY (numeric value 0)
     *   The element has not yet been initialised. All attributes are in
     *   their initial states.
     * - NETWORK_IDLE (numeric value 1)
     *   The element's resource selection algorithm is active and has
     *   selected a resource, but it is not actually using the network at
     *   this time.
     * - NETWORK_LOADING (numeric value 2)
     *   The user agent is actively trying to download data.
     * - NETWORK_NO_SOURCE (numeric value 3)
     *   The element's resource selection algorithm is active, but it has
     *   not yet found a resource to use.
     * @return {Number} the current network activity state
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
     */
    value: function networkState() {
      return this.techGet('networkState');
    }
  }, {
    key: 'readyState',

    /**
     * Returns a value that expresses the current state of the element
     * with respect to rendering the current playback position, from the
     * codes in the list below.
     * - HAVE_NOTHING (numeric value 0)
     *   No information regarding the media resource is available.
     * - HAVE_METADATA (numeric value 1)
     *   Enough of the resource has been obtained that the duration of the
     *   resource is available.
     * - HAVE_CURRENT_DATA (numeric value 2)
     *   Data for the immediate current playback position is available.
     * - HAVE_FUTURE_DATA (numeric value 3)
     *   Data for the immediate current playback position is available, as
     *   well as enough data for the user agent to advance the current
     *   playback position in the direction of playback.
     * - HAVE_ENOUGH_DATA (numeric value 4)
     *   The user agent estimates that enough data is available for
     *   playback to proceed uninterrupted.
     * @return {Number} the current playback rendering state
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
     */
    value: function readyState() {
      return this.techGet('readyState');
    }
  }, {
    key: 'textTracks',

    /**
     * Text tracks are tracks of timed text events.
     * Captions - text displayed over the video for the hearing impaired
     * Subtitles - text displayed over the video for those who don't understand language in the video
     * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video
     * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device
     */

    /**
     * Get an array of associated text tracks. captions, subtitles, chapters, descriptions
     * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
     * @return {Array}           Array of track objects
     */
    value: function textTracks() {
      // cannot use techGet directly because it checks to see whether the tech is ready.
      // Flash is unlikely to be ready in time but textTracks should still work.
      return this.tech && this.tech.textTracks();
    }
  }, {
    key: 'remoteTextTracks',
    value: function remoteTextTracks() {
      return this.tech && this.tech.remoteTextTracks();
    }
  }, {
    key: 'addTextTrack',

    /**
     * Add a text track
     * In addition to the W3C settings we allow adding additional info through options.
     * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
     * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata
     * @param {String=} label       Optional label
     * @param {String=} language    Optional language
     */
    value: function addTextTrack(kind, label, language) {
      return this.tech && this.tech.addTextTrack(kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack(options) {
      return this.tech && this.tech.addRemoteTextTrack(options);
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      this.tech && this.tech.removeRemoteTextTrack(track);
    }
  }, {
    key: 'videoWidth',
    value: function videoWidth() {
      return this.tech && this.tech.videoWidth && this.tech.videoWidth() || 0;
    }
  }, {
    key: 'videoHeight',
    value: function videoHeight() {
      return this.tech && this.tech.videoHeight && this.tech.videoHeight() || 0;
    }
  }, {
    key: 'language',

    // Methods to add support for
    // initialTime: function(){ return this.techCall('initialTime'); },
    // startOffsetTime: function(){ return this.techCall('startOffsetTime'); },
    // played: function(){ return this.techCall('played'); },
    // seekable: function(){ return this.techCall('seekable'); },
    // videoTracks: function(){ return this.techCall('videoTracks'); },
    // audioTracks: function(){ return this.techCall('audioTracks'); },
    // defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },
    // mediaGroup: function(){ return this.techCall('mediaGroup'); },
    // controller: function(){ return this.techCall('controller'); },
    // defaultMuted: function(){ return this.techCall('defaultMuted'); }

    // TODO
    // currentSrcList: the array of sources including other formats and bitrates
    // playList: array of source lists in order of playback

    /**
     * The player's language code
     * @param  {String} languageCode  The locale string
     * @return {String}             The locale string when getting
     * @return {Player}         self, when setting
     */
    value: function language(languageCode) {
      if (languageCode === undefined) {
        return this.language_;
      }

      this.language_ = languageCode;
      return this;
    }
  }, {
    key: 'languages',

    /**
     * Get the player's language dictionary
     */
    value: function languages() {
      return this.languages_;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var options = _mergeOptions2['default'](this.options());
      var tracks = options.tracks;

      options.tracks = [];

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        // deep merge tracks and null out player so no circular references
        track = _mergeOptions2['default'](track);
        track.player = undefined;
        options.tracks[i] = track;
      }

      return options;
    }
  }], [{
    key: 'getTagSettings',
    value: function getTagSettings(tag) {
      var baseOptions = {
        sources: [],
        tracks: []
      };

      var tagOptions = Dom.getElementAttributes(tag);
      var dataSetup = tagOptions['data-setup'];

      // Check if data-setup attr exists.
      if (dataSetup !== null) {
        // Parse options JSON
        // If empty string, make it a parsable json object.

        var _safeParseTuple = _safeParseTuple4['default'](dataSetup || '{}');

        var _safeParseTuple2 = _slicedToArray(_safeParseTuple, 2);

        var err = _safeParseTuple2[0];
        var data = _safeParseTuple2[1];

        if (err) {
          _log2['default'].error(err);
        }
        _assign2['default'](tagOptions, data);
      }

      _assign2['default'](baseOptions, tagOptions);

      // Get tag children settings
      if (tag.hasChildNodes()) {
        var children = tag.childNodes;

        for (var i = 0, j = children.length; i < j; i++) {
          var child = children[i];
          // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
          var childName = child.nodeName.toLowerCase();
          if (childName === 'source') {
            baseOptions.sources.push(Dom.getElementAttributes(child));
          } else if (childName === 'track') {
            baseOptions.tracks.push(Dom.getElementAttributes(child));
          }
        }
      }

      return baseOptions;
    }
  }]);

  return Player;
})(_Component3['default']);

/**
 * Global player list
 * @type {Object}
 */
Player.players = {};

/**
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 * @private
 */
Player.prototype.options_ = _Options2['default'];

/**
 * Fired when the player has initial duration and dimension information
 * @event loadedmetadata
 */
Player.prototype.handleLoadedMetaData;

/**
 * Fired when the player has downloaded data at the current playback position
 * @event loadeddata
 */
Player.prototype.handleLoadedData;

/**
 * Fired when the player has finished downloading the source data
 * @event loadedalldata
 */
Player.prototype.handleLoadedAllData;

/**
 * Fired when the user is active, e.g. moves the mouse over the player
 * @event useractive
 */
Player.prototype.handleUserActive;

/**
 * Fired when the user is inactive, e.g. a short delay after the last mouse move or control interaction
 * @event userinactive
 */
Player.prototype.handleUserInactive;

/**
 * Fired when the current playback position has changed
 *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 * @event timeupdate
 */
Player.prototype.handleTimeUpdate;

/**
 * Fired when the volume changes
 * @event volumechange
 */
Player.prototype.handleVolumeChange;

/**
 * Fired when an error occurs
 * @event error
 */
Player.prototype.handleError;

Player.prototype.flexNotSupported_ = function () {
  var elem = _document2['default'].createElement('i');

  return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style);
};

_Component3['default'].registerComponent('Player', Player);
exports['default'] = Player;
module.exports = exports['default'];

},{"./big-play-button.js":43,"./component.js":45,"./control-bar/control-bar.js":46,"./error-display.js":77,"./fullscreen-api.js":80,"./loading-spinner.js":81,"./media-error.js":82,"./options.js":86,"./poster-image.js":89,"./tech/html5.js":95,"./tech/loader.js":96,"./tracks/text-track-display.js":99,"./tracks/text-track-settings.js":102,"./utils/browser.js":104,"./utils/dom.js":105,"./utils/events.js":106,"./utils/fn.js":107,"./utils/guid.js":109,"./utils/log.js":110,"./utils/merge-options.js":111,"./utils/time-ranges.js":113,"./utils/to-title-case.js":114,"global/document":1,"global/window":2,"object.assign":37,"safe-json-parse/tuple":42}],88:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Player = _dereq_('./player');

var _Player2 = _interopRequireWildcard(_Player);

/**
 * the method for registering a video.js plugin
 *
 * @param  {String} name The name of the plugin
 * @param  {Function} init The function that is run when the player inits
 */
var plugin = function plugin(name, init) {
  _Player2['default'].prototype[name] = init;
};

exports['default'] = plugin;
module.exports = exports['default'];

},{"./player":87}],89:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('./button.js');

var _Button3 = _interopRequireWildcard(_Button2);

var _Component = _dereq_('./component.js');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _import2 = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_import2);

var _import3 = _dereq_('./utils/browser.js');

var browser = _interopRequireWildcard(_import3);

/* Poster Image
================================================================================ */
/**
 * The component that handles showing the poster image.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PosterImage = (function (_Button) {
  function PosterImage(player, options) {
    _classCallCheck(this, PosterImage);

    _get(Object.getPrototypeOf(PosterImage.prototype), 'constructor', this).call(this, player, options);

    this.update();
    player.on('posterchange', Fn.bind(this, this.update));
  }

  _inherits(PosterImage, _Button);

  _createClass(PosterImage, [{
    key: 'dispose',

    /**
     * Clean up the poster image
     */
    value: function dispose() {
      this.player().off('posterchange', this.update);
      _get(Object.getPrototypeOf(PosterImage.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',

    /**
     * Create the poster image element
     * @return {Element}
     */
    value: function createEl() {
      var el = Dom.createEl('div', {
        className: 'vjs-poster',

        // Don't want poster to be tabbable.
        tabIndex: -1
      });

      // To ensure the poster image resizes while maintaining its original aspect
      // ratio, use a div with `background-size` when available. For browsers that
      // do not support `background-size` (e.g. IE8), fall back on using a regular
      // img element.
      if (!browser.BACKGROUND_SIZE_SUPPORTED) {
        this.fallbackImg_ = Dom.createEl('img');
        el.appendChild(this.fallbackImg_);
      }

      return el;
    }
  }, {
    key: 'update',

    /**
     * Event handler for updates to the player's poster source
     */
    value: function update() {
      var url = this.player().poster();

      this.setSrc(url);

      // If there's no poster source we should display:none on this component
      // so it's not still clickable or right-clickable
      if (url) {
        this.show();
      } else {
        this.hide();
      }
    }
  }, {
    key: 'setSrc',

    /**
     * Set the poster source depending on the display method
     */
    value: function setSrc(url) {
      if (this.fallbackImg_) {
        this.fallbackImg_.src = url;
      } else {
        var backgroundImage = '';
        // Any falsey values should stay as an empty string, otherwise
        // this will throw an extra error
        if (url) {
          backgroundImage = 'url("' + url + '")';
        }

        this.el_.style.backgroundImage = backgroundImage;
      }
    }
  }, {
    key: 'handleClick',

    /**
     * Event handler for clicks on the poster image
     */
    value: function handleClick() {
      // We don't want a click to trigger playback when controls are disabled
      // but CSS should be hiding the poster to prevent that from happening
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }
  }]);

  return PosterImage;
})(_Button3['default']);

_Component2['default'].registerComponent('PosterImage', PosterImage);
exports['default'] = PosterImage;
module.exports = exports['default'];

},{"./button.js":44,"./component.js":45,"./utils/browser.js":104,"./utils/dom.js":105,"./utils/fn.js":107}],90:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_import);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _windowLoaded = false;
var videojs = undefined;

/**
 * @fileoverview Functions for automatically setting up a player
 * based on the data-setup attribute of the video tag
 */

// Automatically set up any tags that have a data-setup attribute
var autoSetup = function autoSetup() {
  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements
  // to build up a new, combined list of elements.
  var vids = _document2['default'].getElementsByTagName('video');
  var audios = _document2['default'].getElementsByTagName('audio');
  var mediaEls = [];
  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }
  if (audios && audios.length > 0) {
    for (var i = 0, e = audios.length; i < e; i++) {
      mediaEls.push(audios[i]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var i = 0, e = mediaEls.length; i < e; i++) {
      var mediaEl = mediaEls[i];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl.player === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            var player = videojs(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
        autoSetupTimeout(1);
        break;
      }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};

// Pause to let the DOM keep processing
var autoSetupTimeout = function autoSetupTimeout(wait, vjs) {
  videojs = vjs;
  setTimeout(autoSetup, wait);
};

if (_document2['default'].readyState === 'complete') {
  _windowLoaded = true;
} else {
  Events.one(_window2['default'], 'load', function () {
    _windowLoaded = true;
  });
}

var hasLoaded = function hasLoaded() {
  return _windowLoaded;
};

exports.autoSetup = autoSetup;
exports.autoSetupTimeout = autoSetupTimeout;
exports.hasLoaded = hasLoaded;

},{"./utils/events.js":106,"global/document":1,"global/window":2}],91:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

/**
 * SeekBar Behavior includes play progress bar, and seek handle
 * Needed so it can determine seek position based on handle position/size
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SliderHandle = (function (_Component) {
  function SliderHandle() {
    _classCallCheck(this, SliderHandle);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(SliderHandle, _Component);

  _createClass(SliderHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl(type, props) {
      props = props || {};
      // Add the slider element class to all sub classes
      props.className = props.className + ' vjs-slider-handle';
      props = _assign2['default']({
        innerHTML: '<span class="vjs-control-text">' + (this.defaultValue || 0) + '</span>'
      }, props);

      return _get(Object.getPrototypeOf(SliderHandle.prototype), 'createEl', this).call(this, 'div', props);
    }
  }]);

  return SliderHandle;
})(_Component3['default']);

_Component3['default'].registerComponent('SliderHandle', SliderHandle);
exports['default'] = SliderHandle;
module.exports = exports['default'];

},{"../component.js":45,"object.assign":37}],92:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _roundFloat = _dereq_('../utils/round-float.js');

var _roundFloat2 = _interopRequireWildcard(_roundFloat);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

/* Slider
================================================================================ */
/**
 * The base functionality for sliders like the volume bar and seek bar
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var Slider = (function (_Component) {
  function Slider(player, options) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, player, options);

    // Set property names to bar and handle to match with the child Slider class is looking for
    this.bar = this.getChild(this.options_.barName);
    this.handle = this.getChild(this.options_.handleName);

    // Set a horizontal or vertical class on the slider depending on the slider type
    this.vertical(!!this.options().vertical);

    this.on('mousedown', this.handleMouseDown);
    this.on('touchstart', this.handleMouseDown);
    this.on('focus', this.handleFocus);
    this.on('blur', this.handleBlur);
    this.on('click', this.handleClick);

    this.on(player, 'controlsvisible', this.update);
    this.on(player, this.playerEvent, this.update);
  }

  _inherits(Slider, _Component);

  _createClass(Slider, [{
    key: 'createEl',
    value: function createEl(type) {
      var props = arguments[1] === undefined ? {} : arguments[1];

      // Add the slider element class to all sub classes
      props.className = props.className + ' vjs-slider';
      props = _assign2['default']({
        role: 'slider',
        'aria-valuenow': 0,
        'aria-valuemin': 0,
        'aria-valuemax': 100,
        tabIndex: 0
      }, props);

      return _get(Object.getPrototypeOf(Slider.prototype), 'createEl', this).call(this, type, props);
    }
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      event.preventDefault();
      Dom.blockTextSelection();
      this.addClass('vjs-sliding');

      this.on(_document2['default'], 'mousemove', this.handleMouseMove);
      this.on(_document2['default'], 'mouseup', this.handleMouseUp);
      this.on(_document2['default'], 'touchmove', this.handleMouseMove);
      this.on(_document2['default'], 'touchend', this.handleMouseUp);

      this.handleMouseMove(event);
    }
  }, {
    key: 'handleMouseMove',

    // To be overridden by a subclass
    value: function handleMouseMove() {}
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      Dom.unblockTextSelection();
      this.removeClass('vjs-sliding');

      this.off(_document2['default'], 'mousemove', this.handleMouseMove);
      this.off(_document2['default'], 'mouseup', this.handleMouseUp);
      this.off(_document2['default'], 'touchmove', this.handleMouseMove);
      this.off(_document2['default'], 'touchend', this.handleMouseUp);

      this.update();
    }
  }, {
    key: 'update',
    value: function update() {
      // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
      // execution stack. The player is destroyed before then update will cause an error
      if (!this.el_) {
        return;
      } // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
      // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
      // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
      var progress = this.getPercent();
      var bar = this.bar;

      // If there's no bar...
      if (!bar) {
        return;
      } // Protect against no duration and other division issues
      if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
        progress = 0;
      }

      // If there is a handle, we need to account for the handle in our calculation for progress bar
      // so that it doesn't fall short of or extend past the handle.
      var barProgress = this.updateHandlePosition(progress);

      // Convert to a percentage for setting
      var percentage = _roundFloat2['default'](barProgress * 100, 2) + '%';

      // Set the new bar width or height
      if (this.vertical()) {
        bar.el().style.height = percentage;
      } else {
        bar.el().style.width = percentage;
      }
    }
  }, {
    key: 'updateHandlePosition',

    /**
    * Update the handle position.
    */
    value: function updateHandlePosition(progress) {
      var handle = this.handle;
      if (!handle) {
        return;
      }var vertical = this.vertical();
      var box = this.el_;

      var boxSize = undefined,
          handleSize = undefined;
      if (vertical) {
        boxSize = box.offsetHeight;
        handleSize = handle.el().offsetHeight;
      } else {
        boxSize = box.offsetWidth;
        handleSize = handle.el().offsetWidth;
      }

      // The width of the handle in percent of the containing box
      // In IE, widths may not be ready yet causing NaN
      var handlePercent = handleSize ? handleSize / boxSize : 0;

      // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.
      // There is a margin of half the handle's width on both sides.
      var boxAdjustedPercent = 1 - handlePercent;

      // Adjust the progress that we'll use to set widths to the new adjusted box width
      var adjustedProgress = progress * boxAdjustedPercent;

      // The bar does reach the left side, so we need to account for this in the bar's width
      var barProgress = adjustedProgress + handlePercent / 2;

      var percentage = _roundFloat2['default'](adjustedProgress * 100, 2) + '%';

      if (vertical) {
        handle.el().style.bottom = percentage;
      } else {
        handle.el().style.left = percentage;
      }

      return barProgress;
    }
  }, {
    key: 'calculateDistance',
    value: function calculateDistance(event) {
      var el = this.el_;
      var box = Dom.findPosition(el);
      var boxW = el.offsetWidth;
      var boxH = el.offsetHeight;
      var handle = this.handle;

      if (this.options().vertical) {
        var boxY = box.top;

        var pageY = undefined;
        if (event.changedTouches) {
          pageY = event.changedTouches[0].pageY;
        } else {
          pageY = event.pageY;
        }

        if (handle) {
          var handleH = handle.el().offsetHeight;
          // Adjusted X and Width, so handle doesn't go outside the bar
          boxY = boxY + handleH / 2;
          boxH = boxH - handleH;
        }

        // Percent that the click is through the adjusted area
        return Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
      } else {
        var boxX = box.left;

        var pageX = undefined;
        if (event.changedTouches) {
          pageX = event.changedTouches[0].pageX;
        } else {
          pageX = event.pageX;
        }

        if (handle) {
          var handleW = handle.el().offsetWidth;

          // Adjusted X and Width, so handle doesn't go outside the bar
          boxX = boxX + handleW / 2;
          boxW = boxW - handleW;
        }

        // Percent that the click is through the adjusted area
        return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
      }
    }
  }, {
    key: 'handleFocus',
    value: function handleFocus() {
      this.on(_document2['default'], 'keydown', this.handleKeyPress);
    }
  }, {
    key: 'handleKeyPress',
    value: function handleKeyPress(event) {
      if (event.which === 37 || event.which === 40) {
        // Left and Down Arrows
        event.preventDefault();
        this.stepBack();
      } else if (event.which === 38 || event.which === 39) {
        // Up and Right Arrows
        event.preventDefault();
        this.stepForward();
      }
    }
  }, {
    key: 'handleBlur',
    value: function handleBlur() {
      this.off(_document2['default'], 'keydown', this.handleKeyPress);
    }
  }, {
    key: 'handleClick',

    /**
     * Listener for click events on slider, used to prevent clicks
     *   from bubbling up to parent elements like button menus.
     * @param  {Object} event Event object
     */
    value: function handleClick(event) {
      event.stopImmediatePropagation();
      event.preventDefault();
    }
  }, {
    key: 'vertical',
    value: function vertical(bool) {
      if (bool === undefined) {
        return this.vertical_ || false;
      }

      this.vertical_ = !!bool;

      if (this.vertical_) {
        this.addClass('vjs-slider-vertical');
      } else {
        this.addClass('vjs-slider-horizontal');
      }

      return this;
    }
  }]);

  return Slider;
})(_Component3['default']);

_Component3['default'].registerComponent('Slider', Slider);
exports['default'] = Slider;
module.exports = exports['default'];

},{"../component.js":45,"../utils/dom.js":105,"../utils/round-float.js":112,"global/document":1,"object.assign":37}],93:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function FlashRtmpDecorator(Flash) {
  Flash.streamingFormats = {
    'rtmp/mp4': 'MP4',
    'rtmp/flv': 'FLV'
  };

  Flash.streamFromParts = function (connection, stream) {
    return connection + '&' + stream;
  };

  Flash.streamToParts = function (src) {
    var parts = {
      connection: '',
      stream: ''
    };

    if (!src) return parts;

    // Look for the normal URL separator we expect, '&'.
    // If found, we split the URL into two pieces around the
    // first '&'.
    var connEnd = src.indexOf('&');
    var streamBegin = undefined;
    if (connEnd !== -1) {
      streamBegin = connEnd + 1;
    } else {
      // If there's not a '&', we use the last '/' as the delimiter.
      connEnd = streamBegin = src.lastIndexOf('/') + 1;
      if (connEnd === 0) {
        // really, there's not a '/'?
        connEnd = streamBegin = src.length;
      }
    }
    parts.connection = src.substring(0, connEnd);
    parts.stream = src.substring(streamBegin, src.length);

    return parts;
  };

  Flash.isStreamingType = function (srcType) {
    return srcType in Flash.streamingFormats;
  };

  // RTMP has four variations, any string starting
  // with one of these protocols should be valid
  Flash.RTMP_RE = /^rtmp[set]?:\/\//i;

  Flash.isStreamingSrc = function (src) {
    return Flash.RTMP_RE.test(src);
  };

  /**
   * A source handler for RTMP urls
   * @type {Object}
   */
  Flash.rtmpSourceHandler = {};

  /**
   * Check Flash can handle the source natively
   * @param  {Object} source  The source object
   * @return {String}         'probably', 'maybe', or '' (empty string)
   */
  Flash.rtmpSourceHandler.canHandleSource = function (source) {
    if (Flash.isStreamingType(source.type) || Flash.isStreamingSrc(source.src)) {
      return 'maybe';
    }

    return '';
  };

  /**
   * Pass the source to the flash object
   * Adaptive source handlers will have more complicated workflows before passing
   * video data to the video element
   * @param  {Object} source    The source object
   * @param  {Flash} tech   The instance of the Flash tech
   */
  Flash.rtmpSourceHandler.handleSource = function (source, tech) {
    var srcParts = Flash.streamToParts(source.src);

    tech.setRtmpConnection(srcParts.connection);
    tech.setRtmpStream(srcParts.stream);
  };

  // Register the native source handler
  Flash.registerSourceHandler(Flash.rtmpSourceHandler);

  return Flash;
}

exports['default'] = FlashRtmpDecorator;
module.exports = exports['default'];

},{}],94:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview VideoJS-SWF - Custom Flash Player with HTML5-ish API
 * https://github.com/zencoder/video-js-swf
 * Not using setupTriggers. Using global onEvent func to distribute events
 */

var _Tech2 = _dereq_('./tech');

var _Tech3 = _interopRequireWildcard(_Tech2);

var _import = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _import2 = _dereq_('../utils/url.js');

var Url = _interopRequireWildcard(_import2);

var _createTimeRange = _dereq_('../utils/time-ranges.js');

var _FlashRtmpDecorator = _dereq_('./flash-rtmp');

var _FlashRtmpDecorator2 = _interopRequireWildcard(_FlashRtmpDecorator);

var _Component = _dereq_('../component');

var _Component2 = _interopRequireWildcard(_Component);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

var navigator = _window2['default'].navigator;
/**
 * Flash Media Controller - Wrapper for fallback SWF API
 *
 * @param {Player} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */

var Flash = (function (_Tech) {
  function Flash(options, ready) {
    _classCallCheck(this, Flash);

    _get(Object.getPrototypeOf(Flash.prototype), 'constructor', this).call(this, options, ready);

    var source = options.source;
    var parentEl = options.parentEl;

    // Generate ID for swf object
    var objId = options.playerId + '_flash_api';

    // Merge default flashvars with ones passed in to init
    var flashVars = _assign2['default']({

      // SWF Callback Functions
      readyFunction: 'videojs.Flash.onReady',
      eventProxyFunction: 'videojs.Flash.onEvent',
      errorEventProxyFunction: 'videojs.Flash.onError',

      // Player Settings
      autoplay: options.autoplay,
      preload: options.preload,
      loop: options.loop,
      muted: options.muted

    }, options.flashVars);

    // Merge default parames with ones passed in
    var params = _assign2['default']({
      wmode: 'opaque', // Opaque is needed to overlay controls, but can affect playback performance
      bgcolor: '#000000' // Using bgcolor prevents a white flash when the object is loading
    }, options.params);

    // Merge default attributes with ones passed in
    var attributes = _assign2['default']({
      id: objId,
      name: objId, // Both ID and Name needed or swf to identify itself
      'class': 'vjs-tech'
    }, options.attributes);

    // If source was supplied pass as a flash var.
    if (source) {
      this.ready(function () {
        this.setSource(source);
      });
    }

    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers
    // This allows resetting the playhead when we catch the reload
    if (options.startTime) {
      this.ready(function () {
        this.load();
        this.play();
        this.currentTime(options.startTime);
      });
    }

    _window2['default'].videojs = _window2['default'].videojs || {};
    _window2['default'].videojs.Flash = _window2['default'].videojs.Flash || {};
    _window2['default'].videojs.Flash.onReady = Flash.onReady;
    _window2['default'].videojs.Flash.onEvent = Flash.onEvent;
    _window2['default'].videojs.Flash.onError = Flash.onError;

    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);
    this.el_.tech = this;
  }

  _inherits(Flash, _Tech);

  _createClass(Flash, [{
    key: 'play',
    value: function play() {
      this.el_.vjs_play();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.el_.vjs_pause();
    }
  }, {
    key: 'src',
    value: (function (_src) {
      function src(_x) {
        return _src.apply(this, arguments);
      }

      src.toString = function () {
        return _src.toString();
      };

      return src;
    })(function (src) {
      if (src === undefined) {
        return this.currentSrc();
      }

      // Setting src through `src` not `setSrc` will be deprecated
      return this.setSrc(src);
    })
  }, {
    key: 'setSrc',
    value: function setSrc(src) {
      // Make sure source URL is absolute.
      src = Url.getAbsoluteURL(src);
      this.el_.vjs_src(src);

      // Currently the SWF doesn't autoplay if you load a source later.
      // e.g. Load player w/ no source, wait 2s, set src.
      if (this.autoplay()) {
        var tech = this;
        this.setTimeout(function () {
          tech.play();
        }, 0);
      }
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime(time) {
      this.lastSeekTarget_ = time;
      this.el_.vjs_setProperty('currentTime', time);
      _get(Object.getPrototypeOf(Flash.prototype), 'setCurrentTime', this).call(this);
    }
  }, {
    key: 'currentTime',
    value: function currentTime(time) {
      // when seeking make the reported time keep up with the requested time
      // by reading the time we're seeking to
      if (this.seeking()) {
        return this.lastSeekTarget_ || 0;
      }
      return this.el_.vjs_getProperty('currentTime');
    }
  }, {
    key: 'currentSrc',
    value: function currentSrc() {
      if (this.currentSource_) {
        return this.currentSource_.src;
      } else {
        return this.el_.vjs_getProperty('currentSrc');
      }
    }
  }, {
    key: 'load',
    value: function load() {
      this.el_.vjs_load();
    }
  }, {
    key: 'poster',
    value: function poster() {
      this.el_.vjs_getProperty('poster');
    }
  }, {
    key: 'setPoster',

    // poster images are not handled by the Flash tech so make this a no-op
    value: function setPoster() {}
  }, {
    key: 'buffered',
    value: function buffered() {
      return _createTimeRange.createTimeRange(0, this.el_.vjs_getProperty('buffered'));
    }
  }, {
    key: 'supportsFullScreen',
    value: function supportsFullScreen() {
      return false; // Flash does not allow fullscreen through javascript
    }
  }, {
    key: 'enterFullScreen',
    value: function enterFullScreen() {
      return false;
    }
  }]);

  return Flash;
})(_Tech3['default']);

// Create setters and getters for attributes
var _api = Flash.prototype;
var _readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(',');
var _readOnly = 'error,networkState,readyState,seeking,initialTime,duration,startOffsetTime,paused,played,seekable,ended,videoTracks,audioTracks,videoWidth,videoHeight'.split(',');

function _createSetter(attr) {
  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);
  _api['set' + attrUpper] = function (val) {
    return this.el_.vjs_setProperty(attr, val);
  };
}
function _createGetter(attr) {
  _api[attr] = function () {
    return this.el_.vjs_getProperty(attr);
  };
}

// Create getter and setters for all read/write attributes
for (var i = 0; i < _readWrite.length; i++) {
  _createGetter(_readWrite[i]);
  _createSetter(_readWrite[i]);
}

// Create getters for read-only attributes
for (var i = 0; i < _readOnly.length; i++) {
  _createGetter(_readOnly[i]);
}

/* Flash Support Testing -------------------------------------------------------- */

Flash.isSupported = function () {
  return Flash.version()[0] >= 10;
  // return swfobject.hasFlashPlayerVersion('10');
};

// Add Source Handler pattern functions to this tech
_Tech3['default'].withSourceHandlers(Flash);

/**
 * The default native source handler.
 * This simply passes the source to the video element. Nothing fancy.
 * @param  {Object} source   The source object
 * @param  {Flash} tech  The instance of the Flash tech
 */
Flash.nativeSourceHandler = {};

/**
 * Check Flash can handle the source natively
 * @param  {Object} source  The source object
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Flash.nativeSourceHandler.canHandleSource = function (source) {
  var type;

  function guessMimeType(src) {
    var ext = Url.getFileExtension(src);
    if (ext) {
      return 'video/' + ext;
    }
    return '';
  }

  if (!source.type) {
    type = guessMimeType(source.src);
  } else {
    // Strip code information from the type because we don't get that specific
    type = source.type.replace(/;.*/, '').toLowerCase();
  }

  if (type in Flash.formats) {
    return 'maybe';
  }

  return '';
};

/**
 * Pass the source to the flash object
 * Adaptive source handlers will have more complicated workflows before passing
 * video data to the video element
 * @param  {Object} source    The source object
 * @param  {Flash} tech   The instance of the Flash tech
 */
Flash.nativeSourceHandler.handleSource = function (source, tech) {
  tech.setSrc(source.src);
};

/**
 * Clean up the source handler when disposing the player or switching sources..
 * (no cleanup is needed when supporting the format natively)
 */
Flash.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Flash.registerSourceHandler(Flash.nativeSourceHandler);

Flash.formats = {
  'video/flv': 'FLV',
  'video/x-flv': 'FLV',
  'video/mp4': 'MP4',
  'video/m4v': 'MP4'
};

Flash.onReady = function (currSwf) {
  var el = Dom.el(currSwf);
  var tech = el && el.tech;

  // if there is no el then the tech has been disposed
  // and the tech element was removed from the player div
  if (tech && tech.el()) {
    // check that the flash object is really ready
    Flash.checkReady(tech);
  }
};

// The SWF isn't always ready when it says it is. Sometimes the API functions still need to be added to the object.
// If it's not ready, we set a timeout to check again shortly.
Flash.checkReady = function (tech) {
  // stop worrying if the tech has been disposed
  if (!tech.el()) {
    return;
  }

  // check if API property exists
  if (tech.el().vjs_getProperty) {
    // tell tech it's ready
    tech.triggerReady();
  } else {
    // wait longer
    this.setTimeout(function () {
      Flash.checkReady(tech);
    }, 50);
  }
};

// Trigger events from the swf on the player
Flash.onEvent = function (swfID, eventName) {
  var tech = Dom.el(swfID).tech;
  tech.trigger(eventName);
};

// Log errors from the swf
Flash.onError = function (swfID, err) {
  var tech = Dom.el(swfID).tech;
  var msg = 'FLASH: ' + err;

  if (err === 'srcnotfound') {
    tech.trigger('error', { code: 4, message: msg });

    // errors we haven't categorized into the media errors
  } else {
    tech.trigger('error', msg);
  }
};

// Flash Version Check
Flash.version = function () {
  var version = '0,0,0';

  // IE
  try {
    version = new _window2['default'].ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

    // other browsers
  } catch (e) {
    try {
      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch (err) {}
  }
  return version.split(',');
};

// Flash embedding method. Only used in non-iframe mode
Flash.embed = function (swf, flashVars, params, attributes) {
  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);

  // Get element by embedding code and retrieving created element
  var obj = Dom.createEl('div', { innerHTML: code }).childNodes[0];

  return obj;
};

Flash.getEmbedCode = function (swf, flashVars, params, attributes) {
  var objTag = '<object type="application/x-shockwave-flash" ';
  var flashVarsString = '';
  var paramsString = '';
  var attrsString = '';

  // Convert flash vars to string
  if (flashVars) {
    Object.getOwnPropertyNames(flashVars).forEach(function (key) {
      flashVarsString += '' + key + '=' + flashVars[key] + '&amp;';
    });
  }

  // Add swf, flashVars, and other default params
  params = _assign2['default']({
    movie: swf,
    flashvars: flashVarsString,
    allowScriptAccess: 'always', // Required to talk to swf
    allowNetworking: 'all' // All should be default, but having security issues.
  }, params);

  // Create param tags string
  Object.getOwnPropertyNames(params).forEach(function (key) {
    paramsString += '<param name="' + key + '" value="' + params[key] + '" />';
  });

  attributes = _assign2['default']({
    // Add swf to attributes (need both for IE and Others to work)
    data: swf,

    // Default to 100% width/height
    width: '100%',
    height: '100%'

  }, attributes);

  // Create Attributes string
  Object.getOwnPropertyNames(attributes).forEach(function (key) {
    attrsString += '' + key + '="' + attributes[key] + '" ';
  });

  return '' + objTag + '' + attrsString + '>' + paramsString + '</object>';
};

// Run Flash through the RTMP decorator
_FlashRtmpDecorator2['default'](Flash);

_Component2['default'].registerComponent('Flash', Flash);
exports['default'] = Flash;
module.exports = exports['default'];

},{"../component":45,"../utils/dom.js":105,"../utils/time-ranges.js":113,"../utils/url.js":115,"./flash-rtmp":93,"./tech":97,"global/window":2,"object.assign":37}],95:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API
 */

var _Tech2 = _dereq_('./tech.js');

var _Tech3 = _interopRequireWildcard(_Tech2);

var _Component = _dereq_('../component');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_import);

var _import2 = _dereq_('../utils/url.js');

var Url = _interopRequireWildcard(_import2);

var _import3 = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_import3);

var _log = _dereq_('../utils/log.js');

var _log2 = _interopRequireWildcard(_log);

var _import4 = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_import4);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

var _mergeOptions = _dereq_('../utils/merge-options.js');

var _mergeOptions2 = _interopRequireWildcard(_mergeOptions);

/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 * @param {Player|Object} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */

var Html5 = (function (_Tech) {
  function Html5(options, ready) {
    _classCallCheck(this, Html5);

    _get(Object.getPrototypeOf(Html5.prototype), 'constructor', this).call(this, options, ready);

    var source = options.source;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      this.setSource(source);
    }

    if (this.el_.hasChildNodes()) {

      var nodes = this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === 'track') {
          if (!this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            this.remoteTextTracks().addTrack_(node.track);
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        this.el_.removeChild(removeNodes[i]);
      }
    }

    if (this.featuresNativeTextTracks) {
      this.on('loadstart', Fn.bind(this, this.hideCaptions));
    }

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if (browser.TOUCH_ENABLED && options.nativeControlsForTouch === true) {
      this.trigger('usenativecontrols');
    }

    this.triggerReady();
  }

  _inherits(Html5, _Tech);

  _createClass(Html5, [{
    key: 'dispose',
    value: function dispose() {
      Html5.disposeMediaElement(this.el_);
      _get(Object.getPrototypeOf(Html5.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var el = this.options_.tag;

      // Check if this browser supports moving the element into the box.
      // On the iPhone video will break if you move the element,
      // So we have to create a brand new element.
      if (!el || this.movingMediaElementInDOM === false) {

        // If the original tag is still there, clone and remove it.
        if (el) {
          var clone = el.cloneNode(false);
          Html5.disposeMediaElement(el);
          el = clone;
        } else {
          el = _document2['default'].createElement('video');

          // determine if native controls should be used
          var tagAttributes = this.options_.tag && Dom.getElementAttributes(this.options_.tag);
          var attributes = _mergeOptions2['default']({}, tagAttributes);
          if (!browser.TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
            delete attributes.controls;
          }

          Dom.setElementAttributes(el, _assign2['default'](attributes, {
            id: this.options_.playerId + '_html5_api',
            'class': 'vjs-tech'
          }));
        }

        if (this.options_.tracks) {
          for (var i = 0; i < this.options_.tracks.length; i++) {
            var _track = this.options_.tracks[i];
            var trackEl = _document2['default'].createElement('track');
            trackEl.kind = _track.kind;
            trackEl.label = _track.label;
            trackEl.srclang = _track.srclang;
            trackEl.src = _track.src;
            if ('default' in _track) {
              trackEl.setAttribute('default', 'default');
            }
            el.appendChild(trackEl);
          }
        }
      }

      // Update specific tag settings, in case they were overridden
      var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted'];
      for (var i = settingsAttrs.length - 1; i >= 0; i--) {
        var attr = settingsAttrs[i];
        var overwriteAttrs = {};
        if (typeof this.options_[attr] !== 'undefined') {
          overwriteAttrs[attr] = this.options_[attr];
        }
        Dom.setElementAttributes(el, overwriteAttrs);
      }

      return el;
      // jenniisawesome = true;
    }
  }, {
    key: 'hideCaptions',
    value: function hideCaptions() {
      var tracks = this.el_.querySelectorAll('track');
      var i = tracks.length;
      var kinds = {
        captions: 1,
        subtitles: 1
      };

      while (i--) {
        var _track2 = tracks[i].track;
        if (_track2 && _track2.kind in kinds && !tracks[i]['default']) {
          _track2.mode = 'disabled';
        }
      }
    }
  }, {
    key: 'play',
    value: function play() {
      this.el_.play();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.el_.pause();
    }
  }, {
    key: 'paused',
    value: function paused() {
      return this.el_.paused;
    }
  }, {
    key: 'currentTime',
    value: function currentTime() {
      return this.el_.currentTime;
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime(seconds) {
      try {
        this.el_.currentTime = seconds;
      } catch (e) {
        _log2['default'](e, 'Video is not ready. (Video.js)');
        // this.warning(VideoJS.warnings.videoNotReady);
      }
    }
  }, {
    key: 'duration',
    value: function duration() {
      return this.el_.duration || 0;
    }
  }, {
    key: 'buffered',
    value: function buffered() {
      return this.el_.buffered;
    }
  }, {
    key: 'volume',
    value: function volume() {
      return this.el_.volume;
    }
  }, {
    key: 'setVolume',
    value: function setVolume(percentAsDecimal) {
      this.el_.volume = percentAsDecimal;
    }
  }, {
    key: 'muted',
    value: function muted() {
      return this.el_.muted;
    }
  }, {
    key: 'setMuted',
    value: function setMuted(muted) {
      this.el_.muted = muted;
    }
  }, {
    key: 'width',
    value: function width() {
      return this.el_.offsetWidth;
    }
  }, {
    key: 'height',
    value: function height() {
      return this.el_.offsetHeight;
    }
  }, {
    key: 'supportsFullScreen',
    value: function supportsFullScreen() {
      if (typeof this.el_.webkitEnterFullScreen === 'function') {
        var userAgent = _window2['default'].navigator.userAgent;
        // Seems to be broken in Chromium/Chrome && Safari in Leopard
        if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'enterFullScreen',
    value: function enterFullScreen() {
      var video = this.el_;

      if ('webkitDisplayingFullscreen' in video) {
        this.one('webkitbeginfullscreen', function () {
          this.one('webkitendfullscreen', function () {
            this.trigger('fullscreenchange');
          });

          this.trigger('fullscreenchange');
        });
      }

      if (video.paused && video.networkState <= video.HAVE_METADATA) {
        // attempt to prime the video element for programmatic access
        // this isn't necessary on the desktop but shouldn't hurt
        this.el_.play();

        // playing and pausing synchronously during the transition to fullscreen
        // can get iOS ~6.1 devices into a play/pause loop
        this.setTimeout(function () {
          video.pause();
          video.webkitEnterFullScreen();
        }, 0);
      } else {
        video.webkitEnterFullScreen();
      }
    }
  }, {
    key: 'exitFullScreen',
    value: function exitFullScreen() {
      this.el_.webkitExitFullScreen();
    }
  }, {
    key: 'src',
    value: (function (_src) {
      function src(_x) {
        return _src.apply(this, arguments);
      }

      src.toString = function () {
        return _src.toString();
      };

      return src;
    })(function (src) {
      if (src === undefined) {
        return this.el_.src;
      } else {
        // Setting src through `src` instead of `setSrc` will be deprecated
        this.setSrc(src);
      }
    })
  }, {
    key: 'setSrc',
    value: function setSrc(src) {
      this.el_.src = src;
    }
  }, {
    key: 'load',
    value: function load() {
      this.el_.load();
    }
  }, {
    key: 'currentSrc',
    value: function currentSrc() {
      return this.el_.currentSrc;
    }
  }, {
    key: 'poster',
    value: function poster() {
      return this.el_.poster;
    }
  }, {
    key: 'setPoster',
    value: function setPoster(val) {
      this.el_.poster = val;
    }
  }, {
    key: 'preload',
    value: function preload() {
      return this.el_.preload;
    }
  }, {
    key: 'setPreload',
    value: function setPreload(val) {
      this.el_.preload = val;
    }
  }, {
    key: 'autoplay',
    value: function autoplay() {
      return this.el_.autoplay;
    }
  }, {
    key: 'setAutoplay',
    value: function setAutoplay(val) {
      this.el_.autoplay = val;
    }
  }, {
    key: 'controls',
    value: function controls() {
      return this.el_.controls;
    }
  }, {
    key: 'setControls',
    value: function setControls(val) {
      this.el_.controls = !!val;
    }
  }, {
    key: 'loop',
    value: function loop() {
      return this.el_.loop;
    }
  }, {
    key: 'setLoop',
    value: function setLoop(val) {
      this.el_.loop = val;
    }
  }, {
    key: 'error',
    value: function error() {
      return this.el_.error;
    }
  }, {
    key: 'seeking',
    value: function seeking() {
      return this.el_.seeking;
    }
  }, {
    key: 'ended',
    value: function ended() {
      return this.el_.ended;
    }
  }, {
    key: 'defaultMuted',
    value: function defaultMuted() {
      return this.el_.defaultMuted;
    }
  }, {
    key: 'playbackRate',
    value: function playbackRate() {
      return this.el_.playbackRate;
    }
  }, {
    key: 'setPlaybackRate',
    value: function setPlaybackRate(val) {
      this.el_.playbackRate = val;
    }
  }, {
    key: 'networkState',
    value: function networkState() {
      return this.el_.networkState;
    }
  }, {
    key: 'readyState',
    value: function readyState() {
      return this.el_.readyState;
    }
  }, {
    key: 'videoWidth',
    value: function videoWidth() {
      return this.el_.videoWidth;
    }
  }, {
    key: 'videoHeight',
    value: function videoHeight() {
      return this.el_.videoHeight;
    }
  }, {
    key: 'textTracks',
    value: function textTracks() {
      if (!this.featuresNativeTextTracks) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'textTracks', this).call(this);
      }

      return this.el_.textTracks;
    }
  }, {
    key: 'addTextTrack',
    value: function addTextTrack(kind, label, language) {
      if (!this.featuresNativeTextTracks) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'addTextTrack', this).call(this, kind, label, language);
      }

      return this.el_.addTextTrack(kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack() {
      var options = arguments[0] === undefined ? {} : arguments[0];

      if (!this.featuresNativeTextTracks) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'addRemoteTextTrack', this).call(this, options);
      }

      var track = _document2['default'].createElement('track');

      if (options.kind) {
        track.kind = options.kind;
      }
      if (options.label) {
        track.label = options.label;
      }
      if (options.language || options.srclang) {
        track.srclang = options.language || options.srclang;
      }
      if (options['default']) {
        track['default'] = options['default'];
      }
      if (options.id) {
        track.id = options.id;
      }
      if (options.src) {
        track.src = options.src;
      }

      this.el().appendChild(track);

      if (track.track.kind === 'metadata') {
        track.track.mode = 'hidden';
      } else {
        track.track.mode = 'disabled';
      }

      track.onload = function () {
        var tt = track.track;
        if (track.readyState >= 2) {
          if (tt.kind === 'metadata' && tt.mode !== 'hidden') {
            tt.mode = 'hidden';
          } else if (tt.kind !== 'metadata' && tt.mode !== 'disabled') {
            tt.mode = 'disabled';
          }
          track.onload = null;
        }
      };

      this.remoteTextTracks().addTrack_(track.track);

      return track;
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      if (!this.featuresNativeTextTracks) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'removeRemoteTextTrack', this).call(this, track);
      }

      var tracks, i;

      this.remoteTextTracks().removeTrack_(track);

      tracks = this.el().querySelectorAll('track');

      for (i = 0; i < tracks.length; i++) {
        if (tracks[i] === track || tracks[i].track === track) {
          tracks[i].parentNode.removeChild(tracks[i]);
          break;
        }
      }
    }
  }]);

  return Html5;
})(_Tech3['default']);

/* HTML5 Support Testing ---------------------------------------------------- */

/**
 * Element for testing browser HTML5 video capabilities
 * @type {Element}
 * @constant
 * @private
 */
Html5.TEST_VID = _document2['default'].createElement('video');
var track = _document2['default'].createElement('track');
track.kind = 'captions';
track.srclang = 'en';
track.label = 'English';
Html5.TEST_VID.appendChild(track);

/**
 * Check if HTML5 video is supported by this browser/device
 * @return {Boolean}
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }

  return !!Html5.TEST_VID.canPlayType;
};

// Add Source Handler pattern functions to this tech
_Tech3['default'].withSourceHandlers(Html5);

/**
 * The default native source handler.
 * This simply passes the source to the video element. Nothing fancy.
 * @param  {Object} source   The source object
 * @param  {Html5} tech  The instance of the HTML5 tech
 */
Html5.nativeSourceHandler = {};

/**
 * Check if the video element can handle the source natively
 * @param  {Object} source  The source object
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canHandleSource = function (source) {
  var match, ext;

  function canPlayType(type) {
    // IE9 on Windows 7 without MediaPlayer throws an error here
    // https://github.com/videojs/video.js/issues/519
    try {
      return Html5.TEST_VID.canPlayType(type);
    } catch (e) {
      return '';
    }
  }

  // If a type was provided we should rely on that
  if (source.type) {
    return canPlayType(source.type);
  } else if (source.src) {
    // If no type, fall back to checking 'video/[EXTENSION]'
    ext = Url.getFileExtension(source.src);

    return canPlayType('video/' + ext);
  }

  return '';
};

/**
 * Pass the source to the video element
 * Adaptive source handlers will have more complicated workflows before passing
 * video data to the video element
 * @param  {Object} source    The source object
 * @param  {Html5} tech   The instance of the Html5 tech
 */
Html5.nativeSourceHandler.handleSource = function (source, tech) {
  tech.setSrc(source.src);
};

/**
 * Clean up the source handler when disposing the player or switching sources..
 * (no cleanup is needed when supporting the format natively)
 */
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

/**
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 * @return {Boolean}
 */
Html5.canControlVolume = function () {
  var volume = Html5.TEST_VID.volume;
  Html5.TEST_VID.volume = volume / 2 + 0.1;
  return volume !== Html5.TEST_VID.volume;
};

/**
 * Check if playbackRate is supported in this browser/device.
 * @return {[type]} [description]
 */
Html5.canControlPlaybackRate = function () {
  var playbackRate = Html5.TEST_VID.playbackRate;
  Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
  return playbackRate !== Html5.TEST_VID.playbackRate;
};

/**
 * Check to see if native text tracks are supported by this browser/device
 * @return {Boolean}
 */
Html5.supportsNativeTextTracks = function () {
  var supportsTextTracks;

  // Figure out native text track support
  // If mode is a number, we cannot change it because it'll disappear from view.
  // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.
  // Firefox isn't playing nice either with modifying the mode
  // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862
  supportsTextTracks = !!Html5.TEST_VID.textTracks;
  if (supportsTextTracks && Html5.TEST_VID.textTracks.length > 0) {
    supportsTextTracks = typeof Html5.TEST_VID.textTracks[0].mode !== 'number';
  }
  if (supportsTextTracks && browser.IS_FIREFOX) {
    supportsTextTracks = false;
  }

  return supportsTextTracks;
};

/**
 * Set the tech's volume control support status
 * @type {Boolean}
 */
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();

/**
 * Set the tech's playbackRate support status
 * @type {Boolean}
 */
Html5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();

/**
 * Set the tech's status on moving the video element.
 * In iOS, if you move a video element in the DOM, it breaks video playback.
 * @type {Boolean}
 */
Html5.prototype.movingMediaElementInDOM = !browser.IS_IOS;

/**
 * Set the the tech's fullscreen resize support status.
 * HTML video is able to automatically resize when going to fullscreen.
 * (No longer appears to be used. Can probably be removed.)
 */
Html5.prototype.featuresFullscreenResize = true;

/**
 * Set the tech's progress event support status
 * (this disables the manual progress events of the Tech)
 */
Html5.prototype.featuresProgressEvents = true;

/**
 * Sets the tech's status on native text track support
 * @type {Boolean}
 */
Html5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = undefined;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {
  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  if (browser.ANDROID_VERSION >= 4) {
    if (!canPlayType) {
      canPlayType = Html5.TEST_VID.constructor.prototype.canPlayType;
    }

    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }

  // Override Android 2.2 and less canPlayType method which is broken
  if (browser.IS_OLD_ANDROID) {
    if (!canPlayType) {
      canPlayType = Html5.TEST_VID.constructor.prototype.canPlayType;
    }

    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Html5.TEST_VID.constructor.prototype.canPlayType;
  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  canPlayType = null;
  return r;
};

// by default, patch the video element
Html5.patchCanPlayType();

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {}
    })();
  }
};

_Component2['default'].registerComponent('Html5', Html5);
exports['default'] = Html5;
module.exports = exports['default'];

// not supported

},{"../component":45,"../utils/browser.js":104,"../utils/dom.js":105,"../utils/fn.js":107,"../utils/log.js":110,"../utils/merge-options.js":111,"../utils/url.js":115,"./tech.js":97,"global/document":1,"global/window":2,"object.assign":37}],96:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _toTitleCase = _dereq_('../utils/to-title-case.js');

var _toTitleCase2 = _interopRequireWildcard(_toTitleCase);

/**
 * The Media Loader is the component that decides which playback technology to load
 * when the player is initialized.
 *
 * @constructor
 */

var MediaLoader = (function (_Component) {
  function MediaLoader(player, options, ready) {
    _classCallCheck(this, MediaLoader);

    _get(Object.getPrototypeOf(MediaLoader.prototype), 'constructor', this).call(this, player, options, ready);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.
    if (!player.options_.sources || player.options_.sources.length === 0) {
      for (var i = 0, j = player.options_.techOrder; i < j.length; i++) {
        var techName = _toTitleCase2['default'](j[i]);
        var tech = _Component3['default'].getComponent(techName);

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech(techName);
          break;
        }
      }
    } else {
      // // Loop through playback technologies (HTML5, Flash) and check for support.
      // // Then load the best source.
      // // A few assumptions here:
      // //   All playback technologies respect preload false.
      player.src(player.options_.sources);
    }
  }

  _inherits(MediaLoader, _Component);

  return MediaLoader;
})(_Component3['default']);

_Component3['default'].registerComponent('MediaLoader', MediaLoader);
exports['default'] = MediaLoader;
module.exports = exports['default'];

},{"../component":45,"../utils/to-title-case.js":114,"global/window":2}],97:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview Media Technology Controller - Base class for media playback
 * technology controllers like Flash and HTML5
 */

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _TextTrack = _dereq_('../tracks/text-track');

var _TextTrack2 = _interopRequireWildcard(_TextTrack);

var _TextTrackList = _dereq_('../tracks/text-track-list');

var _TextTrackList2 = _interopRequireWildcard(_TextTrackList);

var _import = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _log = _dereq_('../utils/log.js');

var _log2 = _interopRequireWildcard(_log);

var _createTimeRange = _dereq_('../utils/time-ranges.js');

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * Base class for media (HTML5 Video, Flash) controllers
 * @param {Player|Object} player  Central player instance
 * @param {Object=} options Options object
 * @constructor
 */

var Tech = (function (_Component) {
  function Tech() {
    var options = arguments[0] === undefined ? {} : arguments[0];
    var ready = arguments[1] === undefined ? function () {} : arguments[1];

    _classCallCheck(this, Tech);

    options = options || {};
    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;
    _get(Object.getPrototypeOf(Tech.prototype), 'constructor', this).call(this, null, options, ready);

    this.textTracks_ = options.textTracks;

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!this.featuresProgressEvents) {
      this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!this.featuresTimeupdateEvents) {
      this.manualTimeUpdatesOn();
    }

    this.initControlsListeners();

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      this.featuresNativeTextTracks = false;
    }

    if (!this.featuresNativeTextTracks) {
      this.emulateTextTracks();
    }

    this.initTextTrackListeners();
  }

  _inherits(Tech, _Component);

  _createClass(Tech, [{
    key: 'initControlsListeners',

    /**
     * Set up click and touch listeners for the playback element
     * On desktops, a click on the video itself will toggle playback,
     * on a mobile device a click on the video toggles controls.
     * (toggling controls is done by toggling the user state between active and
     * inactive)
     *
     * A tap can signal that a user has become active, or has become inactive
     * e.g. a quick tap on an iPhone movie should reveal the controls. Another
     * quick tap should hide them again (signaling the user is in an inactive
     * viewing state)
     *
     * In addition to this, we still want the user to be considered inactive after
     * a few seconds of inactivity.
     *
     * Note: the only part of iOS interaction we can't mimic with this setup
     * is a touch and hold on the video element counting as activity in order to
     * keep the controls showing, but that shouldn't be an issue. A touch and hold on
     * any controls will still keep the user active
     */
    value: function initControlsListeners() {
      // if we're loading the playback object after it has started loading or playing the
      // video (often with autoplay on) then the loadstart event has already fired and we
      // need to fire it manually because many things rely on it.
      // Long term we might consider how we would do this for other events like 'canplay'
      // that may also have fired.
      this.ready(function () {
        if (this.networkState && this.networkState() > 0) {
          this.trigger('loadstart');
        }
      });
    }
  }, {
    key: 'manualProgressOn',

    /* Fallbacks for unsupported event types
    ================================================================================ */
    // Manually trigger progress events based on changes to the buffered amount
    // Many flash players and older HTML5 browsers don't send progress or progress-like events
    value: function manualProgressOn() {
      this.on('durationchange', this.onDurationChange);

      this.manualProgress = true;

      // Trigger progress watching when a source begins loading
      this.trackProgress();
    }
  }, {
    key: 'manualProgressOff',
    value: function manualProgressOff() {
      this.manualProgress = false;
      this.stopTrackingProgress();

      this.off('durationchange', this.onDurationChange);
    }
  }, {
    key: 'trackProgress',
    value: function trackProgress() {
      this.progressInterval = this.setInterval(Fn.bind(this, function () {
        // Don't trigger unless buffered amount is greater than last time

        var bufferedPercent = this.bufferedPercent();

        if (this.bufferedPercent_ !== bufferedPercent) {
          this.trigger('progress');
        }

        this.bufferedPercent_ = bufferedPercent;

        if (bufferedPercent === 1) {
          this.stopTrackingProgress();
        }
      }), 500);
    }
  }, {
    key: 'onDurationChange',
    value: function onDurationChange() {
      this.duration_ = this.duration();
    }
  }, {
    key: 'bufferedPercent',
    value: function bufferedPercent() {
      var bufferedDuration = 0,
          start = undefined,
          end = undefined;

      if (!this.duration_) {
        return 0;
      }

      var buffered = this.buffered();

      if (!buffered || !buffered.length) {
        buffered = _createTimeRange.createTimeRange(0, 0);
      }

      for (var i = 0; i < buffered.length; i++) {
        start = buffered.start(i);
        end = buffered.end(i);

        // buffered end can be bigger than duration by a very small fraction
        if (end > this.duration_) {
          end = this.duration_;
        }

        bufferedDuration += end - start;
      }

      return bufferedDuration / this.duration_;
    }
  }, {
    key: 'stopTrackingProgress',
    value: function stopTrackingProgress() {
      this.clearInterval(this.progressInterval);
    }
  }, {
    key: 'manualTimeUpdatesOn',

    /*! Time Tracking -------------------------------------------------------------- */
    value: function manualTimeUpdatesOn() {
      this.manualTimeUpdates = true;

      this.on('play', this.trackCurrentTime);
      this.on('pause', this.stopTrackingCurrentTime);
      // timeupdate is also called by .currentTime whenever current time is set

      // Watch for native timeupdate event only
      var onTimeUpdate = (function (_onTimeUpdate) {
        function onTimeUpdate(_x) {
          return _onTimeUpdate.apply(this, arguments);
        }

        onTimeUpdate.toString = function () {
          return _onTimeUpdate.toString();
        };

        return onTimeUpdate;
      })(function (e) {
        if (e.manuallyTriggered) return;

        this.off('timeupdate', onTimeUpdate);

        // Update known progress support for this playback technology
        this.featuresTimeupdateEvents = true;
        // Turn off manual progress tracking
        this.manualTimeUpdatesOff();
      });

      this.on('timeupdate', onTimeUpdate);
    }
  }, {
    key: 'manualTimeUpdatesOff',
    value: function manualTimeUpdatesOff() {
      this.manualTimeUpdates = false;
      this.stopTrackingCurrentTime();
      this.off('play', this.trackCurrentTime);
      this.off('pause', this.stopTrackingCurrentTime);
    }
  }, {
    key: 'trackCurrentTime',
    value: function trackCurrentTime() {
      if (this.currentTimeInterval) {
        this.stopTrackingCurrentTime();
      }
      this.currentTimeInterval = this.setInterval(function () {
        this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
      }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
    }
  }, {
    key: 'stopTrackingCurrentTime',

    // Turn off play progress tracking (when paused or dragging)
    value: function stopTrackingCurrentTime() {
      this.clearInterval(this.currentTimeInterval);

      // #1002 - if the video ends right before the next timeupdate would happen,
      // the progress bar won't make it all the way to the end
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      // Turn off any manual progress or timeupdate tracking
      if (this.manualProgress) {
        this.manualProgressOff();
      }

      if (this.manualTimeUpdates) {
        this.manualTimeUpdatesOff();
      }

      _get(Object.getPrototypeOf(Tech.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime() {
      // improve the accuracy of manual timeupdates
      if (this.manualTimeUpdates) {
        this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
      }
    }
  }, {
    key: 'initTextTrackListeners',
    value: function initTextTrackListeners() {
      var textTrackListChanges = Fn.bind(this, function () {
        this.trigger('texttrackchange');
      });

      var tracks = this.textTracks();

      if (!tracks) {
        return;
      }tracks.addEventListener('removetrack', textTrackListChanges);
      tracks.addEventListener('addtrack', textTrackListChanges);

      this.on('dispose', Fn.bind(this, function () {
        tracks.removeEventListener('removetrack', textTrackListChanges);
        tracks.removeEventListener('addtrack', textTrackListChanges);
      }));
    }
  }, {
    key: 'emulateTextTracks',
    value: function emulateTextTracks() {
      if (!_window2['default'].WebVTT && this.el().parentNode != null) {
        var script = _document2['default'].createElement('script');
        script.src = this.options_['vtt.js'] || '../node_modules/vtt.js/dist/vtt.js';
        this.el().parentNode.appendChild(script);
        _window2['default'].WebVTT = true;
      }

      var tracks = this.textTracks();
      if (!tracks) {
        return;
      }

      var textTracksChanges = function textTracksChanges() {
        var updateDisplay = Fn.bind(this, function () {
          this.trigger('texttrackchange');
        });

        this.trigger('texttrackchange');

        for (var i = 0; i < this.length; i++) {
          var track = this[i];
          track.removeEventListener('cuechange', updateDisplay);
          if (track.mode === 'showing') {
            track.addEventListener('cuechange', updateDisplay);
          }
        }
      };

      tracks.addEventListener('change', textTracksChanges);

      this.on('dispose', Fn.bind(this, function () {
        tracks.removeEventListener('change', textTracksChanges);
      }));
    }
  }, {
    key: 'textTracks',

    /**
     * Provide default methods for text tracks.
     *
     * Html5 tech overrides these.
     */

    value: function textTracks() {
      this.textTracks_ = this.textTracks_ || new _TextTrackList2['default']();
      return this.textTracks_;
    }
  }, {
    key: 'remoteTextTracks',
    value: function remoteTextTracks() {
      this.remoteTextTracks_ = this.remoteTextTracks_ || new _TextTrackList2['default']();
      return this.remoteTextTracks_;
    }
  }, {
    key: 'addTextTrack',
    value: function addTextTrack(kind, label, language) {
      if (!kind) {
        throw new Error('TextTrack kind is required but was not provided');
      }

      return createTrackHelper(this, kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack(options) {
      var track = createTrackHelper(this, options.kind, options.label, options.language, options);
      this.remoteTextTracks().addTrack_(track);
      return {
        track: track
      };
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      this.textTracks().removeTrack_(track);
      this.remoteTextTracks().removeTrack_(track);
    }
  }, {
    key: 'setPoster',

    /**
     * Provide a default setPoster method for techs
     *
     * Poster support for techs should be optional, so we don't want techs to
     * break if they don't have a way to set a poster.
     */
    value: function setPoster() {}
  }]);

  return Tech;
})(_Component3['default']);

/**
 * List of associated text tracks
 * @type {Array}
 * @private
 */
Tech.prototype.textTracks_;

var createTrackHelper = function createTrackHelper(self, kind, label, language) {
  var options = arguments[4] === undefined ? {} : arguments[4];

  var tracks = self.textTracks();

  options.kind = kind;

  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self;

  var track = new _TextTrack2['default'](options);
  tracks.addTrack_(track);

  return track;
};

Tech.prototype.featuresVolumeControl = true;

// Resizing plugins using request fullscreen reloads the plugin
Tech.prototype.featuresFullscreenResize = false;
Tech.prototype.featuresPlaybackRate = false;

// Optional events that we can manually mimic with timers
// currently not triggered by video-js-swf
Tech.prototype.featuresProgressEvents = false;
Tech.prototype.featuresTimeupdateEvents = false;

Tech.prototype.featuresNativeTextTracks = false;

/**
 * A functional mixin for techs that want to use the Source Handler pattern.
 *
 * ##### EXAMPLE:
 *
 *   Tech.withSourceHandlers.call(MyTech);
 *
 */
Tech.withSourceHandlers = function (_Tech) {
  /**
   * Register a source handler
   * Source handlers are scripts for handling specific formats.
   * The source handler pattern is used for adaptive formats (HLS, DASH) that
   * manually load video data and feed it into a Source Buffer (Media Source Extensions)
   * @param  {Function} handler  The source handler
   * @param  {Boolean}  first    Register it before any existing handlers
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /**
   * Return the first source handler that supports the source
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   * @param  {Object} source The source object
   * @returns {Object}       The first source handler that supports the source
   * @returns {null}         Null if no source handler is found
   */
  _Tech.selectSourceHandler = function (source) {
    var handlers = _Tech.sourceHandlers || [];
    var can = undefined;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /**
  * Check if the tech can support the given source
  * @param  {Object} srcObj  The source object
  * @return {String}         'probably', 'maybe', or '' (empty string)
  */
  _Tech.canPlaySource = function (srcObj) {
    var sh = _Tech.selectSourceHandler(srcObj);

    if (sh) {
      return sh.canHandleSource(srcObj);
    }

    return '';
  };

  /**
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   * @param {Object} source  A source object with src and type keys
   * @return {Tech} self
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        _log2['default'].error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    this.currentSource_ = source;
    this.sourceHandler_ = sh.handleSource(source, this);
    this.on('dispose', this.disposeSourceHandler);

    return this;
  };

  /**
   * Clean up any existing source handler
   */
  _Tech.prototype.disposeSourceHandler = function () {
    if (this.sourceHandler_ && this.sourceHandler_.dispose) {
      this.sourceHandler_.dispose();
    }
  };
};

_Component3['default'].registerComponent('Tech', Tech);
// Old name for Tech
_Component3['default'].registerComponent('MediaTechController', Tech);
exports['default'] = Tech;
module.exports = exports['default'];

},{"../component":45,"../tracks/text-track":103,"../tracks/text-track-list":101,"../utils/fn.js":107,"../utils/log.js":110,"../utils/time-ranges.js":113,"global/document":1,"global/window":2}],98:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_import);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist
 *
 * interface TextTrackCueList {
 *   readonly attribute unsigned long length;
 *   getter TextTrackCue (unsigned long index);
 *   TextTrackCue? getCueById(DOMString id);
 * };
 */

var TextTrackCueList = (function (_TextTrackCueList) {
  function TextTrackCueList(_x) {
    return _TextTrackCueList.apply(this, arguments);
  }

  TextTrackCueList.toString = function () {
    return _TextTrackCueList.toString();
  };

  return TextTrackCueList;
})(function (cues) {
  var list = this;

  if (browser.IS_IE8) {
    list = _document2['default'].createElement('custom');

    for (var prop in TextTrackCueList.prototype) {
      list[prop] = TextTrackCueList.prototype[prop];
    }
  }

  TextTrackCueList.prototype.setCues_.call(list, cues);

  Object.defineProperty(list, 'length', {
    get: function get() {
      return this.length_;
    }
  });

  if (browser.IS_IE8) {
    return list;
  }
});

TextTrackCueList.prototype.setCues_ = function (cues) {
  var oldLength = this.length || 0;
  var i = 0;
  var l = cues.length;

  this.cues_ = cues;
  this.length_ = cues.length;

  var defineProp = function defineProp(i) {
    if (!('' + i in this)) {
      Object.defineProperty(this, '' + i, {
        get: function get() {
          return this.cues_[i];
        }
      });
    }
  };

  if (oldLength < l) {
    i = oldLength;

    for (; i < l; i++) {
      defineProp.call(this, i);
    }
  }
};

TextTrackCueList.prototype.getCueById = function (id) {
  var result = null;
  for (var i = 0, l = this.length; i < l; i++) {
    var cue = this[i];
    if (cue.id === id) {
      result = cue;
      break;
    }
  }

  return result;
};

exports['default'] = TextTrackCueList;
module.exports = exports['default'];

},{"../utils/browser.js":104,"global/document":1}],99:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _Menu = _dereq_('../menu/menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _MenuItem = _dereq_('../menu/menu-item.js');

var _MenuItem2 = _interopRequireWildcard(_MenuItem);

var _MenuButton = _dereq_('../menu/menu-button.js');

var _MenuButton2 = _interopRequireWildcard(_MenuButton);

var _import = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * The component for displaying text track cues
 *
 * @constructor
 */

var TextTrackDisplay = (function (_Component) {
  function TextTrackDisplay(player, options, ready) {
    _classCallCheck(this, TextTrackDisplay);

    _get(Object.getPrototypeOf(TextTrackDisplay.prototype), 'constructor', this).call(this, player, options, ready);

    player.on('loadstart', Fn.bind(this, this.toggleDisplay));
    player.on('texttrackchange', Fn.bind(this, this.toggleDisplay));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(Fn.bind(this, function () {
      if (player.tech && player.tech.featuresNativeTextTracks) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', Fn.bind(this, this.updateDisplay));

      var tracks = player.options_.tracks || [];
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        this.player_.addRemoteTextTrack(track);
      }
    }));
  }

  _inherits(TextTrackDisplay, _Component);

  _createClass(TextTrackDisplay, [{
    key: 'toggleDisplay',
    value: function toggleDisplay() {
      if (this.player_.tech && this.player_.tech.featuresNativeTextTracks) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TextTrackDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-text-track-display'
      });
    }
  }, {
    key: 'clearDisplay',
    value: function clearDisplay() {
      if (typeof _window2['default'].WebVTT === 'function') {
        _window2['default'].WebVTT.processCues(_window2['default'], [], this.el_);
      }
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      var tracks = this.player_.textTracks();

      this.clearDisplay();

      if (!tracks) {
        return;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track.mode === 'showing') {
          this.updateForTrack(track);
        }
      }
    }
  }, {
    key: 'updateForTrack',
    value: function updateForTrack(track) {
      if (typeof _window2['default'].WebVTT !== 'function' || !track.activeCues) {
        return;
      }

      var overrides = this.player_.textTrackSettings.getValues();

      var cues = [];
      for (var _i = 0; _i < track.activeCues.length; _i++) {
        cues.push(track.activeCues[_i]);
      }

      _window2['default'].WebVTT.processCues(_window2['default'], track.activeCues, this.el_);

      var i = cues.length;
      while (i--) {
        var cueDiv = cues[i].displayState;
        if (overrides.color) {
          cueDiv.firstChild.style.color = overrides.color;
        }
        if (overrides.textOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
        }
        if (overrides.backgroundColor) {
          cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
        }
        if (overrides.backgroundOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
        }
        if (overrides.windowColor) {
          if (overrides.windowOpacity) {
            tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
          } else {
            cueDiv.style.backgroundColor = overrides.windowColor;
          }
        }
        if (overrides.edgeStyle) {
          if (overrides.edgeStyle === 'dropshadow') {
            cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
          } else if (overrides.edgeStyle === 'raised') {
            cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
          } else if (overrides.edgeStyle === 'depressed') {
            cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
          } else if (overrides.edgeStyle === 'uniform') {
            cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
          }
        }
        if (overrides.fontPercent && overrides.fontPercent !== 1) {
          var fontSize = _window2['default'].parseFloat(cueDiv.style.fontSize);
          cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
          cueDiv.style.height = 'auto';
          cueDiv.style.top = 'auto';
          cueDiv.style.bottom = '2px';
        }
        if (overrides.fontFamily && overrides.fontFamily !== 'default') {
          if (overrides.fontFamily === 'small-caps') {
            cueDiv.firstChild.style.fontVariant = 'small-caps';
          } else {
            cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
          }
        }
      }
    }
  }]);

  return TextTrackDisplay;
})(_Component3['default']);

// Add cue HTML to display
function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

function tryUpdateStyle(el, style, rule) {
  // some style changes will throw an error, particularly in IE8. Those should be noops.
  try {
    el.style[style] = rule;
  } catch (e) {}
}

_Component3['default'].registerComponent('TextTrackDisplay', TextTrackDisplay);
exports['default'] = TextTrackDisplay;
module.exports = exports['default'];

},{"../component":45,"../menu/menu-button.js":83,"../menu/menu-item.js":84,"../menu/menu.js":85,"../utils/fn.js":107,"global/document":1,"global/window":2}],100:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 *
 * enum TextTrackMode { "disabled",  "hidden",  "showing" };
 */
var TextTrackMode = {
  disabled: 'disabled',
  hidden: 'hidden',
  showing: 'showing'
};

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind
 *
 * enum TextTrackKind { "subtitles",  "captions",  "descriptions",  "chapters",  "metadata" };
 */
var TextTrackKind = {
  subtitles: 'subtitles',
  captions: 'captions',
  descriptions: 'descriptions',
  chapters: 'chapters',
  metadata: 'metadata'
};

exports.TextTrackMode = TextTrackMode;
exports.TextTrackKind = TextTrackKind;

},{}],101:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _EventEmitter = _dereq_('../event-emitter');

var _EventEmitter2 = _interopRequireWildcard(_EventEmitter);

var _import = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _import2 = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_import2);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist
 *
 * interface TextTrackList : EventTarget {
 *   readonly attribute unsigned long length;
 *   getter TextTrack (unsigned long index);
 *   TextTrack? getTrackById(DOMString id);
 *
 *   attribute EventHandler onchange;
 *   attribute EventHandler onaddtrack;
 *   attribute EventHandler onremovetrack;
 * };
 */
var TextTrackList = (function (_TextTrackList) {
  function TextTrackList(_x) {
    return _TextTrackList.apply(this, arguments);
  }

  TextTrackList.toString = function () {
    return _TextTrackList.toString();
  };

  return TextTrackList;
})(function (tracks) {
  var list = this;

  if (browser.IS_IE8) {
    list = _document2['default'].createElement('custom');

    for (var prop in TextTrackList.prototype) {
      list[prop] = TextTrackList.prototype[prop];
    }
  }

  tracks = tracks || [];
  list.tracks_ = [];

  Object.defineProperty(list, 'length', {
    get: function get() {
      return this.tracks_.length;
    }
  });

  for (var i = 0; i < tracks.length; i++) {
    list.addTrack_(tracks[i]);
  }

  if (browser.IS_IE8) {
    return list;
  }
});

TextTrackList.prototype = Object.create(_EventEmitter2['default'].prototype);
TextTrackList.prototype.constructor = TextTrackList;

/*
 * change - One or more tracks in the track list have been enabled or disabled.
 * addtrack - A track has been added to the track list.
 * removetrack - A track has been removed from the track list.
*/
TextTrackList.prototype.allowedEvents_ = {
  change: 'change',
  addtrack: 'addtrack',
  removetrack: 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var _event in TextTrackList.prototype.allowedEvents_) {
  TextTrackList.prototype['on' + _event] = null;
}

TextTrackList.prototype.addTrack_ = function (track) {
  var index = this.tracks_.length;
  if (!('' + index in this)) {
    Object.defineProperty(this, index, {
      get: function get() {
        return this.tracks_[index];
      }
    });
  }

  track.addEventListener('modechange', Fn.bind(this, function () {
    this.trigger('change');
  }));
  this.tracks_.push(track);

  this.trigger({
    type: 'addtrack',
    track: track
  });
};

TextTrackList.prototype.removeTrack_ = function (rtrack) {
  var result = null;
  var track = undefined;

  for (var i = 0, l = this.length; i < l; i++) {
    track = this[i];
    if (track === rtrack) {
      this.tracks_.splice(i, 1);
      break;
    }
  }

  this.trigger({
    type: 'removetrack',
    track: track
  });
};

TextTrackList.prototype.getTrackById = function (id) {
  var result = null;

  for (var i = 0, l = this.length; i < l; i++) {
    var track = this[i];
    if (track.id === id) {
      result = track;
      break;
    }
  }

  return result;
};

exports['default'] = TextTrackList;
module.exports = exports['default'];

},{"../event-emitter":78,"../utils/browser.js":104,"../utils/fn.js":107,"global/document":1}],102:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../utils/events.js');

var Events = _interopRequireWildcard(_import);

var _import2 = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_import2);

var _log = _dereq_('../utils/log.js');

var _log2 = _interopRequireWildcard(_log);

var _safeParseTuple3 = _dereq_('safe-json-parse/tuple');

var _safeParseTuple4 = _interopRequireWildcard(_safeParseTuple3);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var TextTrackSettings = (function (_Component) {
  function TextTrackSettings(player, options) {
    _classCallCheck(this, TextTrackSettings);

    _get(Object.getPrototypeOf(TextTrackSettings.prototype), 'constructor', this).call(this, player, options);
    this.hide();

    Events.on(this.el().querySelector('.vjs-done-button'), 'click', Fn.bind(this, function () {
      this.saveSettings();
      this.hide();
    }));

    Events.on(this.el().querySelector('.vjs-default-button'), 'click', Fn.bind(this, function () {
      this.el().querySelector('.vjs-fg-color > select').selectedIndex = 0;
      this.el().querySelector('.vjs-bg-color > select').selectedIndex = 0;
      this.el().querySelector('.window-color > select').selectedIndex = 0;
      this.el().querySelector('.vjs-text-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-bg-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-window-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-edge-style select').selectedIndex = 0;
      this.el().querySelector('.vjs-font-family select').selectedIndex = 0;
      this.el().querySelector('.vjs-font-percent select').selectedIndex = 2;
      this.updateDisplay();
    }));

    Events.on(this.el().querySelector('.vjs-fg-color > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-bg-color > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.window-color > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-text-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-bg-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-window-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-font-percent select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-edge-style select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-font-family select'), 'change', Fn.bind(this, this.updateDisplay));

    if (player.options().persistTextTrackSettings) {
      this.restoreSettings();
    }
  }

  _inherits(TextTrackSettings, _Component);

  _createClass(TextTrackSettings, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TextTrackSettings.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-caption-settings vjs-modal-overlay',
        innerHTML: captionOptionsMenuTemplate()
      });
    }
  }, {
    key: 'getValues',
    value: function getValues() {
      var el = this.el();

      var textEdge = getSelectedOptionValue(el.querySelector('.vjs-edge-style select'));
      var fontFamily = getSelectedOptionValue(el.querySelector('.vjs-font-family select'));
      var fgColor = getSelectedOptionValue(el.querySelector('.vjs-fg-color > select'));
      var textOpacity = getSelectedOptionValue(el.querySelector('.vjs-text-opacity > select'));
      var bgColor = getSelectedOptionValue(el.querySelector('.vjs-bg-color > select'));
      var bgOpacity = getSelectedOptionValue(el.querySelector('.vjs-bg-opacity > select'));
      var windowColor = getSelectedOptionValue(el.querySelector('.window-color > select'));
      var windowOpacity = getSelectedOptionValue(el.querySelector('.vjs-window-opacity > select'));
      var fontPercent = _window2['default'].parseFloat(getSelectedOptionValue(el.querySelector('.vjs-font-percent > select')));

      var result = {
        backgroundOpacity: bgOpacity,
        textOpacity: textOpacity,
        windowOpacity: windowOpacity,
        edgeStyle: textEdge,
        fontFamily: fontFamily,
        color: fgColor,
        backgroundColor: bgColor,
        windowColor: windowColor,
        fontPercent: fontPercent
      };
      for (var _name in result) {
        if (result[_name] === '' || result[_name] === 'none' || _name === 'fontPercent' && result[_name] === 1) {
          delete result[_name];
        }
      }
      return result;
    }
  }, {
    key: 'setValues',
    value: function setValues(values) {
      var el = this.el();

      setSelectedOption(el.querySelector('.vjs-edge-style select'), values.edgeStyle);
      setSelectedOption(el.querySelector('.vjs-font-family select'), values.fontFamily);
      setSelectedOption(el.querySelector('.vjs-fg-color > select'), values.color);
      setSelectedOption(el.querySelector('.vjs-text-opacity > select'), values.textOpacity);
      setSelectedOption(el.querySelector('.vjs-bg-color > select'), values.backgroundColor);
      setSelectedOption(el.querySelector('.vjs-bg-opacity > select'), values.backgroundOpacity);
      setSelectedOption(el.querySelector('.window-color > select'), values.windowColor);
      setSelectedOption(el.querySelector('.vjs-window-opacity > select'), values.windowOpacity);

      var fontPercent = values.fontPercent;

      if (fontPercent) {
        fontPercent = fontPercent.toFixed(2);
      }

      setSelectedOption(el.querySelector('.vjs-font-percent > select'), fontPercent);
    }
  }, {
    key: 'restoreSettings',
    value: function restoreSettings() {
      var _safeParseTuple = _safeParseTuple4['default'](_window2['default'].localStorage.getItem('vjs-text-track-settings'));

      var _safeParseTuple2 = _slicedToArray(_safeParseTuple, 2);

      var err = _safeParseTuple2[0];
      var values = _safeParseTuple2[1];

      if (err) {
        _log2['default'].error(err);
      }

      if (values) {
        this.setValues(values);
      }
    }
  }, {
    key: 'saveSettings',
    value: function saveSettings() {
      if (!this.player_.options().persistTextTrackSettings) {
        return;
      }

      var values = this.getValues();
      try {
        if (Object.getOwnPropertyNames(values).length > 0) {
          _window2['default'].localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));
        } else {
          _window2['default'].localStorage.removeItem('vjs-text-track-settings');
        }
      } catch (e) {}
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      var ttDisplay = this.player_.getChild('textTrackDisplay');
      if (ttDisplay) {
        ttDisplay.updateDisplay();
      }
    }
  }]);

  return TextTrackSettings;
})(_Component3['default']);

_Component3['default'].registerComponent('TextTrackSettings', TextTrackSettings);

function getSelectedOptionValue(target) {
  var selectedOption = undefined;
  // not all browsers support selectedOptions, so, fallback to options
  if (target.selectedOptions) {
    selectedOption = target.selectedOptions[0];
  } else if (target.options) {
    selectedOption = target.options[target.options.selectedIndex];
  }

  return selectedOption.value;
}

function setSelectedOption(target, value) {
  if (!value) {
    return;
  }

  var i = undefined;
  for (i = 0; i < target.options.length; i++) {
    var option = target.options[i];
    if (option.value === value) {
      break;
    }
  }

  target.selectedIndex = i;
}

function captionOptionsMenuTemplate() {
  var template = '<div class="vjs-tracksettings">\n      <div class="vjs-tracksettings-colors">\n        <div class="vjs-fg-color vjs-tracksetting">\n            <label class="vjs-label">Foreground</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-text-opacity vjs-opacity">\n              <select>\n                <option value="">---</option>\n                <option value="1">Opaque</option>\n                <option value="0.5">Semi-Opaque</option>\n              </select>\n            </span>\n        </div> <!-- vjs-fg-color -->\n        <div class="vjs-bg-color vjs-tracksetting">\n            <label class="vjs-label">Background</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-bg-opacity vjs-opacity">\n                <select>\n                  <option value="">---</option>\n                  <option value="1">Opaque</option>\n                  <option value="0.5">Semi-Transparent</option>\n                  <option value="0">Transparent</option>\n                </select>\n            </span>\n        </div> <!-- vjs-bg-color -->\n        <div class="window-color vjs-tracksetting">\n            <label class="vjs-label">Window</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-window-opacity vjs-opacity">\n                <select>\n                  <option value="">---</option>\n                  <option value="1">Opaque</option>\n                  <option value="0.5">Semi-Transparent</option>\n                  <option value="0">Transparent</option>\n                </select>\n            </span>\n        </div> <!-- vjs-window-color -->\n      </div> <!-- vjs-tracksettings -->\n      <div class="vjs-tracksettings-font">\n        <div class="vjs-font-percent vjs-tracksetting">\n          <label class="vjs-label">Font Size</label>\n          <select>\n            <option value="0.50">50%</option>\n            <option value="0.75">75%</option>\n            <option value="1.00" selected>100%</option>\n            <option value="1.25">125%</option>\n            <option value="1.50">150%</option>\n            <option value="1.75">175%</option>\n            <option value="2.00">200%</option>\n            <option value="3.00">300%</option>\n            <option value="4.00">400%</option>\n          </select>\n        </div> <!-- vjs-font-percent -->\n        <div class="vjs-edge-style vjs-tracksetting">\n          <label class="vjs-label">Text Edge Style</label>\n          <select>\n            <option value="none">None</option>\n            <option value="raised">Raised</option>\n            <option value="depressed">Depressed</option>\n            <option value="uniform">Uniform</option>\n            <option value="dropshadow">Dropshadow</option>\n          </select>\n        </div> <!-- vjs-edge-style -->\n        <div class="vjs-font-family vjs-tracksetting">\n          <label class="vjs-label">Font Family</label>\n          <select>\n            <option value="">Default</option>\n            <option value="monospaceSerif">Monospace Serif</option>\n            <option value="proportionalSerif">Proportional Serif</option>\n            <option value="monospaceSansSerif">Monospace Sans-Serif</option>\n            <option value="proportionalSansSerif">Proportional Sans-Serif</option>\n            <option value="casual">Casual</option>\n            <option value="script">Script</option>\n            <option value="small-caps">Small Caps</option>\n          </select>\n        </div> <!-- vjs-font-family -->\n      </div>\n    </div>\n    <div class="vjs-tracksettings-controls">\n      <button class="vjs-default-button">Defaults</button>\n      <button class="vjs-done-button">Done</button>\n    </div>';

  return template;
}

exports['default'] = TextTrackSettings;
module.exports = exports['default'];

},{"../component":45,"../utils/events.js":106,"../utils/fn.js":107,"../utils/log.js":110,"global/window":2,"safe-json-parse/tuple":42}],103:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackCueList = _dereq_('./text-track-cue-list');

var _TextTrackCueList2 = _interopRequireWildcard(_TextTrackCueList);

var _import = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_import);

var _import2 = _dereq_('../utils/guid.js');

var Guid = _interopRequireWildcard(_import2);

var _import3 = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_import3);

var _import4 = _dereq_('./text-track-enums');

var TextTrackEnum = _interopRequireWildcard(_import4);

var _log = _dereq_('../utils/log.js');

var _log2 = _interopRequireWildcard(_log);

var _EventEmitter = _dereq_('../event-emitter');

var _EventEmitter2 = _interopRequireWildcard(_EventEmitter);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _XHR = _dereq_('../xhr.js');

var _XHR2 = _interopRequireWildcard(_XHR);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack
 *
 * interface TextTrack : EventTarget {
 *   readonly attribute TextTrackKind kind;
 *   readonly attribute DOMString label;
 *   readonly attribute DOMString language;
 *
 *   readonly attribute DOMString id;
 *   readonly attribute DOMString inBandMetadataTrackDispatchType;
 *
 *   attribute TextTrackMode mode;
 *
 *   readonly attribute TextTrackCueList? cues;
 *   readonly attribute TextTrackCueList? activeCues;
 *
 *   void addCue(TextTrackCue cue);
 *   void removeCue(TextTrackCue cue);
 *
 *   attribute EventHandler oncuechange;
 * };
 */
var TextTrack = (function (_TextTrack) {
  function TextTrack() {
    return _TextTrack.apply(this, arguments);
  }

  TextTrack.toString = function () {
    return _TextTrack.toString();
  };

  return TextTrack;
})(function () {
  var options = arguments[0] === undefined ? {} : arguments[0];

  if (!options.tech) {
    throw new Error('A tech was not provided.');
  }

  var tt = this;
  if (browser.IS_IE8) {
    tt = _document2['default'].createElement('custom');

    for (var prop in TextTrack.prototype) {
      tt[prop] = TextTrack.prototype[prop];
    }
  }

  tt.tech_ = options.tech;

  var mode = TextTrackEnum.TextTrackMode[options.mode] || 'disabled';
  var kind = TextTrackEnum.TextTrackKind[options.kind] || 'subtitles';
  var label = options.label || '';
  var language = options.language || options.srclang || '';
  var id = options.id || 'vjs_text_track_' + Guid.newGUID();

  if (kind === 'metadata' || kind === 'chapters') {
    mode = 'hidden';
  }

  tt.cues_ = [];
  tt.activeCues_ = [];

  var cues = new _TextTrackCueList2['default'](tt.cues_);
  var activeCues = new _TextTrackCueList2['default'](tt.activeCues_);

  var changed = false;
  var timeupdateHandler = Fn.bind(tt, function () {
    this.activeCues;
    if (changed) {
      this.trigger('cuechange');
      changed = false;
    }
  });
  if (mode !== 'disabled') {
    tt.tech_.on('timeupdate', timeupdateHandler);
  }

  Object.defineProperty(tt, 'kind', {
    get: function get() {
      return kind;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'label', {
    get: function get() {
      return label;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'language', {
    get: function get() {
      return language;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'id', {
    get: function get() {
      return id;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'mode', {
    get: function get() {
      return mode;
    },
    set: function set(newMode) {
      if (!TextTrackEnum.TextTrackMode[newMode]) {
        return;
      }
      mode = newMode;
      if (mode === 'showing') {
        this.tech_.on('timeupdate', timeupdateHandler);
      }
      this.trigger('modechange');
    }
  });

  Object.defineProperty(tt, 'cues', {
    get: function get() {
      if (!this.loaded_) {
        return null;
      }

      return cues;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'activeCues', {
    get: function get() {
      if (!this.loaded_) {
        return null;
      }

      if (this.cues.length === 0) {
        return activeCues; // nothing to do
      }

      var ct = this.tech_.currentTime();
      var active = [];

      for (var i = 0, l = this.cues.length; i < l; i++) {
        var cue = this.cues[i];
        if (cue.startTime <= ct && cue.endTime >= ct) {
          active.push(cue);
        } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
          active.push(cue);
        }
      }

      changed = false;

      if (active.length !== this.activeCues_.length) {
        changed = true;
      } else {
        for (var i = 0; i < active.length; i++) {
          if (indexOf.call(this.activeCues_, active[i]) === -1) {
            changed = true;
          }
        }
      }

      this.activeCues_ = active;
      activeCues.setCues_(this.activeCues_);

      return activeCues;
    },
    set: Function.prototype
  });

  if (options.src) {
    loadTrack(options.src, tt);
  } else {
    tt.loaded_ = true;
  }

  if (browser.IS_IE8) {
    return tt;
  }
});

TextTrack.prototype = Object.create(_EventEmitter2['default'].prototype);
TextTrack.prototype.constructor = TextTrack;

/*
 * cuechange - One or more cues in the track have become active or stopped being active.
 */
TextTrack.prototype.allowedEvents_ = {
  cuechange: 'cuechange'
};

TextTrack.prototype.addCue = function (cue) {
  var tracks = this.tech_.textTracks();

  if (tracks) {
    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }
  }

  this.cues_.push(cue);
  this.cues.setCues_(this.cues_);
};

TextTrack.prototype.removeCue = function (removeCue) {
  var removed = false;

  for (var i = 0, l = this.cues_.length; i < l; i++) {
    var cue = this.cues_[i];
    if (cue === removeCue) {
      this.cues_.splice(i, 1);
      removed = true;
    }
  }

  if (removed) {
    this.cues.setCues_(this.cues_);
  }
};

/*
 * Downloading stuff happens below this point
 */
var parseCues = (function (_parseCues) {
  function parseCues(_x, _x2) {
    return _parseCues.apply(this, arguments);
  }

  parseCues.toString = function () {
    return _parseCues.toString();
  };

  return parseCues;
})(function (srcContent, track) {
  if (typeof _window2['default'].WebVTT !== 'function') {
    //try again a bit later
    return _window2['default'].setTimeout(function () {
      parseCues(srcContent, track);
    }, 25);
  }

  var parser = new _window2['default'].WebVTT.Parser(_window2['default'], _window2['default'].vttjs, _window2['default'].WebVTT.StringDecoder());

  parser.oncue = function (cue) {
    track.addCue(cue);
  };
  parser.onparsingerror = function (error) {
    _log2['default'].error(error);
  };

  parser.parse(srcContent);
  parser.flush();
});

var loadTrack = function loadTrack(src, track) {
  _XHR2['default'](src, Fn.bind(this, function (err, response, responseBody) {
    if (err) {
      return _log2['default'].error(err);
    }

    track.loaded_ = true;
    parseCues(responseBody, track);
  }));
};

var indexOf = function indexOf(searchElement, fromIndex) {
  if (this == null) {
    throw new TypeError('"this" is null or not defined');
  }

  var O = Object(this);

  var len = O.length >>> 0;

  if (len === 0) {
    return -1;
  }

  var n = +fromIndex || 0;

  if (Math.abs(n) === Infinity) {
    n = 0;
  }

  if (n >= len) {
    return -1;
  }

  var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

  while (k < len) {
    if (k in O && O[k] === searchElement) {
      return k;
    }
    k++;
  }
  return -1;
};

exports['default'] = TextTrack;
module.exports = exports['default'];

},{"../event-emitter":78,"../utils/browser.js":104,"../utils/fn.js":107,"../utils/guid.js":109,"../utils/log.js":110,"../xhr.js":117,"./text-track-cue-list":98,"./text-track-enums":100,"global/document":1,"global/window":2}],104:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var USER_AGENT = _window2['default'].navigator.userAgent;

/**
 * Device is an iPhone
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPHONE = /iPhone/i.test(USER_AGENT);
exports.IS_IPHONE = IS_IPHONE;
var IS_IPAD = /iPad/i.test(USER_AGENT);
exports.IS_IPAD = IS_IPAD;
var IS_IPOD = /iPod/i.test(USER_AGENT);
exports.IS_IPOD = IS_IPOD;
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

exports.IS_IOS = IS_IOS;
var IOS_VERSION = (function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);
  if (match && match[1]) {
    return match[1];
  }
})();

exports.IOS_VERSION = IOS_VERSION;
var IS_ANDROID = /Android/i.test(USER_AGENT);
exports.IS_ANDROID = IS_ANDROID;
var ANDROID_VERSION = (function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
      major,
      minor;

  if (!match) {
    return null;
  }

  major = match[1] && parseFloat(match[1]);
  minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  } else {
    return null;
  }
})();
exports.ANDROID_VERSION = ANDROID_VERSION;
// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;

exports.IS_OLD_ANDROID = IS_OLD_ANDROID;
var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
exports.IS_FIREFOX = IS_FIREFOX;
var IS_CHROME = /Chrome/i.test(USER_AGENT);
exports.IS_CHROME = IS_CHROME;
var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);

exports.IS_IE8 = IS_IE8;
var TOUCH_ENABLED = !!('ontouchstart' in _window2['default'] || _window2['default'].DocumentTouch && _document2['default'] instanceof _window2['default'].DocumentTouch);
exports.TOUCH_ENABLED = TOUCH_ENABLED;
var BACKGROUND_SIZE_SUPPORTED = ('backgroundSize' in _document2['default'].createElement('video').style);
exports.BACKGROUND_SIZE_SUPPORTED = BACKGROUND_SIZE_SUPPORTED;

},{"global/document":1,"global/window":2}],105:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _import = _dereq_('./guid.js');

var Guid = _interopRequireWildcard(_import);

var _roundFloat = _dereq_('./round-float.js');

var _roundFloat2 = _interopRequireWildcard(_roundFloat);

/**
 * Shorthand for document.getElementById()
 * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
 * @param  {String} id  Element ID
 * @return {Element}    Element with supplied ID
 * @private
 */
var el = function el(id) {
  if (id.indexOf('#') === 0) {
    id = id.slice(1);
  }

  return _document2['default'].getElementById(id);
};

exports.el = el;
/**
 * Creates an element and applies properties.
 * @param  {String=} tagName    Name of tag to be created.
 * @param  {Object=} properties Element properties to be applied.
 * @return {Element}
 * @private
 */
var createEl = function createEl() {
  var tagName = arguments[0] === undefined ? 'div' : arguments[0];
  var properties = arguments[1] === undefined ? {} : arguments[1];

  var el = _document2['default'].createElement(tagName);

  Object.getOwnPropertyNames(properties).forEach(function (propName) {
    var val = properties[propName];

    // Not remembering why we were checking for dash
    // but using setAttribute means you have to use getAttribute

    // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.
    // The additional check for "role" is because the default method for adding attributes does not
    // add the attribute "role". My guess is because it's not a valid attribute in some namespaces, although
    // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.
    // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.
    if (propName.indexOf('aria-') !== -1 || propName === 'role') {
      el.setAttribute(propName, val);
    } else {
      el[propName] = val;
    }
  });

  return el;
};

exports.createEl = createEl;
/**
 * Insert an element as the first child node of another
 * @param  {Element} child   Element to insert
 * @param  {[type]} parent Element to insert child into
 * @private
 */
var insertFirst = function insertFirst(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
};

exports.insertFirst = insertFirst;
/**
 * Element Data Store. Allows for binding data to an element without putting it directly on the element.
 * Ex. Event listeners are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 * @type {Object}
 * @private
 */
var cache = {};

exports.cache = cache;
/**
 * Unique attribute name to store an element's guid in
 * @type {String}
 * @constant
 * @private
 */
var expando = 'vdata' + new Date().getTime();

exports.expando = expando;
/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
var getData = function getData(el) {
  var id = el[expando];
  if (!id) {
    id = el[expando] = Guid.newGUID();
  }
  if (!cache[id]) {
    cache[id] = {};
  }
  return cache[id];
};

exports.getData = getData;
/**
 * Returns whether or not an element has cached data
 * @param  {Element} el A dom element
 * @return {Boolean}
 * @private
 */
var hasData = function hasData(el) {
  var id = el[expando];

  if (!id) {
    return false;
  }

  return !!Object.getOwnPropertyNames(cache[id]).length;
};

exports.hasData = hasData;
/**
 * Delete data for the element from the cache and the guid attr from getElementById
 * @param  {Element} el Remove data for an element
 * @private
 */
var removeData = function removeData(el) {
  var id = el[expando];
  if (!id) {
    return;
  }
  // Remove all stored data
  // Changed to = null
  // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
  // cache[id] = null;
  delete cache[id];

  // Remove the expando property from the DOM node
  try {
    delete el[expando];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(expando);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[expando] = null;
    }
  }
};

exports.removeData = removeData;
/**
 * Check if an element has a CSS class
 * @param {Element} element Element to check
 * @param {String} classToCheck Classname to check
 * @private
 */
var hasClass = function hasClass(element, classToCheck) {
  return (' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1;
};

exports.hasClass = hasClass;
/**
 * Add a CSS class name to an element
 * @param {Element} element    Element to add class name to
 * @param {String} classToAdd Classname to add
 * @private
 */
var addClass = function addClass(element, classToAdd) {
  if (!hasClass(element, classToAdd)) {
    element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
  }
};

exports.addClass = addClass;
/**
 * Remove a CSS class name from an element
 * @param {Element} element    Element to remove from class name
 * @param {String} classToAdd Classname to remove
 * @private
 */
var removeClass = function removeClass(element, classToRemove) {
  if (!hasClass(element, classToRemove)) {
    return;
  }

  var classNames = element.className.split(' ');

  // no arr.indexOf in ie8, and we don't want to add a big shim
  for (var i = classNames.length - 1; i >= 0; i--) {
    if (classNames[i] === classToRemove) {
      classNames.splice(i, 1);
    }
  }

  element.className = classNames.join(' ');
};

exports.removeClass = removeClass;
/**
 * Apply attributes to an HTML element.
 * @param  {Element} el         Target element.
 * @param  {Object=} attributes Element attributes to be applied.
 * @private
 */
var setElementAttributes = function setElementAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    var attrValue = attributes[attrName];

    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
};

exports.setElementAttributes = setElementAttributes;
/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 * @param  {Element} tag Element from which to get tag attributes
 * @return {Object}
 * @private
 */
var getElementAttributes = function getElementAttributes(tag) {
  var obj, knownBooleans, attrs, attrName, attrVal;

  obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      attrName = attrs[i].name;
      attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
};

exports.getElementAttributes = getElementAttributes;
/**
 * Get the computed style value for an element
 * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/
 * @param  {Element} el        Element to get style value for
 * @param  {String} strCssRule Style name
 * @return {String}            Style value
 * @private
 */
var getComputedDimension = function getComputedDimension(el, strCssRule) {
  var strValue = '';
  if (_document2['default'].defaultView && _document2['default'].defaultView.getComputedStyle) {
    strValue = _document2['default'].defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);
  } else if (el.currentStyle) {
    // IE8 Width/Height support
    var upperCasedRule = strCssRule.substr(0, 1).toUpperCase() + strCssRule.substr(1);
    strValue = el['client' + upperCasedRule] + 'px';
  }
  return strValue;
};

exports.getComputedDimension = getComputedDimension;
// Attempt to block the ability to select text while dragging controls
var blockTextSelection = function blockTextSelection() {
  _document2['default'].body.focus();
  _document2['default'].onselectstart = function () {
    return false;
  };
};
exports.blockTextSelection = blockTextSelection;
// Turn off text selection blocking
var unblockTextSelection = function unblockTextSelection() {
  _document2['default'].onselectstart = function () {
    return true;
  };
};

exports.unblockTextSelection = unblockTextSelection;
// Offset Left
// getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
var findPosition = function findPosition(el) {
  var box = undefined;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = _document2['default'].documentElement;
  var body = _document2['default'].body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = _window2['default'].pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = _window2['default'].pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: _roundFloat2['default'](left),
    top: _roundFloat2['default'](top)
  };
};
exports.findPosition = findPosition;

},{"./guid.js":109,"./round-float.js":112,"global/document":1,"global/window":2}],106:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 * @param  {Element|Object}   elem Element or object to bind listeners to
 * @param  {String|Array}   type Type of event to bind to.
 * @param  {Function} fn   Event listener.
 */
exports.on = on;

/**
 * Removes event listeners from an element
 * @param  {Element|Object}   elem Object to remove listeners from
 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
 */
exports.off = off;

/**
 * Trigger an event for an element
 * @param  {Element|Object}      elem  Element to trigger an event on
 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
 */
exports.trigger = trigger;

/**
 * Trigger a listener only once for an event
 * @param  {Element|Object}   elem Element or object to
 * @param  {String|Array}   type
 * @param  {Function} fn
 */
exports.one = one;

/**
 * Fix a native event to have standard property values
 * @param  {Object} event Event object to fix
 * @return {Object}
 * @private
 */
exports.fixEvent = fixEvent;
/**
 * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 */

var _import = _dereq_('./dom.js');

var Dom = _interopRequireWildcard(_import);

var _import2 = _dereq_('./guid.js');

var Guid = _interopRequireWildcard(_import2);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

function on(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = Dom.getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) data.handlers = {};

  if (!data.handlers[type]) data.handlers[type] = [];

  if (!fn.guid) fn.guid = Guid.newGUID();

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event) {

      if (data.disabled) return;
      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            handlersCopy[m].call(elem, event);
          }
        }
      }
    };
  }

  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      elem.addEventListener(type, data.dispatcher, false);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
}

function off(elem, type, fn) {
  // Don't want to add a cache object through getData if not needed
  if (!Dom.hasData(elem)) {
    return;
  }var data = Dom.getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Array.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(t) {
    data.handlers[t] = [];
    _cleanUpEvents(elem, t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) {
      removeType(t);
    }return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) {
    return;
  } // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  _cleanUpEvents(elem, type);
}

function trigger(elem, event) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasData first.
  var elemData = Dom.hasData(elem) ? Dom.getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  }
  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
    trigger(parent, event);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = Dom.getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
}

function one(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = (function (_func) {
    function func() {
      return _func.apply(this, arguments);
    }

    func.toString = function () {
      return _func.toString();
    };

    return func;
  })(function () {
    off(elem, type, func);
    fn.apply(this, arguments);
  });
  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || Guid.newGUID();
  on(elem, type, func);
}

function fixEvent(event) {

  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || _window2['default'].event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || _document2['default'];
    }

    // Handle which other element the event is related to
    event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX != null) {
      var doc = _document2['default'].documentElement,
          body = _document2['default'].body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button != null) {
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
    }
  }

  // Returns fixed-up instance
  return event;
}

/**
 * Clean up the listener cache and dispatchers
 * @param  {Element|Object} elem Element to clean up
 * @param  {String} type Type of event to clean up
 * @private
 */
function _cleanUpEvents(elem, type) {
  var data = Dom.getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;

    // data.handlers = null;
    // data.dispatcher = null;
    // data.disabled = null;
  }

  // Finally remove the expando if there is no data left
  if (Object.getOwnPropertyNames(data).length <= 0) {
    Dom.removeData(elem);
  }
}

/**
 * Loops through an array of event types and calls the requested method for each type.
 * @param  {Function} fn   The event method we want to use.
 * @param  {Element|Object} elem Element or object to bind listeners to
 * @param  {String}   type Type of event to bind to.
 * @param  {Function} callback   Event listener.
 * @private
 */
function _handleMultipleEvents(fn, elem, types, callback) {
  types.forEach(function (type) {
    //Call the event method for each one of the types
    fn(elem, type, callback);
  });
}

},{"./dom.js":105,"./guid.js":109,"global/document":1,"global/window":2}],107:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _newGUID = _dereq_('./guid.js');

/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
   It also stores a unique id on the function so it can be easily removed from events
 * @param  {*}   context The object to bind as scope
 * @param  {Function} fn      The function to be bound to a scope
 * @param  {Number=}   uid     An optional unique ID for the function to be set
 * @return {Function}
 * @private
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = _newGUID.newGUID();
  }

  // Create the new function that changes the context
  var ret = function ret() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  ret.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return ret;
};
exports.bind = bind;

},{"./guid.js":109}],108:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 * @param  {Number} seconds Number of seconds to be turned into a string
 * @param  {Number} guide   Number (in seconds) to model the string after
 * @return {String}         Time formatted as H:MM:SS or M:SS
 * @private
 */
function formatTime(seconds) {
  var guide = arguments[1] === undefined ? seconds : arguments[1];
  return (function () {
    var s = Math.floor(seconds % 60);
    var m = Math.floor(seconds / 60 % 60);
    var h = Math.floor(seconds / 3600);
    var gm = Math.floor(guide / 60 % 60);
    var gh = Math.floor(guide / 3600);

    // handle invalid times
    if (isNaN(seconds) || seconds === Infinity) {
      // '-' is false for all relational operators (e.g. <, >=) so this setting
      // will add the minimum number of fields specified by the guide
      h = m = s = '-';
    }

    // Check if we need to show hours
    h = h > 0 || gh > 0 ? h + ':' : '';

    // If hours are showing, we may need to add a leading zero.
    // Always show at least one digit of minutes.
    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

    // Check if leading zero is need for seconds
    s = s < 10 ? '0' + s : s;

    return h + m + s;
  })();
}

exports['default'] = formatTime;
module.exports = exports['default'];

},{}],109:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Get the next unique ID
 */
exports.newGUID = newGUID;
/**
 * Unique ID for an element or function
 * @type {Number}
 * @private
 */
var _guid = 1;
function newGUID() {
  return _guid++;
}

},{}],110:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

/**
 * Log plain debug messages
 */
var log = function log() {
  _logType(null, arguments);
};

/**
 * Keep a history of log messages
 * @type {Array}
 */
log.history = [];

/**
 * Log error messages
 */
log.error = function () {
  _logType('error', arguments);
};

/**
 * Log warning messages
 */
log.warn = function () {
  _logType('warn', arguments);
};

/**
 * Log messages to the console and history based on the type of message
 *
 * @param  {String} type The type of message, or `null` for `log`
 * @param  {[type]} args The args to be passed to the log
 * @private
 */
function _logType(type, args) {
  // convert args to an array to get array functions
  var argsArray = Array.prototype.slice.call(args);
  // if there's no console then don't try to output messages
  // they will still be stored in log.history
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  var noop = function noop() {};

  var console = _window2['default'].console || {
    log: noop,
    warn: noop,
    error: noop
  };

  if (type) {
    // add the type to the front of the message
    argsArray.unshift(type.toUpperCase() + ':');
  } else {
    // default to log with no prefix
    type = 'log';
  }

  // add to history
  log.history.push(argsArray);

  // add console prefix after adding to history
  argsArray.unshift('VIDEOJS:');

  // call appropriate log function
  if (console[type].apply) {
    console[type].apply(console, argsArray);
  } else {
    // ie8 doesn't allow error.apply, but it will just join() the array anyway
    console[type](argsArray.join(' '));
  }
}

exports['default'] = log;
module.exports = exports['default'];

},{"global/window":2}],111:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

/**
 * Merge two options objects, recursively merging any plain object properties as
 * well.  Previously `deepMerge`
 *
 * @param  {Object} obj1 Object to override values in
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object -- obj1 and obj2 will be untouched
 */
exports['default'] = mergeOptions;

var _merge = _dereq_('lodash.merge');

var _merge2 = _interopRequireWildcard(_merge);

var _isPlainObject = _dereq_('lodash.isplainobject');

var _isPlainObject2 = _interopRequireWildcard(_isPlainObject);

var _cloneDeep = _dereq_('lodash.clonedeep');

var _cloneDeep2 = _interopRequireWildcard(_cloneDeep);

function mergeOptions(obj1) {
  // Copy to ensure we're not modifying the defaults somewhere
  obj1 = _cloneDeep2['default'](obj1, function (value) {
    if (!_isPlainObject2['default'](value)) {
      return value;
    }
  });

  // Allow for infinite additional object args to merge
  Array.prototype.slice.call(arguments, 1).forEach(function (argObj) {
    // Recursively merge only plain objects
    // All other values will be directly copied
    _merge2['default'](obj1, argObj, function (a, b) {
      if (!_isPlainObject2['default'](a) || !_isPlainObject2['default'](b)) {
        return b;
      }
    });
  });

  return obj1;
}

module.exports = exports['default'];

},{"lodash.clonedeep":4,"lodash.isplainobject":16,"lodash.merge":22}],112:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Should round off a number to a decimal place
 * @param  {Number} num Number to round
 * @param  {Number} dec Number of decimal places to round to
 * @return {Number}     Rounded number
 * @private
 */
var roundFloat = function roundFloat(num) {
  var dec = arguments[1] === undefined ? 0 : arguments[1];

  return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
};

exports["default"] = roundFloat;
module.exports = exports["default"];

},{}],113:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Should create a fake TimeRange object
 * Mimics an HTML5 time range instance, which has functions that
 * return the start and end times for a range
 * TimeRanges are returned by the buffered() method
 * @param  {Number} start Start time in seconds
 * @param  {Number} end   End time in seconds
 * @return {Object}       Fake TimeRange object
 * @private
 */
exports.createTimeRange = createTimeRange;

function createTimeRange(start, end) {
  return {
    length: 1,
    start: (function (_start) {
      function start() {
        return _start.apply(this, arguments);
      }

      start.toString = function () {
        return _start.toString();
      };

      return start;
    })(function () {
      return start;
    }),
    end: (function (_end) {
      function end() {
        return _end.apply(this, arguments);
      }

      end.toString = function () {
        return _end.toString();
      };

      return end;
    })(function () {
      return end;
    })
  };
}

},{}],114:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Uppercase the first letter of a string
 * @param  {String} string String to be uppercased
 * @return {String}
 * @private
 */
function toTitleCase(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

exports["default"] = toTitleCase;
module.exports = exports["default"];

},{}],115:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * Resolve and parse the elements of a URL
 * @param  {String} url The url to parse
 * @return {Object}     An object of url details
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = _document2['default'].createElement('a');
  a.href = url;

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = undefined;
  if (addToBody) {
    div = _document2['default'].createElement('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    _document2['default'].body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }
  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (addToBody) {
    _document2['default'].body.removeChild(div);
  }

  return details;
};

exports.parseUrl = parseUrl;
/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 * @param  {String} url URL to make absolute
 * @return {String}     Absolute URL
 * @private
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    var div = _document2['default'].createElement('div');
    div.innerHTML = '<a href="' + url + '">x</a>';
    url = div.firstChild.href;
  }

  return url;
};

exports.getAbsoluteURL = getAbsoluteURL;
/**
 * Returns the extension of the passed file name. It will return an empty string if you pass an invalid path
 *
 * @param {String}    path    The fileName path like '/path/to/file.mp4'
 * @returns {String}          The extension in lower case or an empty string if no extension could be found.
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};
exports.getFileExtension = getFileExtension;

},{"global/document":1}],116:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _assign = _dereq_('object.assign');

var _assign2 = _interopRequireWildcard(_assign);

var _MediaLoader = _dereq_('./tech/loader.js');

var _MediaLoader2 = _interopRequireWildcard(_MediaLoader);

var _Html5 = _dereq_('./tech/html5.js');

var _Html52 = _interopRequireWildcard(_Html5);

var _Flash = _dereq_('./tech/flash.js');

var _Flash2 = _interopRequireWildcard(_Flash);

var _PosterImage = _dereq_('./poster-image.js');

var _PosterImage2 = _interopRequireWildcard(_PosterImage);

var _TextTrackDisplay = _dereq_('./tracks/text-track-display.js');

var _TextTrackDisplay2 = _interopRequireWildcard(_TextTrackDisplay);

var _LoadingSpinner = _dereq_('./loading-spinner.js');

var _LoadingSpinner2 = _interopRequireWildcard(_LoadingSpinner);

var _BigPlayButton = _dereq_('./big-play-button.js');

var _BigPlayButton2 = _interopRequireWildcard(_BigPlayButton);

var _ControlBar = _dereq_('./control-bar/control-bar.js');

var _ControlBar2 = _interopRequireWildcard(_ControlBar);

var _ErrorDisplay = _dereq_('./error-display.js');

var _ErrorDisplay2 = _interopRequireWildcard(_ErrorDisplay);

var _import = _dereq_('./setup');

var setup = _interopRequireWildcard(_import);

var _Component = _dereq_('./component');

var _Component2 = _interopRequireWildcard(_Component);

var _Options = _dereq_('./options');

var _Options2 = _interopRequireWildcard(_Options);

var _import2 = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_import2);

var _log = _dereq_('./utils/log.js');

var _log2 = _interopRequireWildcard(_log);

var _import3 = _dereq_('./utils/browser.js');

var browser = _interopRequireWildcard(_import3);

var _Player = _dereq_('./player');

var _Player2 = _interopRequireWildcard(_Player);

var _extendsFn = _dereq_('./extends.js');

var _extendsFn2 = _interopRequireWildcard(_extendsFn);

var _plugin = _dereq_('./plugins.js');

var _plugin2 = _interopRequireWildcard(_plugin);

var _options = _dereq_('./options.js');

var _options2 = _interopRequireWildcard(_options);

var _mergeOptions = _dereq_('../../src/js/utils/merge-options.js');

var _mergeOptions2 = _interopRequireWildcard(_mergeOptions);

// HTML5 Element Shim for IE8
if (typeof HTMLVideoElement === 'undefined') {
  _document2['default'].createElement('video');
  _document2['default'].createElement('audio');
  _document2['default'].createElement('track');
}

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 *
 * **ALIASES** videojs, _V_ (deprecated)
 *
 * The `vjs` function can be used to initialize or retrieve a player.
 *
 *     var myPlayer = vjs('my_video_id');
 *
 * @param  {String|Element} id      Video element or video element ID
 * @param  {Object=} options        Optional options object for config/settings
 * @param  {Function=} ready        Optional ready callback
 * @return {Player}             A player instance
 * @namespace
 */
var videojs = function videojs(id, options, ready) {
  var tag; // Element of ID

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (_Player2['default'].players[id]) {

      // If options or ready funtion are passed, warn
      if (options) {
        _log2['default'].warn('Player "' + id + '" is already initialised. Options will not be applied.');
      }

      if (ready) {
        _Player2['default'].players[id].ready(ready);
      }

      return _Player2['default'].players[id];

      // Otherwise get element for ID
    } else {
      tag = Dom.el(id);
    }

    // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  if (!tag || !tag.nodeName) {
    // re: nodeName, could be a box div also
    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
  }

  // Element may have a player attr referring to an already created player instance.
  // If not, set up a new player and return the instance.
  return tag.player || new _Player2['default'](tag, options, ready);
};

// CDN Version. Used to target right flash swf.
videojs.CDN_VERSION = '5.0';
videojs.ACCESS_PROTOCOL = 'https:' === _document2['default'].location.protocol ? 'https://' : 'http://';

/**
* Full player version
* @type {string}
*/
videojs.VERSION = '5.0.0-18';

// Set CDN Version of swf
// The added (+) blocks the replace from changing this _VERSION_NO_PATCH_ string
if (videojs.CDN_VERSION !== '__VERSION_' + 'NO_PATCH__') {
  _Options2['default'].flash.swf = '' + videojs.ACCESS_PROTOCOL + 'vjs.zencdn.net/' + videojs.CDN_VERSION + '/video-js.swf';
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)
setup.autoSetupTimeout(1, videojs);

videojs.getComponent = _Component2['default'].getComponent;
videojs.registerComponent = _Component2['default'].registerComponent;

// APIs that will be removed with 5.0, but need them to get tests passing
// in ES6 transition
videojs.TOUCH_ENABLED = browser.TOUCH_ENABLED;

// Probably want to keep this one for 5.0?
videojs.players = _Player2['default'].players;

videojs['extends'] = _extendsFn2['default'];

videojs.mergeOptions = _mergeOptions2['default'];

videojs.getGlobalOptions = function () {
  return _options2['default'];
};
videojs.setGlobalOptions = function (newOptions) {
  _mergeOptions2['default'](_options2['default'], newOptions);
};

videojs.plugin = _plugin2['default'];

/**
 * Utility function for adding languages to the default options. Useful for
 * amending multiple language support at runtime.
 *
 * Example: videojs.addLanguage('es', {'Hello':'Hola'});
 *
 * @param  {String} code The language code or dictionary property
 * @param  {Object} data The data values to be translated
 * @return {Object} The resulting global languages dictionary object
 */
videojs.addLanguage = function (code, data) {
  if (_Options2['default'].languages[code] !== undefined) {
    _Options2['default'].languages[code] = _mergeOptions2['default'](_Options2['default'].languages[code], data);
  } else {
    _Options2['default'].languages[code] = data;
  }
  return _Options2['default'].languages;
};

// REMOVING: We probably should add this to the migration plugin
// // Expose but deprecate the window[componentName] method for accessing components
// Object.getOwnPropertyNames(Component.components).forEach(function(name){
//   let component = Component.components[name];
//
//   // A deprecation warning as the constuctor
//   module.exports[name] = function(player, options, ready){
//     log.warn('Using videojs.'+name+' to access the '+name+' component has been deprecated. Please use videojs.getComponent("componentName")');
//
//     return new Component(player, options, ready);
//   };
//
//   // Allow the prototype and class methods to be accessible still this way
//   // Though anything that attempts to override class methods will no longer work
//   assign(module.exports[name], component);
// });

/**
 * Custom Universal Module Definition (UMD)
 *
 * Video.js will never be a non-browser lib so we can simplify UMD a bunch and
 * still support requirejs and browserify. This also needs to be closure
 * compiler compatible, so string keys are used.
 */
if (typeof define === 'function' && define.amd) {
  define('videojs', [], function () {
    return videojs;
  });

  // checking that module is an object too because of umdjs/umd#35
} else if (typeof exports === 'object' && typeof module === 'object') {
  module.exports = videojs;
}

exports['default'] = videojs;
module.exports = exports['default'];

},{"../../src/js/utils/merge-options.js":111,"./big-play-button.js":43,"./component":45,"./control-bar/control-bar.js":46,"./error-display.js":77,"./extends.js":79,"./loading-spinner.js":81,"./options":86,"./options.js":86,"./player":87,"./plugins.js":88,"./poster-image.js":89,"./setup":90,"./tech/flash.js":94,"./tech/html5.js":95,"./tech/loader.js":96,"./tracks/text-track-display.js":99,"./utils/browser.js":104,"./utils/dom.js":105,"./utils/log.js":110,"global/document":1,"object.assign":37}],117:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./utils/url.js');

var Url = _interopRequireWildcard(_import);

var _log = _dereq_('./utils/log.js');

var _log2 = _interopRequireWildcard(_log);

var _mergeOptions = _dereq_('./utils/merge-options.js');

var _mergeOptions2 = _interopRequireWildcard(_mergeOptions);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

/**
 * Simple http request for retrieving external files (e.g. text tracks)
 *
 * ##### Example
 *
 *     // using url string
 *     videojs.xhr('http://example.com/myfile.vtt', function(error, response, responseBody){});
 *
 *     // or options block
 *     videojs.xhr({
 *       uri: 'http://example.com/myfile.vtt',
 *       method: 'GET',
 *       responseType: 'text'
 *     }, function(error, response, responseBody){
 *       if (error) {
 *         // log the error
 *       } else {
 *         // successful, do something with the response
 *       }
 *     });
 *
 *
 * API is modeled after the Raynos/xhr, which we hope to use after
 * getting browserify implemented.
 * https://github.com/Raynos/xhr/blob/master/index.js
 *
 * @param  {Object|String}  options   Options block or URL string
 * @param  {Function}       callback  The callback function
 * @returns {Object}                  The request
 */
var xhr = function xhr(options, callback) {
  var abortTimeout = undefined;

  // If options is a string it's the url
  if (typeof options === 'string') {
    options = {
      uri: options
    };
  }

  // Merge with default options
  _mergeOptions2['default']({
    method: 'GET',
    timeout: 45 * 1000
  }, options);

  callback = callback || function () {};

  var XHR = _window2['default'].XMLHttpRequest;

  if (typeof XHR === 'undefined') {
    // Shim XMLHttpRequest for older IEs
    XHR = function () {
      try {
        return new _window2['default'].ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e) {}
      try {
        return new _window2['default'].ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (f) {}
      try {
        return new _window2['default'].ActiveXObject('Msxml2.XMLHTTP');
      } catch (g) {}
      throw new Error('This browser does not support XMLHttpRequest.');
    };
  }

  var request = new XHR();
  // Store a reference to the url on the request instance
  request.uri = options.uri;

  var urlInfo = Url.parseUrl(options.uri);
  var winLoc = _window2['default'].location;

  var successHandler = function successHandler() {
    _window2['default'].clearTimeout(abortTimeout);
    callback(null, request, request.response || request.responseText);
  };

  var errorHandler = function errorHandler(err) {
    _window2['default'].clearTimeout(abortTimeout);

    if (!err || typeof err === 'string') {
      err = new Error(err);
    }

    callback(err, request);
  };

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = urlInfo.protocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  // XDomainRequest -- Use for IE if XMLHTTPRequest2 isn't available
  // 'withCredentials' is only available in XMLHTTPRequest2
  // Also XDomainRequest has a lot of gotchas, so only use if cross domain
  if (crossOrigin && _window2['default'].XDomainRequest && !('withCredentials' in request)) {
    request = new _window2['default'].XDomainRequest();
    request.onload = successHandler;
    request.onerror = errorHandler;
    // These blank handlers need to be set to fix ie9
    // http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/
    request.onprogress = function () {};
    request.ontimeout = function () {};

    // XMLHTTPRequest
  } else {
    (function () {
      var fileUrl = urlInfo.protocol === 'file:' || winLoc.protocol === 'file:';

      request.onreadystatechange = function () {
        if (request.readyState === 4) {
          if (request.timedout) {
            return errorHandler('timeout');
          }

          if (request.status === 200 || fileUrl && request.status === 0) {
            successHandler();
          } else {
            errorHandler();
          }
        }
      };

      if (options.timeout) {
        abortTimeout = _window2['default'].setTimeout(function () {
          if (request.readyState !== 4) {
            request.timedout = true;
            request.abort();
          }
        }, options.timeout);
      }
    })();
  }

  // open the connection
  try {
    // Third arg is async, or ignored by XDomainRequest
    request.open(options.method || 'GET', options.uri, true);
  } catch (err) {
    return errorHandler(err);
  }

  // withCredentials only supported by XMLHttpRequest2
  if (options.withCredentials) {
    request.withCredentials = true;
  }

  if (options.responseType) {
    request.responseType = options.responseType;
  }

  // send the request
  try {
    request.send();
  } catch (err) {
    return errorHandler(err);
  }

  return request;
};

exports['default'] = xhr;
module.exports = exports['default'];

},{"./utils/log.js":110,"./utils/merge-options.js":111,"./utils/url.js":115,"global/window":2}]},{},[116])(116)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5jbG9uZWRlZXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmNsb25lZGVlcC9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlY2xvbmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmNsb25lZGVlcC9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlY2xvbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC5fYXJyYXljb3B5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5jbG9uZWRlZXAvbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWNsb25lL25vZGVfbW9kdWxlcy9sb2Rhc2guX2FycmF5ZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guY2xvbmVkZWVwL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2VjbG9uZS9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5jbG9uZWRlZXAvbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWNsb25lL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2Vhc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWNvcHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmNsb25lZGVlcC9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlY2xvbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWZvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guY2xvbmVkZWVwL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2VjbG9uZS9ub2RlX21vZHVsZXMvbG9kYXNoLmlzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmNsb25lZGVlcC9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlY2xvbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC5pc25hdGl2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guY2xvbmVkZWVwL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2VjbG9uZS9ub2RlX21vZHVsZXMvbG9kYXNoLmtleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmNsb25lZGVlcC9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlY2xvbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC5rZXlzL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNhcmd1bWVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmNsb25lZGVlcC9ub2RlX21vZHVsZXMvbG9kYXNoLl9iaW5kY2FsbGJhY2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzcGxhaW5vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzcGxhaW5vYmplY3Qvbm9kZV9tb2R1bGVzL2xvZGFzaC5rZXlzaW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLm1lcmdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5tZXJnZS9ub2RlX21vZHVsZXMvbG9kYXNoLl9jcmVhdGVhc3NpZ25lci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gubWVyZ2Uvbm9kZV9tb2R1bGVzL2xvZGFzaC5fY3JlYXRlYXNzaWduZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC5faXNpdGVyYXRlZWNhbGwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLm1lcmdlL25vZGVfbW9kdWxlcy9sb2Rhc2guX2NyZWF0ZWFzc2lnbmVyL25vZGVfbW9kdWxlcy9sb2Rhc2gucmVzdHBhcmFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5tZXJnZS9ub2RlX21vZHVsZXMvbG9kYXNoLmlzdHlwZWRhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gubWVyZ2Uvbm9kZV9tb2R1bGVzL2xvZGFzaC50b3BsYWlub2JqZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvbm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvc2FmZS1qc29uLXBhcnNlL3R1cGxlLmpzIiwiYmlnLXBsYXktYnV0dG9uLmpzIiwiYnV0dG9uLmpzIiwiY29tcG9uZW50LmpzIiwiY29udHJvbC1iYXIvY29udHJvbC1iYXIuanMiLCJjb250cm9sLWJhci9mdWxsc2NyZWVuLXRvZ2dsZS5qcyIsImNvbnRyb2wtYmFyL2xpdmUtZGlzcGxheS5qcyIsImNvbnRyb2wtYmFyL211dGUtdG9nZ2xlLmpzIiwiY29udHJvbC1iYXIvcGxheS10b2dnbGUuanMiLCJjb250cm9sLWJhci9wbGF5YmFjay1yYXRlLW1lbnUvcGxheWJhY2stcmF0ZS1tZW51LWJ1dHRvbi5qcyIsImNvbnRyb2wtYmFyL3BsYXliYWNrLXJhdGUtbWVudS9wbGF5YmFjay1yYXRlLW1lbnUtaXRlbS5qcyIsImNvbnRyb2wtYmFyL3Byb2dyZXNzLWNvbnRyb2wvbG9hZC1wcm9ncmVzcy1iYXIuanMiLCJjb250cm9sLWJhci9wcm9ncmVzcy1jb250cm9sL3BsYXktcHJvZ3Jlc3MtYmFyLmpzIiwiY29udHJvbC1iYXIvcHJvZ3Jlc3MtY29udHJvbC9wcm9ncmVzcy1jb250cm9sLmpzIiwiY29udHJvbC1iYXIvcHJvZ3Jlc3MtY29udHJvbC9zZWVrLWJhci5qcyIsImNvbnRyb2wtYmFyL3Byb2dyZXNzLWNvbnRyb2wvc2Vlay1oYW5kbGUuanMiLCJjb250cm9sLWJhci9zcGFjZXItY29udHJvbHMvY3VzdG9tLWNvbnRyb2wtc3BhY2VyLmpzIiwiY29udHJvbC1iYXIvc3BhY2VyLWNvbnRyb2xzL3NwYWNlci5qcyIsImNvbnRyb2wtYmFyL3RleHQtdHJhY2stY29udHJvbHMvY2FwdGlvbi1zZXR0aW5ncy1tZW51LWl0ZW0uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL2NhcHRpb25zLWJ1dHRvbi5qcyIsImNvbnRyb2wtYmFyL3RleHQtdHJhY2stY29udHJvbHMvY2hhcHRlcnMtYnV0dG9uLmpzIiwiY29udHJvbC1iYXIvdGV4dC10cmFjay1jb250cm9scy9jaGFwdGVycy10cmFjay1tZW51LWl0ZW0uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL29mZi10ZXh0LXRyYWNrLW1lbnUtaXRlbS5qcyIsImNvbnRyb2wtYmFyL3RleHQtdHJhY2stY29udHJvbHMvc3VidGl0bGVzLWJ1dHRvbi5qcyIsImNvbnRyb2wtYmFyL3RleHQtdHJhY2stY29udHJvbHMvdGV4dC10cmFjay1idXR0b24uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL3RleHQtdHJhY2stbWVudS1pdGVtLmpzIiwiY29udHJvbC1iYXIvdGltZS1jb250cm9scy9jdXJyZW50LXRpbWUtZGlzcGxheS5qcyIsImNvbnRyb2wtYmFyL3RpbWUtY29udHJvbHMvZHVyYXRpb24tZGlzcGxheS5qcyIsImNvbnRyb2wtYmFyL3RpbWUtY29udHJvbHMvcmVtYWluaW5nLXRpbWUtZGlzcGxheS5qcyIsImNvbnRyb2wtYmFyL3RpbWUtY29udHJvbHMvdGltZS1kaXZpZGVyLmpzIiwiY29udHJvbC1iYXIvdm9sdW1lLWNvbnRyb2wvdm9sdW1lLWJhci5qcyIsImNvbnRyb2wtYmFyL3ZvbHVtZS1jb250cm9sL3ZvbHVtZS1jb250cm9sLmpzIiwiY29udHJvbC1iYXIvdm9sdW1lLWNvbnRyb2wvdm9sdW1lLWhhbmRsZS5qcyIsImNvbnRyb2wtYmFyL3ZvbHVtZS1jb250cm9sL3ZvbHVtZS1sZXZlbC5qcyIsImNvbnRyb2wtYmFyL3ZvbHVtZS1tZW51LWJ1dHRvbi5qcyIsImVycm9yLWRpc3BsYXkuanMiLCJldmVudC1lbWl0dGVyLmpzIiwiZXh0ZW5kcy5qcyIsImZ1bGxzY3JlZW4tYXBpLmpzIiwibG9hZGluZy1zcGlubmVyLmpzIiwibWVkaWEtZXJyb3IuanMiLCJtZW51L21lbnUtYnV0dG9uLmpzIiwibWVudS9tZW51LWl0ZW0uanMiLCJtZW51L21lbnUuanMiLCJvcHRpb25zLmpzIiwicGxheWVyLmpzIiwicGx1Z2lucy5qcyIsInBvc3Rlci1pbWFnZS5qcyIsInNldHVwLmpzIiwic2xpZGVyL3NsaWRlci1oYW5kbGUuanMiLCJzbGlkZXIvc2xpZGVyLmpzIiwidGVjaC9mbGFzaC1ydG1wLmpzIiwidGVjaC9mbGFzaC5qcyIsInRlY2gvaHRtbDUuanMiLCJ0ZWNoL2xvYWRlci5qcyIsInRlY2gvdGVjaC5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLWN1ZS1saXN0LmpzIiwidHJhY2tzL3RleHQtdHJhY2stZGlzcGxheS5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLWVudW1zLmpzIiwidHJhY2tzL3RleHQtdHJhY2stbGlzdC5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLXNldHRpbmdzLmpzIiwidHJhY2tzL3RleHQtdHJhY2suanMiLCJ1dGlscy9icm93c2VyLmpzIiwidXRpbHMvZG9tLmpzIiwidXRpbHMvZXZlbnRzLmpzIiwidXRpbHMvZm4uanMiLCJ1dGlscy9mb3JtYXQtdGltZS5qcyIsInV0aWxzL2d1aWQuanMiLCJ1dGlscy9sb2cuanMiLCJ1dGlscy9tZXJnZS1vcHRpb25zLmpzIiwidXRpbHMvcm91bmQtZmxvYXQuanMiLCJ1dGlscy90aW1lLXJhbmdlcy5qcyIsInV0aWxzL3RvLXRpdGxlLWNhc2UuanMiLCJ1dGlscy91cmwuanMiLCJ2aWRlby5qcyIsInhoci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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YUFBYSxDQUFDLHdCQUF3QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNwRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHlCQUF5QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNyRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN0RSxVQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7S0FDdEIsQ0FBQyxDQUFDLENBQUM7O0FBRUosVUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQzFHLFVBQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUMxRyxVQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsd0JBQXdCLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDMUcsVUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDRCQUE0QixDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQzlHLFVBQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGFB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Y3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudDtcbn0gZWxzZSB7XG4gICAgdmFyIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXTtcblxuICAgIGlmICghZG9jY3kpIHtcbiAgICAgICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddID0gbWluRG9jO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG59XG4iLCJpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG4iLG51bGwsIi8qKlxuICogbG9kYXNoIDMuMC4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS43LjAgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlY2xvbmUnKSxcbiAgICBiaW5kQ2FsbGJhY2sgPSByZXF1aXJlKCdsb2Rhc2guX2JpbmRjYWxsYmFjaycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gKiB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nXG4gKiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAqIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uXG4gKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy4gU2VlIHRoZSBbSFRNTDUgc3BlY2lmaWNhdGlvbl0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKHVzZXJzKTtcbiAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBlbCA9IF8uY2xvbmVEZWVwKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gKiB9KTtcbiAqXG4gKiBib2R5ID09PSBkb2N1bWVudC5ib2R5XG4gKiAvLyA9PiBmYWxzZVxuICogYm9keS5ub2RlTmFtZVxuICogLy8gPT4gQk9EWVxuICogYm9keS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAqIC8vID0+IDIwXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyAmJiBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSk7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIGN1c3RvbWl6ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogbG9kYXNoIDMuMS4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYXJyYXlDb3B5ID0gcmVxdWlyZSgnbG9kYXNoLl9hcnJheWNvcHknKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCdsb2Rhc2guX2FycmF5ZWFjaCcpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2Vhc3NpZ24nKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlZm9yJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FycmF5JyksXG4gICAgaXNOYXRpdmUgPSByZXF1aXJlKCdsb2Rhc2guaXNuYXRpdmUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnbG9kYXNoLmtleXMnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID1cbmNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBBcnJheUJ1ZmZlciA9IGlzTmF0aXZlKEFycmF5QnVmZmVyID0gZ2xvYmFsLkFycmF5QnVmZmVyKSAmJiBBcnJheUJ1ZmZlcixcbiAgICBidWZmZXJTbGljZSA9IGlzTmF0aXZlKGJ1ZmZlclNsaWNlID0gQXJyYXlCdWZmZXIgJiYgbmV3IEFycmF5QnVmZmVyKDApLnNsaWNlKSAmJiBidWZmZXJTbGljZSxcbiAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgVWludDhBcnJheSA9IGlzTmF0aXZlKFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSkgJiYgVWludDhBcnJheTtcblxuLyoqIFVzZWQgdG8gY2xvbmUgYXJyYXkgYnVmZmVycy4gKi9cbnZhciBGbG9hdDY0QXJyYXkgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIFNhZmFyaSA1IGVycm9ycyB3aGVuIHVzaW5nIGFuIGFycmF5IGJ1ZmZlciB0byBpbml0aWFsaXplIGEgdHlwZWQgYXJyYXlcbiAgLy8gd2hlcmUgdGhlIGFycmF5IGJ1ZmZlcidzIGBieXRlTGVuZ3RoYCBpcyBub3QgYSBtdWx0aXBsZSBvZiB0aGUgdHlwZWRcbiAgLy8gYXJyYXkncyBgQllURVNfUEVSX0VMRU1FTlRgLlxuICB0cnkge1xuICAgIHZhciBmdW5jID0gaXNOYXRpdmUoZnVuYyA9IGdsb2JhbC5GbG9hdDY0QXJyYXkpICYmIGZ1bmMsXG4gICAgICAgIHJlc3VsdCA9IG5ldyBmdW5jKG5ldyBBcnJheUJ1ZmZlcigxMCksIDAsIDEpICYmIGZ1bmM7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHJlc3VsdDtcbn0oKSk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplLCBpbiBieXRlcywgb2YgZWFjaCBgRmxvYXQ2NEFycmF5YCBlbGVtZW50LiAqL1xudmFyIEZMT0FUNjRfQllURVNfUEVSX0VMRU1FTlQgPSBGbG9hdDY0QXJyYXkgPyBGbG9hdDY0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG4gKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgYHZhbHVlYCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWc7XG5cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsb25lYWJsZVRhZ3NbdGFnXVxuICAgICAgICA/IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcClcbiAgICAgICAgOiAob2JqZWN0ID8gdmFsdWUgOiB7fSk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICB9XG4gIH1cbiAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmUuXG4gIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBnaXZlbiBhcnJheSBidWZmZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlclNsaWNlLmNhbGwoYnVmZmVyLCAwKTtcbn1cbmlmICghYnVmZmVyU2xpY2UpIHtcbiAgLy8gUGhhbnRvbUpTIGhhcyBgQXJyYXlCdWZmZXJgIGFuZCBgVWludDhBcnJheWAgYnV0IG5vdCBgRmxvYXQ2NEFycmF5YC5cbiAgYnVmZmVyQ2xvbmUgPSAhKEFycmF5QnVmZmVyICYmIFVpbnQ4QXJyYXkpID8gY29uc3RhbnQobnVsbCkgOiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICBmbG9hdExlbmd0aCA9IEZsb2F0NjRBcnJheSA/IGZsb29yKGJ5dGVMZW5ndGggLyBGTE9BVDY0X0JZVEVTX1BFUl9FTEVNRU5UKSA6IDAsXG4gICAgICAgIG9mZnNldCA9IGZsb2F0TGVuZ3RoICogRkxPQVQ2NF9CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuXG4gICAgaWYgKGZsb2F0TGVuZ3RoKSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBGbG9hdDY0QXJyYXkocmVzdWx0LCAwLCBmbG9hdExlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlciwgMCwgZmxvYXRMZW5ndGgpKTtcbiAgICB9XG4gICAgaWYgKGJ5dGVMZW5ndGggIT0gb2Zmc2V0KSB7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0LCBvZmZzZXQpO1xuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgIEN0b3IgPSBPYmplY3Q7XG4gIH1cbiAgcmV0dXJuIG5ldyBDdG9yO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGJ1ZmZlckNsb25lKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICB2YXIgYnVmZmVyID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgQ3Rvcihpc0RlZXAgPyBidWZmZXJDbG9uZShidWZmZXIpIDogYnVmZmVyLCBvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0Lmxlbmd0aCk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3Iob2JqZWN0LnNvdXJjZSwgcmVGbGFncy5leGVjKG9iamVjdCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IG9iamVjdC5sYXN0SW5kZXg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICpcbiAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjcuMCA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUNvcHkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlDb3B5O1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjcuMCA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIG9yIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlQ29weSA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWNvcHknKSxcbiAgICBpc05hdGl2ZSA9IHJlcXVpcmUoJ2xvZGFzaC5pc25hdGl2ZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCdsb2Rhc2gua2V5cycpO1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGlzTmF0aXZlKGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpICYmIGdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlQXNzaWduID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSA9PSBudWxsXG4gICAgPyBvYmplY3RcbiAgICA6IGJhc2VDb3B5KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBiYXNlQ29weShzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIWdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbnN0YW50KFtdKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRvT2JqZWN0KG9iamVjdCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIG9iamVjdCBpZiBpdCBpcyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PSAnZnVuY3Rpb24nIHx8ICghIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxpdHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqIHZhciBnZXR0ZXIgPSBfLmNvbnN0YW50KG9iamVjdCk7XG4gKlxuICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQ29weShzb3VyY2UsIHByb3BzLCBvYmplY3QpIHtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ29weTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JJbmAgYW5kIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlc1xuICogb3ZlciBgb2JqZWN0YCBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3JcbiAqIGVhY2ggcHJvcGVydHkuIEl0ZXJhdG9yIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseVxuICogcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBvYmplY3QgaWYgaXQgaXMgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIFtzcGVjaWFsIGNoYXJhY3RlcnNdKGh0dHA6Ly93d3cucmVndWxhci1leHByZXNzaW9ucy5pbmZvL2NoYXJhY3RlcnMuaHRtbCNzcGVjaWFsKS5cbiAqIEluIGFkZGl0aW9uIHRvIHNwZWNpYWwgY2hhcmFjdGVycyB0aGUgZm9yd2FyZCBzbGFzaCBpcyBlc2NhcGVkIHRvIGFsbG93IGZvclxuICogZWFzaWVyIGBldmFsYCB1c2UgYW5kIGBGdW5jdGlvbmAgY29tcGlsYXRpb24uXG4gKi9cbnZhciByZVJlZ0V4cENoYXJzID0gL1suKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nLFxuICAgIHJlSGFzUmVnRXhwQ2hhcnMgPSBSZWdFeHAocmVSZWdFeHBDaGFycy5zb3VyY2UpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCBpcyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAqIGZvciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogKHZhbHVlICsgJycpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBlc2NhcGVSZWdFeHAob2JqVG9TdHJpbmcpXG4gIC5yZXBsYWNlKC90b1N0cmluZ3woZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0FycmF5ID0gaXNOYXRpdmUobmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkpICYmIG5hdGl2ZUlzQXJyYXk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZykge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIlxcXCIsIFwiL1wiLCBcIl5cIiwgXCIkXCIsIFwiLlwiLCBcInxcIiwgXCI/XCIsXG4gKiBcIipcIiwgXCIrXCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiBhbmQgXCJ9XCIgaW4gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczpcXC9cXC9sb2Rhc2hcXC5jb21cXC9cXCknXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhcnMudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFycywgJ1xcXFwkJicpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIFtzcGVjaWFsIGNoYXJhY3RlcnNdKGh0dHA6Ly93d3cucmVndWxhci1leHByZXNzaW9ucy5pbmZvL2NoYXJhY3RlcnMuaHRtbCNzcGVjaWFsKS5cbiAqIEluIGFkZGl0aW9uIHRvIHNwZWNpYWwgY2hhcmFjdGVycyB0aGUgZm9yd2FyZCBzbGFzaCBpcyBlc2NhcGVkIHRvIGFsbG93IGZvclxuICogZWFzaWVyIGBldmFsYCB1c2UgYW5kIGBGdW5jdGlvbmAgY29tcGlsYXRpb24uXG4gKi9cbnZhciByZVJlZ0V4cENoYXJzID0gL1suKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nLFxuICAgIHJlSGFzUmVnRXhwQ2hhcnMgPSBSZWdFeHAocmVSZWdFeHBDaGFycy5zb3VyY2UpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCBpcyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAqIGZvciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogKHZhbHVlICsgJycpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBlc2NhcGVSZWdFeHAob2JqVG9TdHJpbmcpXG4gIC5yZXBsYWNlKC90b1N0cmluZ3woZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXFxcIiwgXCIvXCIsIFwiXlwiLCBcIiRcIiwgXCIuXCIsIFwifFwiLCBcIj9cIixcbiAqIFwiKlwiLCBcIitcIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiIGFuZCBcIn1cIiBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOlxcL1xcL2xvZGFzaFxcLmNvbVxcL1xcKSdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFycy50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXJzLCAnXFxcXCQmJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05hdGl2ZTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC43IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdsb2Rhc2guaXNhcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJyYXknKSxcbiAgICBpc05hdGl2ZSA9IHJlcXVpcmUoJ2xvZGFzaC5pc25hdGl2ZScpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXM7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbi8qKlxuICogQW4gb2JqZWN0IGVudmlyb25tZW50IGZlYXR1cmUgZmxhZ3MuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIE9iamVjdFxuICovXG52YXIgc3VwcG9ydCA9IHt9O1xuXG4oZnVuY3Rpb24oeCkge1xuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCkgeyB0aGlzLnggPSB4OyB9LFxuICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgIG9iamVjdCA9IHsgJzAnOiB4LCAnbGVuZ3RoJzogeCB9LFxuICAgICAgcHJvcHMgPSBbXTtcblxuICBDdG9yLnByb3RvdHlwZSA9IHsgJ3ZhbHVlT2YnOiB4LCAneSc6IHggfTtcbiAgZm9yICh2YXIga2V5IGluIG5ldyBDdG9yKSB7IHByb3BzLnB1c2goa2V5KTsgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgYGFyZ3VtZW50c2Agb2JqZWN0IGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiBJbiBGaXJlZm94IDwgNCwgSUUgPCA5LCBQaGFudG9tSlMsIGFuZCBTYWZhcmkgPCA1LjEgYGFyZ3VtZW50c2Agb2JqZWN0XG4gICAqIGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlLiBDaHJvbWUgPCAyNSBhbmQgTm9kZS5qcyA8IDAuMTEuMCB0cmVhdFxuICAgKiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcyBub24tZW51bWVyYWJsZSBhbmQgZmFpbCBgaGFzT3duUHJvcGVydHlgXG4gICAqIGNoZWNrcyBmb3IgaW5kZXhlcyB0aGF0IGV4Y2VlZCB0aGUgbnVtYmVyIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYW5kXG4gICAqIHdob3NlIGFzc29jaWF0ZWQgYXJndW1lbnQgdmFsdWVzIGFyZSBgMGAuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICogQHR5cGUgYm9vbGVhblxuICAgKi9cbiAgdHJ5IHtcbiAgICBzdXBwb3J0Lm5vbkVudW1BcmdzID0gIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoYXJncywgMSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN1cHBvcnQubm9uRW51bUFyZ3MgPSB0cnVlO1xuICB9XG59KDEsIDApKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSBsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgKHN1cHBvcnQubm9uRW51bUFyZ3MgJiYgaXNBcmd1bWVudHMob2JqZWN0KSkpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgaWYgKChhbGxvd0luZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpIHx8IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PSAnZnVuY3Rpb24nIHx8ICghIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xudmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0ICE9IG51bGwgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCAoc3VwcG9ydC5ub25FbnVtQXJncyAmJiBpc0FyZ3VtZW50cyhvYmplY3QpKSkgJiYgbGVuZ3RoKSB8fCAwO1xuXG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGlzUHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VDYWxsYmFja2Agd2hpY2ggb25seSBzdXBwb3J0cyBgdGhpc2AgYmluZGluZ1xuICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxuICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxpdHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmRDYWxsYmFjaztcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmFzZUZvciA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWZvcicpLFxuICAgIGlzTmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLmlzbmF0aXZlJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnbG9kYXNoLmtleXNpbicpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZU9mID0gaXNOYXRpdmUoZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YpICYmIGdldFByb3RvdHlwZU9mO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckluYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzSW4pO1xufVxuXG4vKipcbiAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBoYXMgYSBgW1tQcm90b3R5cGVdXWBcbiAqIG9mIGBudWxsYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICB2YXIgQ3RvcjtcblxuICAvLyBFeGl0IGVhcmx5IGZvciBub24gYE9iamVjdGAgb2JqZWN0cy5cbiAgaWYgKCEoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RUYWcpIHx8XG4gICAgICAoIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjb25zdHJ1Y3RvcicpICYmXG4gICAgICAgIChDdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgIShDdG9yIGluc3RhbmNlb2YgQ3RvcikpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJRSA8IDkgaXRlcmF0ZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLiBJZiB0aGUgZmlyc3RcbiAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAvLyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gIHZhciByZXN1bHQ7XG4gIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgYmFzZUZvckluKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0ID0ga2V5O1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhc3N1bWVzIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3JcbiAqIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xudmFyIGlzUGxhaW5PYmplY3QgPSAhZ2V0UHJvdG90eXBlT2YgPyBzaGltSXNQbGFpbk9iamVjdCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghKHZhbHVlICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gIHJldHVybiBvYmpQcm90b1xuICAgID8gKHZhbHVlID09IG9ialByb3RvIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90bylcbiAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC42IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdsb2Rhc2guaXNhcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuLyoqXG4gKiBBbiBvYmplY3QgZW52aXJvbm1lbnQgZmVhdHVyZSBmbGFncy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHR5cGUgT2JqZWN0XG4gKi9cbnZhciBzdXBwb3J0ID0ge307XG5cbihmdW5jdGlvbih4KSB7XG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9IHg7IH0sXG4gICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgb2JqZWN0ID0geyAnMCc6IHgsICdsZW5ndGgnOiB4IH0sXG4gICAgICBwcm9wcyA9IFtdO1xuXG4gIEN0b3IucHJvdG90eXBlID0geyAndmFsdWVPZic6IHgsICd5JzogeCB9O1xuICBmb3IgKHZhciBrZXkgaW4gbmV3IEN0b3IpIHsgcHJvcHMucHVzaChrZXkpOyB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGUuXG4gICAqXG4gICAqIEluIEZpcmVmb3ggPCA0LCBJRSA8IDksIFBoYW50b21KUywgYW5kIFNhZmFyaSA8IDUuMSBgYXJndW1lbnRzYCBvYmplY3RcbiAgICogaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGUuIENocm9tZSA8IDI1IGFuZCBOb2RlLmpzIDwgMC4xMS4wIHRyZWF0XG4gICAqIGBhcmd1bWVudHNgIG9iamVjdCBpbmRleGVzIGFzIG5vbi1lbnVtZXJhYmxlIGFuZCBmYWlsIGBoYXNPd25Qcm9wZXJ0eWBcbiAgICogY2hlY2tzIGZvciBpbmRleGVzIHRoYXQgZXhjZWVkIHRoZSBudW1iZXIgb2YgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmRcbiAgICogd2hvc2UgYXNzb2NpYXRlZCBhcmd1bWVudCB2YWx1ZXMgYXJlIGAwYC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqL1xuICB0cnkge1xuICAgIHN1cHBvcnQubm9uRW51bUFyZ3MgPSAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChhcmdzLCAxKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3VwcG9ydC5ub25FbnVtQXJncyA9IHRydWU7XG4gIH1cbn0oMSwgMCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PSAnZnVuY3Rpb24nIHx8ICghIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IChzdXBwb3J0Lm5vbkVudW1BcmdzICYmIGlzQXJndW1lbnRzKG9iamVjdCkpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICBza2lwSW5kZXhlcyA9IGxlbmd0aCA+IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gKGluZGV4ICsgJycpO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShza2lwSW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgJiZcbiAgICAgICAgIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIGxvZGFzaCAzLjIuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGFycmF5Q29weSA9IHJlcXVpcmUoJ2xvZGFzaC5fYXJyYXljb3B5JyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnbG9kYXNoLl9hcnJheWVhY2gnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJ2xvZGFzaC5fY3JlYXRlYXNzaWduZXInKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpLFxuICAgIGlzTmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLmlzbmF0aXZlJyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC5pc3BsYWlub2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnbG9kYXNoLmlzdHlwZWRhcnJheScpLFxuICAgIGtleXMgPSByZXF1aXJlKCdsb2Rhc2gua2V5cycpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzaW4nKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoLnRvcGxhaW5vYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gaXNOYXRpdmUoZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgJiYgZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIHB1c2ggPSBhcnJheVByb3RvLnB1c2g7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgdmFyIGlzU3JjQXJyID0gaXNBcnJheUxpa2Uoc291cmNlKSAmJiAoaXNBcnJheShzb3VyY2UpIHx8IGlzVHlwZWRBcnJheShzb3VyY2UpKTtcbiAgaWYgKCFpc1NyY0Fycikge1xuICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICBwdXNoLmFwcGx5KHByb3BzLCBnZXRTeW1ib2xzKHNvdXJjZSkpO1xuICB9XG4gIGFycmF5RWFjaChwcm9wcyB8fCBzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHNyY1ZhbHVlO1xuICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0TGlrZShzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgaXNDb21tb24gPSByZXN1bHQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKChpc1NyY0FyciB8fCByZXN1bHQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAoaXNDb21tb24gfHwgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aCxcbiAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHNyY1ZhbHVlKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHN0YWNrQltsZW5ndGhdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FycmF5TGlrZShzcmNWYWx1ZSkgJiYgKGlzQXJyYXkoc3JjVmFsdWUpIHx8IGlzVHlwZWRBcnJheShzcmNWYWx1ZSkpKSB7XG4gICAgICByZXN1bHQgPSBpc0FycmF5KHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogKGlzQXJyYXlMaWtlKHZhbHVlKSA/IGFycmF5Q29weSh2YWx1ZSkgOiBbXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgcmVzdWx0ID0gaXNBcmd1bWVudHModmFsdWUpXG4gICAgICAgID8gdG9QbGFpbk9iamVjdCh2YWx1ZSlcbiAgICAgICAgOiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IHt9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZVxuICAvLyBpdCB3aXRoIGl0cyBtZXJnZWQgdmFsdWUuXG4gIHN0YWNrQS5wdXNoKHNyY1ZhbHVlKTtcbiAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBvYmplY3Rba2V5XSA9IG1lcmdlRnVuYyhyZXN1bHQsIHNyY1ZhbHVlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQik7XG4gIH0gZWxzZSBpZiAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkge1xuICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uc3RhbnQoW10pIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHModG9PYmplY3Qob2JqZWN0KSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gb2JqZWN0IGlmIGl0IGlzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09ICdmdW5jdGlvbicgfHwgKCEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jyk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAqIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kXG4gKiBzb3VyY2UgcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgbWVyZ2luZyBpcyBoYW5kbGVkXG4gKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gKiB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0ge1xuICogICAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAndXNlcic6ICdmcmVkJyB9XVxuICogfTtcbiAqXG4gKiB2YXIgYWdlcyA9IHtcbiAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZSh1c2VycywgYWdlcyk7XG4gKiAvLyA9PiB7ICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gKlxuICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnZnJ1aXRzJzogWydhcHBsZSddLFxuICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2ZydWl0cyc6IFsnYmFuYW5hJ10sXG4gKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIsIGZ1bmN0aW9uKGEsIGIpIHtcbiAqICAgaWYgKF8uaXNBcnJheShhKSkge1xuICogICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAqICAgfVxuICogfSk7XG4gKiAvLyA9PiB7ICdmcnVpdHMnOiBbJ2FwcGxlJywgJ2JhbmFuYSddLCAndmVnZXRhYmxlcyc6IFsnYmVldCcsICdjYXJyb3QnXSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VNZXJnZSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAqXG4gKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiaW5kQ2FsbGJhY2sgPSByZXF1aXJlKCdsb2Rhc2guX2JpbmRjYWxsYmFjaycpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnbG9kYXNoLl9pc2l0ZXJhdGVlY2FsbCcpLFxuICAgIHJlc3RQYXJhbSA9IHJlcXVpcmUoJ2xvZGFzaC5yZXN0cGFyYW0nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhc3NpZ25zIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byBhIGdpdmVuXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgYF8uYXNzaWduYCwgYF8uZGVmYXVsdHNgLCBhbmQgYF8ubWVyZ2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDIgJiYgc291cmNlc1tsZW5ndGggLSAyXSxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyICYmIHNvdXJjZXNbMl0sXG4gICAgICAgIHRoaXNBcmcgPSBsZW5ndGggPiAxICYmIHNvdXJjZXNbbGVuZ3RoIC0gMV07XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VzdG9taXplciA9IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCA1KTtcbiAgICAgIGxlbmd0aCAtPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIHRoaXNBcmcgPT0gJ2Z1bmN0aW9uJyA/IHRoaXNBcmcgOiBudWxsO1xuICAgICAgbGVuZ3RoIC09IChjdXN0b21pemVyID8gMSA6IDApO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IG51bGwgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC43IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkpIHtcbiAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PSAnZnVuY3Rpb24nIHx8ICghIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy42LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gKlxuICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHJlc3RQYXJhbShmdW5jLCBzdGFydCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiAoK3N0YXJ0IHx8IDApLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIHJlc3QpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICBpbmRleCA9IC0xO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0UGFyYW07XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9XG50eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjcuMCA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlQ29weSA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWNvcHknKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCdsb2Rhc2gua2V5c2luJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlXG4gKiBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ29weSh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM2LXNoaW1cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBjYW5CZU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnICYmIG9iaiAhPT0gbnVsbDtcbn07XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgpID09PSAnc3ltYm9sJztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBpc0VudW1lcmFibGVPbiA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIGZ1bmN0aW9uIGlzRW51bWVyYWJsZShwcm9wKSB7XG5cdFx0cmV0dXJuIHByb3BJc0VudW1lcmFibGUuY2FsbChvYmosIHByb3ApO1xuXHR9O1xufTtcblxudmFyIGFzc2lnblNoaW0gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UxKSB7XG5cdGlmICghY2FuQmVPYmplY3QodGFyZ2V0KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTsgfVxuXHR2YXIgb2JqVGFyZ2V0ID0gT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzLCBzb3VyY2UsIGksIHByb3BzO1xuXHRmb3IgKHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgKytzKSB7XG5cdFx0c291cmNlID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cdFx0cHJvcHMgPSBrZXlzKHNvdXJjZSk7XG5cdFx0aWYgKGhhc1N5bWJvbHMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0cHJvcHMucHVzaC5hcHBseShwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihpc0VudW1lcmFibGVPbihzb3VyY2UpKSk7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0b2JqVGFyZ2V0W3Byb3BzW2ldXSA9IHNvdXJjZVtwcm9wc1tpXV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmpUYXJnZXQ7XG59O1xuXG5hc3NpZ25TaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0QXNzaWduKCkge1xuXHRpZiAoT2JqZWN0LmFzc2lnbiAmJiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcblx0XHR2YXIgYXNzaWduSGFzUGVuZGluZ0V4Y2VwdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gRmlyZWZveCAzNyBzdGlsbCBoYXMgXCJwZW5kaW5nIGV4Y2VwdGlvblwiIGxvZ2ljIGluIGl0cyBPYmplY3QuYXNzaWduIGltcGxlbWVudGF0aW9uLFxuXHRcdFx0Ly8gd2hpY2ggaXMgNzIlIHNsb3dlciB0aGFuIG91ciBzaGltLCBhbmQgRmlyZWZveCA0MCdzIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cblx0XHRcdHZhciB0aHJvd2VyID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHsgMTogMiB9KTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdE9iamVjdC5hc3NpZ24odGhyb3dlciwgJ3h5Jyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd2VyWzFdID09PSAneSc7XG5cdFx0XHR9XG5cdFx0fSgpKTtcblx0XHRpZiAoYXNzaWduSGFzUGVuZGluZ0V4Y2VwdGlvbnMpIHtcblx0XHRcdGRlbGV0ZSBPYmplY3QuYXNzaWduO1xuXHRcdH1cblx0fVxuXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdCwge1xuXHRcdFx0YXNzaWduOiBhc3NpZ25TaGltXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIE9iamVjdC5hc3NpZ24gfHwgYXNzaWduU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduU2hpbTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgb2JqID0ge307XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IHZhbHVlOiBvYmogfSk7XG5cdFx0cmV0dXJuIG9iai54ID09PSBvYmo7XG5cdH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBJRSA4LiAqL1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQoKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QgJiYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHRmb3JlYWNoKGtleXMobWFwKSwgZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgcHJlZGljYXRlc1tuYW1lXSk7XG5cdH0pO1xufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4iLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcbnZhciBoYXNEb250RW51bUJ1ZyA9ICEoeyAndG9TdHJpbmcnOiBudWxsIH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xudmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGZ1bmN0aW9uICgpIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCdwcm90b3R5cGUnKTtcbnZhciBkb250RW51bXMgPSBbXG5cdCd0b1N0cmluZycsXG5cdCd0b0xvY2FsZVN0cmluZycsXG5cdCd2YWx1ZU9mJyxcblx0J2hhc093blByb3BlcnR5Jyxcblx0J2lzUHJvdG90eXBlT2YnLFxuXHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHQnY29uc3RydWN0b3InXG5dO1xuXG52YXIga2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0fVxuXG5cdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHR2YXIgY3RvciA9IG9iamVjdC5jb25zdHJ1Y3Rvcjtcblx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0O1xuXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoZUtleXM7XG59O1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmICghT2JqZWN0LmtleXMpIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XSdcblx0XHRcdCYmIHZhbHVlICE9PSBudWxsXG5cdFx0XHQmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG5cdFx0XHQmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJ1xuXHRcdFx0JiYgdmFsdWUubGVuZ3RoID49IDBcblx0XHRcdCYmIHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gU2FmZVBhcnNlVHVwbGVcblxuZnVuY3Rpb24gU2FmZVBhcnNlVHVwbGUob2JqLCByZXZpdmVyKSB7XG4gICAgdmFyIGpzb25cbiAgICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShvYmosIHJldml2ZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIFtlcnJvciwganNvbl1cbn1cbiIsImltcG9ydCBCdXR0b24gZnJvbSAnLi9idXR0b24uanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudC5qcyc7XG5cbi8qIEJpZyBQbGF5IEJ1dHRvblxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogSW5pdGlhbCBwbGF5IGJ1dHRvbi4gU2hvd3MgYmVmb3JlIHRoZSB2aWRlbyBoYXMgcGxheWVkLiBUaGUgaGlkaW5nIG9mIHRoZVxuICogYmlnIHBsYXkgYnV0dG9uIGlzIGRvbmUgdmlhIENTUyBhbmQgcGxheWVyIHN0YXRlcy5cbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEJpZ1BsYXlCdXR0b24gZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWJpZy1wbGF5LWJ1dHRvbicsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+JyxcbiAgICAgICdhcmlhLWxhYmVsJzogJ3BsYXkgdmlkZW8nXG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdCaWdQbGF5QnV0dG9uJywgQmlnUGxheUJ1dHRvbik7XG5leHBvcnQgZGVmYXVsdCBCaWdQbGF5QnV0dG9uO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi91dGlscy9kb20uanMnO1xuaW1wb3J0ICogYXMgRXZlbnRzIGZyb20gJy4vdXRpbHMvZXZlbnRzLmpzJztcbmltcG9ydCAqIGFzIEZuIGZyb20gJy4vdXRpbHMvZm4uanMnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5pbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC5hc3NpZ24nO1xuXG4vKiBCdXR0b24gLSBCYXNlIGNsYXNzIGZvciBhbGwgYnV0dG9uc1xuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJ1dHRvbnNcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEJ1dHRvbiBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMuZW1pdFRhcEV2ZW50cygpO1xuXG4gICAgdGhpcy5vbigndGFwJywgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgdGhpcy5vbignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICB9XG5cbiAgY3JlYXRlRWwodHlwZSwgcHJvcHMpIHtcbiAgICAvLyBBZGQgc3RhbmRhcmQgQXJpYSBhbmQgVGFiaW5kZXggaW5mb1xuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKCksXG4gICAgICAncm9sZSc6ICdidXR0b24nLFxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnLCAvLyBsZXQgdGhlIHNjcmVlbiByZWFkZXIgdXNlciBrbm93IHRoYXQgdGhlIHRleHQgb2YgdGhlIGJ1dHRvbiBtYXkgY2hhbmdlXG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIGxldCBlbCA9IHN1cGVyLmNyZWF0ZUVsKHR5cGUsIHByb3BzKTtcblxuICAgIC8vIGlmIGlubmVySFRNTCBoYXNuJ3QgYmVlbiBvdmVycmlkZGVuIChiaWdQbGF5QnV0dG9uKSwgYWRkIGNvbnRlbnQgZWxlbWVudHNcbiAgICBpZiAoIXByb3BzLmlubmVySFRNTCkge1xuICAgICAgdGhpcy5jb250ZW50RWxfID0gRG9tLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLWNvbnRlbnQnXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jb250cm9sVGV4dF8gPSBEb20uY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnLFxuICAgICAgICBpbm5lckhUTUw6IHRoaXMubG9jYWxpemUodGhpcy5idXR0b25UZXh0KSB8fCAnTmVlZCBUZXh0J1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY29udGVudEVsXy5hcHBlbmRDaGlsZCh0aGlzLmNvbnRyb2xUZXh0Xyk7XG4gICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIGB2anMtY29udHJvbCB2anMtYnV0dG9uICR7c3VwZXIuYnVpbGRDU1NDbGFzcygpfWA7XG4gIH1cblxuICAvLyBDbGljayAtIE92ZXJyaWRlIHdpdGggc3BlY2lmaWMgZnVuY3Rpb25hbGl0eSBmb3IgYnV0dG9uXG4gIGhhbmRsZUNsaWNrKCkge31cblxuICAvLyBGb2N1cyAtIEFkZCBrZXlib2FyZCBmdW5jdGlvbmFsaXR5IHRvIGVsZW1lbnRcbiAgaGFuZGxlRm9jdXMoKSB7XG4gICAgRXZlbnRzLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIEZuLmJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9XG5cbiAgLy8gS2V5UHJlc3MgKGRvY3VtZW50IGxldmVsKSAtIFRyaWdnZXIgY2xpY2sgd2hlbiBrZXlzIGFyZSBwcmVzc2VkXG4gIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNwYWNlIGJhciAoMzIpIG9yIGVudGVyICgxMykga2V5c1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5oYW5kbGVDbGljaygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJsdXIgLSBSZW1vdmUga2V5Ym9hcmQgdHJpZ2dlcnNcbiAgaGFuZGxlQmx1cigpIHtcbiAgICBFdmVudHMub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIEZuLmJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9XG5cbn1cblxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0J1dHRvbicsIEJ1dHRvbik7XG5leHBvcnQgZGVmYXVsdCBCdXR0b247XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGxheWVyIENvbXBvbmVudCAtIEJhc2UgY2xhc3MgZm9yIGFsbCBVSSBvYmplY3RzXG4gKlxuICovXG5cbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi91dGlscy9kb20uanMnO1xuaW1wb3J0ICogYXMgRm4gZnJvbSAnLi91dGlscy9mbi5qcyc7XG5pbXBvcnQgKiBhcyBHdWlkIGZyb20gJy4vdXRpbHMvZ3VpZC5qcyc7XG5pbXBvcnQgKiBhcyBFdmVudHMgZnJvbSAnLi91dGlscy9ldmVudHMuanMnO1xuaW1wb3J0IGxvZyBmcm9tICcuL3V0aWxzL2xvZy5qcyc7XG5pbXBvcnQgdG9UaXRsZUNhc2UgZnJvbSAnLi91dGlscy90by10aXRsZS1jYXNlLmpzJztcbmltcG9ydCBhc3NpZ24gZnJvbSAnb2JqZWN0LmFzc2lnbic7XG5pbXBvcnQgbWVyZ2VPcHRpb25zIGZyb20gJy4vdXRpbHMvbWVyZ2Utb3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQmFzZSBVSSBDb21wb25lbnQgY2xhc3NcbiAqXG4gKiBDb21wb25lbnRzIGFyZSBlbWJlZGRhYmxlIFVJIG9iamVjdHMgdGhhdCBhcmUgcmVwcmVzZW50ZWQgYnkgYm90aCBhXG4gKiBqYXZhc2NyaXB0IG9iamVjdCBhbmQgYW4gZWxlbWVudCBpbiB0aGUgRE9NLiBUaGV5IGNhbiBiZSBjaGlsZHJlbiBvZiBvdGhlclxuICogY29tcG9uZW50cywgYW5kIGNhbiBoYXZlIG1hbnkgY2hpbGRyZW4gdGhlbXNlbHZlcy5cbiAqXG4gKiAgICAgLy8gYWRkaW5nIGEgYnV0dG9uIHRvIHRoZSBwbGF5ZXJcbiAqICAgICB2YXIgYnV0dG9uID0gcGxheWVyLmFkZENoaWxkKCdidXR0b24nKTtcbiAqICAgICBidXR0b24uZWwoKTsgLy8gLT4gYnV0dG9uIGVsZW1lbnRcbiAqXG4gKiAgICAgPGRpdiBjbGFzcz1cInZpZGVvLWpzXCI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWJ1dHRvblwiPkJ1dHRvbjwvZGl2PlxuICogICAgIDwvZGl2PlxuICpcbiAqIENvbXBvbmVudHMgYXJlIGFsc28gZXZlbnQgZW1pdHRlcnMuXG4gKlxuICogICAgIGJ1dHRvbi5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICogICAgICAgY29uc29sZS5sb2coJ0J1dHRvbiBDbGlja2VkIScpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBidXR0b24udHJpZ2dlcignY3VzdG9tZXZlbnQnKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWVyICBNYWluIFBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcblxuICAgIC8vIFRoZSBjb21wb25lbnQgbWlnaHQgYmUgdGhlIHBsYXllciBpdHNlbGYgYW5kIHdlIGNhbid0IHBhc3MgYHRoaXNgIHRvIHN1cGVyXG4gICAgaWYgKCFwbGF5ZXIgJiYgdGhpcy5wbGF5KSB7XG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXIgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXyA9IHBsYXllcjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgY29weSBvZiBwcm90b3R5cGUub3B0aW9uc18gdG8gcHJvdGVjdCBhZ2FpbnN0IG92ZXJyaWRpbmcgZ2xvYmFsIGRlZmF1bHRzXG4gICAgdGhpcy5vcHRpb25zXyA9IGFzc2lnbih7fSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICAvLyBVcGRhdGVkIG9wdGlvbnMgd2l0aCBzdXBwbGllZCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8vIEdldCBJRCBmcm9tIG9wdGlvbnMgb3Igb3B0aW9ucyBlbGVtZW50IGlmIG9uZSBpcyBzdXBwbGllZFxuICAgIHRoaXMuaWRfID0gb3B0aW9ucy5pZCB8fCAob3B0aW9ucy5lbCAmJiBvcHRpb25zLmVsLmlkKTtcblxuICAgIC8vIElmIHRoZXJlIHdhcyBubyBJRCBmcm9tIHRoZSBvcHRpb25zLCBnZW5lcmF0ZSBvbmVcbiAgICBpZiAoIXRoaXMuaWRfKSB7XG4gICAgICAvLyBEb24ndCByZXF1aXJlIHRoZSBwbGF5ZXIgSUQgZnVuY3Rpb24gaW4gdGhlIGNhc2Ugb2YgbW9jayBwbGF5ZXJzXG4gICAgICBsZXQgaWQgPSBwbGF5ZXIgJiYgcGxheWVyLmlkICYmIHBsYXllci5pZCgpIHx8ICdub19wbGF5ZXInO1xuXG4gICAgICB0aGlzLmlkXyA9IGAke2lkfV9jb21wb25lbnRfJHtHdWlkLm5ld0dVSUQoKX1gO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcblxuICAgIC8vIENyZWF0ZSBlbGVtZW50IGlmIG9uZSB3YXNuJ3QgcHJvdmlkZWQgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLmVsXyA9IG9wdGlvbnMuZWw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNyZWF0ZUVsICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbF8gPSB0aGlzLmNyZWF0ZUVsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBbXTtcbiAgICB0aGlzLmNoaWxkSW5kZXhfID0ge307XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSB7fTtcblxuICAgIC8vIEFkZCBhbnkgY2hpbGQgY29tcG9uZW50cyBpbiBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuaW5pdENoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbml0Q2hpbGRyZW4oKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlYWR5KHJlYWR5KTtcbiAgICAvLyBEb24ndCB3YW50IHRvIHRyaWdnZXIgcmVhZHkgaGVyZSBvciBpdCB3aWxsIGJlZm9yZSBpbml0IGlzIGFjdHVhbGx5XG4gICAgLy8gZmluaXNoZWQgZm9yIGFsbCBjaGlsZHJlbiB0aGF0IHJ1biB0aGlzIGNvbnN0cnVjdG9yXG5cbiAgICBpZiAob3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbmFibGVUb3VjaEFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGVtcCBmb3IgRVM2IGNsYXNzIHRyYW5zaXRpb24sIHJlbW92ZSBiZWZvcmUgNS4wXG4gIGluaXQoKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2luaXQgY2FsbGVkIG9uIENvbXBvbmVudCcpO1xuICAgIENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGNvbXBvbmVudCBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHNcbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ2Rpc3Bvc2UnLCBidWJibGVzOiBmYWxzZSB9KTtcblxuICAgIC8vIERpc3Bvc2UgYWxsIGNoaWxkcmVuLlxuICAgIGlmICh0aGlzLmNoaWxkcmVuXykge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbl9baV0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGNoaWxkIHJlZmVyZW5jZXNcbiAgICB0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSBudWxsO1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAgdGhpcy5vZmYoKTtcblxuICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4gICAgaWYgKHRoaXMuZWxfLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbF8pO1xuICAgIH1cblxuICAgIERvbS5yZW1vdmVEYXRhKHRoaXMuZWxfKTtcbiAgICB0aGlzLmVsXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb21wb25lbnQncyBwbGF5ZXJcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKi9cbiAgcGxheWVyKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcl87XG4gIH1cblxuICAvKipcbiAgICogRGVlcCBtZXJnZSBvZiBvcHRpb25zIG9iamVjdHNcbiAgICpcbiAgICogV2hlbmV2ZXIgYSBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgb24gYm90aCBvcHRpb25zIG9iamVjdHNcbiAgICogdGhlIHR3byBwcm9wZXJ0aWVzIHdpbGwgYmUgbWVyZ2VkIHVzaW5nIG1lcmdlT3B0aW9ucy5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIGZvciBtZXJnaW5nIG9wdGlvbnMgZm9yIGNoaWxkIGNvbXBvbmVudHMuIFdlXG4gICAqIHdhbnQgaXQgdG8gYmUgZWFzeSB0byBvdmVycmlkZSBpbmRpdmlkdWFsIG9wdGlvbnMgb24gYSBjaGlsZFxuICAgKiBjb21wb25lbnQgd2l0aG91dCBoYXZpbmcgdG8gcmV3cml0ZSBhbGwgdGhlIG90aGVyIGRlZmF1bHQgb3B0aW9ucy5cbiAgICpcbiAgICogICAgIFBhcmVudC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gICAqICAgICAgIGNoaWxkcmVuOiB7XG4gICAqICAgICAgICAgJ2NoaWxkT25lJzogeyAnZm9vJzogJ2JhcicsICdhc2RmJzogJ2Zkc2EnIH0sXG4gICAqICAgICAgICAgJ2NoaWxkVHdvJzoge30sXG4gICAqICAgICAgICAgJ2NoaWxkVGhyZWUnOiB7fVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgICBuZXdPcHRpb25zID0ge1xuICAgKiAgICAgICBjaGlsZHJlbjoge1xuICAgKiAgICAgICAgICdjaGlsZE9uZSc6IHsgJ2Zvbyc6ICdiYXonLCAnYWJjJzogJzEyMycgfVxuICAgKiAgICAgICAgICdjaGlsZFR3byc6IG51bGwsXG4gICAqICAgICAgICAgJ2NoaWxkRm91cic6IHt9XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICpcbiAgICogICAgIHRoaXMub3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICpcbiAgICogUkVTVUxUXG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIGNoaWxkcmVuOiB7XG4gICAqICAgICAgICAgJ2NoaWxkT25lJzogeyAnZm9vJzogJ2JheicsICdhc2RmJzogJ2Zkc2EnLCAnYWJjJzogJzEyMycgfSxcbiAgICogICAgICAgICAnY2hpbGRUd28nOiBudWxsLCAvLyBEaXNhYmxlZC4gV29uJ3QgYmUgaW5pdGlhbGl6ZWQuXG4gICAqICAgICAgICAgJ2NoaWxkVGhyZWUnOiB7fSxcbiAgICogICAgICAgICAnY2hpbGRGb3VyJzoge31cbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBPYmplY3Qgb2YgbmV3IG9wdGlvbiB2YWx1ZXNcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgQSBORVcgb2JqZWN0IG9mIHRoaXMub3B0aW9uc18gYW5kIG9iaiBtZXJnZWRcbiAgICovXG4gIG9wdGlvbnMob2JqKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9uc18gPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zXywgb2JqKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqICAgICB2YXIgZG9tRWwgPSBteUNvbXBvbmVudC5lbCgpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nPX0gdGFnTmFtZSAgRWxlbWVudCdzIG5vZGUgdHlwZS4gZS5nLiAnZGl2J1xuICAgKiBAcGFyYW0gIHtPYmplY3Q9fSBhdHRyaWJ1dGVzIEFuIG9iamVjdCBvZiBlbGVtZW50IGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVFbCh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIERvbS5jcmVhdGVFbCh0YWdOYW1lLCBhdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGxvY2FsaXplKHN0cmluZykge1xuICAgIGxldCBsYW5nID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlKCk7XG4gICAgbGV0IGxhbmd1YWdlcyA9IHRoaXMucGxheWVyXy5sYW5ndWFnZXMoKTtcblxuICAgIGlmIChsYW5ndWFnZXMgJiYgbGFuZ3VhZ2VzW2xhbmddICYmIGxhbmd1YWdlc1tsYW5nXVtzdHJpbmddKSB7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2VzW2xhbmddW3N0cmluZ107XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50IHdoZXJlIGNoaWxkcmVuIGFyZSBpbnNlcnRlZC5cbiAgICogV2lsbCBlaXRoZXIgYmUgdGhlIHNhbWUgYXMgZWwoKSBvciBhIG5ldyBlbGVtZW50IGRlZmluZWQgaW4gY3JlYXRlRWwoKS5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGNvbnRlbnRFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50RWxfIHx8IHRoaXMuZWxfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcG9uZW50J3MgSURcbiAgICpcbiAgICogICAgIHZhciBpZCA9IG15Q29tcG9uZW50LmlkKCk7XG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGlkKCkge1xuICAgIHJldHVybiB0aGlzLmlkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCdzIG5hbWUuIFRoZSBuYW1lIGlzIG9mdGVuIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqICAgICB2YXIgbmFtZSA9IG15Q29tcG9uZW50Lm5hbWUoKTtcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYXJyYXkgb2YgYWxsIGNoaWxkIGNvbXBvbmVudHNcbiAgICpcbiAgICogICAgIHZhciBraWRzID0gbXlDb21wb25lbnQuY2hpbGRyZW4oKTtcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBjaGlsZHJlblxuICAgKi9cbiAgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjaGlsZCBjb21wb25lbnQgd2l0aCB0aGUgcHJvdmlkZWQgSURcbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKi9cbiAgZ2V0Q2hpbGRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRJbmRleF9baWRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjaGlsZCBjb21wb25lbnQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZVxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBnZXRDaGlsZChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGROYW1lSW5kZXhfW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGlsZCBjb21wb25lbnQgaW5zaWRlIHRoaXMgY29tcG9uZW50XG4gICAqXG4gICAqICAgICBteUNvbXBvbmVudC5lbCgpO1xuICAgKiAgICAgLy8gLT4gPGRpdiBjbGFzcz0nbXktY29tcG9uZW50Jz48L2Rpdj5cbiAgICogICAgIG15Q29tcG9uZW50LmNoaWxkcmVuKCk7XG4gICAqICAgICAvLyBbZW1wdHkgYXJyYXldXG4gICAqXG4gICAqICAgICB2YXIgbXlCdXR0b24gPSBteUNvbXBvbmVudC5hZGRDaGlsZCgnTXlCdXR0b24nKTtcbiAgICogICAgIC8vIC0+IDxkaXYgY2xhc3M9J215LWNvbXBvbmVudCc+PGRpdiBjbGFzcz1cIm15LWJ1dHRvblwiPm15QnV0dG9uPGRpdj48L2Rpdj5cbiAgICogICAgIC8vIC0+IG15QnV0dG9uID09PSBteUNvbW9uZW50LmNoaWxkcmVuKClbMF07XG4gICAqXG4gICAqIFBhc3MgaW4gb3B0aW9ucyBmb3IgY2hpbGQgY29uc3RydWN0b3JzIGFuZCBvcHRpb25zIGZvciBjaGlsZHJlbiBvZiB0aGUgY2hpbGRcbiAgICpcbiAgICogICAgIHZhciBteUJ1dHRvbiA9IG15Q29tcG9uZW50LmFkZENoaWxkKCdNeUJ1dHRvbicsIHtcbiAgICogICAgICAgdGV4dDogJ1ByZXNzIE1lJyxcbiAgICogICAgICAgY2hpbGRyZW46IHtcbiAgICogICAgICAgICBidXR0b25DaGlsZEV4YW1wbGU6IHtcbiAgICogICAgICAgICAgIGJ1dHRvbkNoaWxkT3B0aW9uOiB0cnVlXG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICB9XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8Q29tcG9uZW50fSBjaGlsZCBUaGUgY2xhc3MgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT3B0aW9ucywgaW5jbHVkaW5nIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGNoaWxkcmVuIG9mIHRoZSBjaGlsZC5cbiAgICogQHJldHVybiB7Q29tcG9uZW50fSBUaGUgY2hpbGQgY29tcG9uZW50IChjcmVhdGVkIGJ5IHRoaXMgcHJvY2VzcyBpZiBhIHN0cmluZyB3YXMgdXNlZClcbiAgICogQHN1cHByZXNzIHthY2Nlc3NDb250cm9sc3xjaGVja1JlZ0V4cHxjaGVja1R5cGVzfGNoZWNrVmFyc3xjb25zdHxjb25zdGFudFByb3BlcnR5fGRlcHJlY2F0ZWR8ZHVwbGljYXRlfGVzNVN0cmljdHxmaWxlb3ZlcnZpZXdUYWdzfGdsb2JhbFRoaXN8aW52YWxpZENhc3RzfG1pc3NpbmdQcm9wZXJ0aWVzfG5vblN0YW5kYXJkSnNEb2NzfHN0cmljdE1vZHVsZURlcENoZWNrfHVuZGVmaW5lZE5hbWVzfHVuZGVmaW5lZFZhcnN8dW5rbm93bkRlZmluZXN8dXNlbGVzc0NvZGV8dmlzaWJpbGl0eX1cbiAgICovXG4gIGFkZENoaWxkKGNoaWxkLCBvcHRpb25zPXt9KSB7XG4gICAgbGV0IGNvbXBvbmVudDtcbiAgICBsZXQgY29tcG9uZW50TmFtZTtcblxuICAgIC8vIElmIGNoaWxkIGlzIGEgc3RyaW5nLCBjcmVhdGUgbnQgd2l0aCBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjaGlsZDtcblxuICAgICAgLy8gT3B0aW9ucyBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgYXMgYSBib29sZWFuLCBzbyBjb252ZXJ0IHRvIGFuIGVtcHR5IG9iamVjdCBpZiBmYWxzZS5cbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCB0cnVlIGlzIGRlcHJlY2F0ZWQgc28gc2hvdyBhIHdhcm5pbmcuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBsb2cud2FybignSW5pdGlhbGl6aW5nIGEgY2hpbGQgY29tcG9uZW50IHdpdGggYHRydWVgIGlzIGRlcHJlY2F0ZWQuIENoaWxkcmVuIHNob3VsZCBiZSBkZWZpbmVkIGluIGFuIGFycmF5IHdoZW4gcG9zc2libGUsIGJ1dCBpZiBuZWNlc3NhcnkgdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGB0cnVlYC4nKTtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBjb21wb25lbnRDbGFzcyBpbiBvcHRpb25zLCBhc3N1bWUgY29tcG9uZW50Q2xhc3MgaXMgdGhlIG5hbWUgbG93ZXJjYXNlZFxuICAgICAgLy8gKGUuZy4gcGxheUJ1dHRvbilcbiAgICAgIGxldCBjb21wb25lbnRDbGFzc05hbWUgPSBvcHRpb25zLmNvbXBvbmVudENsYXNzIHx8IHRvVGl0bGVDYXNlKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAvLyBTZXQgbmFtZSB0aHJvdWdoIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMubmFtZSA9IGNvbXBvbmVudE5hbWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgJiBlbGVtZW50IGZvciB0aGlzIGNvbnRyb2xzIHNldFxuICAgICAgLy8gSWYgdGhlcmUncyBubyAucGxheWVyXywgdGhpcyBpcyBhIHBsYXllclxuICAgICAgbGV0IENvbXBvbmVudENsYXNzID0gQ29tcG9uZW50LmdldENvbXBvbmVudChjb21wb25lbnRDbGFzc05hbWUpO1xuXG4gICAgICBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50Q2xhc3ModGhpcy5wbGF5ZXJfIHx8IHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hpbGQgaXMgYSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50ID0gY2hpbGQ7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbl8ucHVzaChjb21wb25lbnQpO1xuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gY29tcG9uZW50O1xuICAgIH1cblxuICAgIC8vIElmIGEgbmFtZSB3YXNuJ3QgdXNlZCB0byBjcmVhdGUgdGhlIGNvbXBvbmVudCwgY2hlY2sgaWYgd2UgY2FuIHVzZSB0aGVcbiAgICAvLyBuYW1lIGZ1bmN0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCAoY29tcG9uZW50Lm5hbWUgJiYgY29tcG9uZW50Lm5hbWUoKSk7XG5cbiAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50TmFtZV0gPSBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBVSSBvYmplY3QncyBlbGVtZW50IHRvIHRoZSBjb250YWluZXIgZGl2IChib3gpXG4gICAgLy8gSGF2aW5nIGFuIGVsZW1lbnQgaXMgbm90IHJlcXVpcmVkXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuZWwgPT09ICdmdW5jdGlvbicgJiYgY29tcG9uZW50LmVsKCkpIHtcbiAgICAgIHRoaXMuY29udGVudEVsKCkuYXBwZW5kQ2hpbGQoY29tcG9uZW50LmVsKCkpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBzbyBpdCBjYW4gc3RvcmVkIG9uIHBhcmVudCBvYmplY3QgaWYgZGVzaXJlZC5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNoaWxkIGNvbXBvbmVudCBmcm9tIHRoaXMgY29tcG9uZW50J3MgbGlzdCBvZiBjaGlsZHJlbiwgYW5kIHRoZVxuICAgKiBjaGlsZCBjb21wb25lbnQncyBlbGVtZW50IGZyb20gdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUNoaWxkKGNvbXBvbmVudCkge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRDaGlsZChjb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmICghY29tcG9uZW50IHx8ICF0aGlzLmNoaWxkcmVuXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjaGlsZEZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXSA9PT0gY29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkRm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hpbGRGb3VuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnQubmFtZSgpXSA9IG51bGw7XG5cbiAgICBsZXQgY29tcEVsID0gY29tcG9uZW50LmVsKCk7XG5cbiAgICBpZiAoY29tcEVsICYmIGNvbXBFbC5wYXJlbnROb2RlID09PSB0aGlzLmNvbnRlbnRFbCgpKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLnJlbW92ZUNoaWxkKGNvbXBvbmVudC5lbCgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuZCBpbml0aWFsaXplIGRlZmF1bHQgY2hpbGQgY29tcG9uZW50cyBmcm9tIG9wdGlvbnNcbiAgICpcbiAgICogICAgIC8vIHdoZW4gYW4gaW5zdGFuY2Ugb2YgTXlDb21wb25lbnQgaXMgY3JlYXRlZCwgYWxsIGNoaWxkcmVuIGluIG9wdGlvbnNcbiAgICogICAgIC8vIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGluc3RhbmNlIGJ5IHRoZWlyIG5hbWUgc3RyaW5ncyBhbmQgb3B0aW9uc1xuICAgKiAgICAgTXlDb21wb25lbnQucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuID0ge1xuICAgKiAgICAgICBteUNoaWxkQ29tcG9uZW50OiB7XG4gICAqICAgICAgICAgbXlDaGlsZE9wdGlvbjogdHJ1ZVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICAvLyBPciB3aGVuIGNyZWF0aW5nIHRoZSBjb21wb25lbnRcbiAgICogICAgIHZhciBteUNvbXAgPSBuZXcgTXlDb21wb25lbnQocGxheWVyLCB7XG4gICAqICAgICAgIGNoaWxkcmVuOiB7XG4gICAqICAgICAgICAgbXlDaGlsZENvbXBvbmVudDoge1xuICAgKiAgICAgICAgICAgbXlDaGlsZE9wdGlvbjogdHJ1ZVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfVxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIFRoZSBjaGlsZHJlbiBvcHRpb24gY2FuIGFsc28gYmUgYW4gQXJyYXkgb2YgY2hpbGQgbmFtZXMgb3JcbiAgICogY2hpbGQgb3B0aW9ucyBvYmplY3RzICh0aGF0IGFsc28gaW5jbHVkZSBhICduYW1lJyBrZXkpLlxuICAgKlxuICAgKiAgICAgdmFyIG15Q29tcCA9IG5ldyBNeUNvbXBvbmVudChwbGF5ZXIsIHtcbiAgICogICAgICAgY2hpbGRyZW46IFtcbiAgICogICAgICAgICAnYnV0dG9uJyxcbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICBuYW1lOiAnYnV0dG9uJyxcbiAgICogICAgICAgICAgIHNvbWVPdGhlck9wdGlvbjogdHJ1ZVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqL1xuICBpbml0Q2hpbGRyZW4oKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5vcHRpb25zXy5jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgLy8gYHRoaXNgIGlzIGBwYXJlbnRgXG4gICAgICBsZXQgcGFyZW50T3B0aW9ucyA9IHRoaXMub3B0aW9ucygpO1xuICAgICAgbGV0IGhhbmRsZUFkZCA9IChuYW1lLCBvcHRzKSA9PiB7XG4gICAgICAgIC8vIEFsbG93IG9wdGlvbnMgZm9yIGNoaWxkcmVuIHRvIGJlIHNldCBhdCB0aGUgcGFyZW50IG9wdGlvbnNcbiAgICAgICAgLy8gZS5nLiB2aWRlb2pzKGlkLCB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICAvLyBpbnN0ZWFkIG9mIHZpZGVvanMoaWQsIHsgY2hpbGRyZW46IHsgY29udHJvbEJhcjogZmFsc2UgfSk7XG4gICAgICAgIGlmIChwYXJlbnRPcHRpb25zW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRzID0gcGFyZW50T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGZvciBkaXNhYmxpbmcgZGVmYXVsdCBjb21wb25lbnRzXG4gICAgICAgIC8vIGUuZy4gb3B0aW9uc1snY2hpbGRyZW4nXVsncG9zdGVySW1hZ2UnXSA9IGZhbHNlXG4gICAgICAgIGlmIChvcHRzID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAgIC8vIEFkZCBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGNoaWxkIGJ5IG5hbWUgb24gdGhlIHBhcmVudCBpbnN0YW5jZS5cbiAgICAgICAgLy8gSWYgdHdvIG9mIHRoZSBzYW1lIGNvbXBvbmVudCBhcmUgdXNlZCwgZGlmZmVyZW50IG5hbWVzIHNob3VsZCBiZSBzdXBwbGllZFxuICAgICAgICAvLyBmb3IgZWFjaFxuICAgICAgICB0aGlzW25hbWVdID0gdGhpcy5hZGRDaGlsZChuYW1lLCBvcHRzKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEFsbG93IGZvciBhbiBhcnJheSBvZiBjaGlsZHJlbiBkZXRhaWxzIHRvIHBhc3NlZCBpbiB0aGUgb3B0aW9uc1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBsZXQgbmFtZTtcbiAgICAgICAgICBsZXQgb3B0cztcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBbJ215Q29tcG9uZW50J11cbiAgICAgICAgICAgIG5hbWUgPSBjaGlsZDtcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gW3sgbmFtZTogJ215Q29tcG9uZW50Jywgb3RoZXJPcHRpb246IHRydWUgfV1cbiAgICAgICAgICAgIG5hbWUgPSBjaGlsZC5uYW1lO1xuICAgICAgICAgICAgb3B0cyA9IGNoaWxkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZUFkZChuYW1lLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG4gICAgICAgICAgaGFuZGxlQWRkKG5hbWUsIGNoaWxkcmVuW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgY2xhc3MgbmFtZVxuICAgKi9cbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICAvLyBDaGlsZCBjbGFzc2VzIGNhbiBpbmNsdWRlIGEgZnVuY3Rpb24gdGhhdCBkb2VzOlxuICAgIC8vIHJldHVybiAnQ0xBU1MgTkFNRScgKyB0aGlzLl9zdXBlcigpO1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAqXG4gICAqICAgICB2YXIgbXlGdW5jID0gZnVuY3Rpb24oKXtcbiAgICogICAgICAgdmFyIG15Q29tcG9uZW50ID0gdGhpcztcbiAgICogICAgICAgLy8gRG8gc29tZXRoaW5nIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkXG4gICAqICAgICB9O1xuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub24oJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqXG4gICAqIFRoZSBjb250ZXh0IG9mIG15RnVuYyB3aWxsIGJlIG15Q29tcG9uZW50IHVubGVzcyBwcmV2aW91c2x5IGJvdW5kLlxuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGFkZCBhIGxpc3RlbmVyIHRvIGFub3RoZXIgZWxlbWVudCBvciBjb21wb25lbnQuXG4gICAqXG4gICAqICAgICBteUNvbXBvbmVudC5vbihvdGhlckVsZW1lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKiAgICAgbXlDb21wb25lbnQub24ob3RoZXJDb21wb25lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBUaGUgYmVuZWZpdCBvZiB1c2luZyB0aGlzIG92ZXIgYFZqc0V2ZW50cy5vbihvdGhlckVsZW1lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpYFxuICAgKiBhbmQgYG90aGVyQ29tcG9uZW50Lm9uKCdldmVudE5hbWUnLCBteUZ1bmMpYCBpcyB0aGF0IHRoaXMgd2F5IHRoZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgd2hlbiBlaXRoZXIgY29tcG9uZW50IGlzIGRpc3Bvc2VkLlxuICAgKiBJdCB3aWxsIGFsc28gYmluZCBteUNvbXBvbmVudCBhcyB0aGUgY29udGV4dCBvZiBteUZ1bmMuXG4gICAqXG4gICAqICoqTk9URSoqOiBXaGVuIHVzaW5nIHRoaXMgb24gZWxlbWVudHMgaW4gdGhlIHBhZ2Ugb3RoZXIgdGhhbiB3aW5kb3dcbiAgICogYW5kIGRvY3VtZW50IChib3RoIHBlcm1hbmVudCksIGlmIHlvdSByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NXG4gICAqIHlvdSBuZWVkIHRvIGNhbGwgYG15Q29tcG9uZW50LnRyaWdnZXIoZWwsICdkaXNwb3NlJylgIG9uIGl0IHRvIGNsZWFuIHVwXG4gICAqIHJlZmVyZW5jZXMgdG8gaXQgYW5kIGFsbG93IHRoZSBicm93c2VyIHRvIGdhcmJhZ2UgY29sbGVjdCBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfENvbXBvbmVudH0gZmlyc3QgICBUaGUgZXZlbnQgdHlwZSBvciBvdGhlciBjb21wb25lbnRcbiAgICogQHBhcmFtICB7RnVuY3Rpb258U3RyaW5nfSAgICAgIHNlY29uZCAgVGhlIGV2ZW50IGhhbmRsZXIgb3IgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgdGhpcmQgICBUaGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9ICAgICAgICBzZWxmXG4gICAqL1xuICBvbihmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoZmlyc3QpKSB7XG4gICAgICBFdmVudHMub24odGhpcy5lbF8sIGZpcnN0LCBGbi5iaW5kKHRoaXMsIHNlY29uZCkpO1xuXG4gICAgLy8gVGFyZ2V0aW5nIGFub3RoZXIgY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZmlyc3Q7XG4gICAgICBjb25zdCB0eXBlID0gc2Vjb25kO1xuICAgICAgY29uc3QgZm4gPSBGbi5iaW5kKHRoaXMsIHRoaXJkKTtcblxuICAgICAgLy8gV2hlbiB0aGlzIGNvbXBvbmVudCBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHRoZSBvdGhlciBjb21wb25lbnRcbiAgICAgIGNvbnN0IHJlbW92ZU9uRGlzcG9zZSA9ICgpID0+IHRoaXMub2ZmKHRhcmdldCwgdHlwZSwgZm4pO1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgc28gd2UgY2FuIHJlbW92ZSBpdCBsYXRlciBpdCB1c2luZyB0aGUgSURcbiAgICAgIC8vIG9mIHRoZSBvcmlnaW5hbCBsaXN0ZW5lclxuICAgICAgcmVtb3ZlT25EaXNwb3NlLmd1aWQgPSBmbi5ndWlkO1xuICAgICAgdGhpcy5vbignZGlzcG9zZScsIHJlbW92ZU9uRGlzcG9zZSk7XG5cbiAgICAgIC8vIElmIHRoZSBvdGhlciBjb21wb25lbnQgaXMgZGlzcG9zZWQgZmlyc3Qgd2UgbmVlZCB0byBjbGVhbiB0aGUgcmVmZXJlbmNlXG4gICAgICAvLyB0byB0aGUgb3RoZXIgY29tcG9uZW50IGluIHRoaXMgY29tcG9uZW50J3MgcmVtb3ZlT25EaXNwb3NlIGxpc3RlbmVyXG4gICAgICAvLyBPdGhlcndpc2Ugd2UgY3JlYXRlIGEgbWVtb3J5IGxlYWsuXG4gICAgICBjb25zdCBjbGVhblJlbW92ZXIgPSAoKSA9PiB0aGlzLm9mZignZGlzcG9zZScsIHJlbW92ZU9uRGlzcG9zZSk7XG5cbiAgICAgIC8vIEFkZCB0aGUgc2FtZSBmdW5jdGlvbiBJRCBzbyB3ZSBjYW4gZWFzaWx5IHJlbW92ZSBpdCBsYXRlclxuICAgICAgY2xlYW5SZW1vdmVyLmd1aWQgPSBmbi5ndWlkO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgRE9NIG5vZGVcbiAgICAgIGlmIChmaXJzdC5ub2RlTmFtZSkge1xuICAgICAgICAvLyBBZGQgdGhlIGxpc3RlbmVyIHRvIHRoZSBvdGhlciBlbGVtZW50XG4gICAgICAgIEV2ZW50cy5vbih0YXJnZXQsIHR5cGUsIGZuKTtcbiAgICAgICAgRXZlbnRzLm9uKHRhcmdldCwgJ2Rpc3Bvc2UnLCBjbGVhblJlbW92ZXIpO1xuXG4gICAgICAvLyBTaG91bGQgYmUgYSBjb21wb25lbnRcbiAgICAgIC8vIE5vdCB1c2luZyBgaW5zdGFuY2VvZiBDb21wb25lbnRgIGJlY2F1c2UgaXQgbWFrZXMgbW9jayBwbGF5ZXJzIGRpZmZpY3VsdFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3Qub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBsaXN0ZW5lciB0byB0aGUgb3RoZXIgY29tcG9uZW50XG4gICAgICAgIHRhcmdldC5vbih0eXBlLCBmbik7XG4gICAgICAgIHRhcmdldC5vbignZGlzcG9zZScsIGNsZWFuUmVtb3Zlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAqXG4gICAqICAgICBteUNvbXBvbmVudC5vZmYoJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqXG4gICAqIElmIG15RnVuYyBpcyBleGNsdWRlZCwgQUxMIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50IHR5cGUgd2lsbCBiZSByZW1vdmVkLlxuICAgKiBJZiBldmVudFR5cGUgaXMgZXhjbHVkZWQsIEFMTCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHVzZSBgb2ZmYCB0byByZW1vdmUgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZCB0byBvdGhlclxuICAgKiBlbGVtZW50cyBvciBjb21wb25lbnRzIHVzaW5nIGBteUNvbXBvbmVudC5vbihvdGhlckNvbXBvbmVudC4uLmAuXG4gICAqIEluIHRoaXMgY2FzZSBib3RoIHRoZSBldmVudCB0eXBlIGFuZCBsaXN0ZW5lciBmdW5jdGlvbiBhcmUgUkVRVUlSRUQuXG4gICAqXG4gICAqICAgICBteUNvbXBvbmVudC5vZmYob3RoZXJFbGVtZW50LCAnZXZlbnRUeXBlJywgbXlGdW5jKTtcbiAgICogICAgIG15Q29tcG9uZW50Lm9mZihvdGhlckNvbXBvbmVudCwgJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZz18Q29tcG9uZW50fSAgZmlyc3QgIFRoZSBldmVudCB0eXBlIG9yIG90aGVyIGNvbXBvbmVudFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbj18U3RyaW5nfSAgICAgICBzZWNvbmQgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtICB7RnVuY3Rpb249fSAgICAgICAgICAgICAgdGhpcmQgIFRoZSBsaXN0ZW5lciBmb3Igb3RoZXIgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIG9mZihmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIGlmICghZmlyc3QgfHwgdHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGZpcnN0KSkge1xuICAgICAgRXZlbnRzLm9mZih0aGlzLmVsXywgZmlyc3QsIHNlY29uZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGZpcnN0O1xuICAgICAgY29uc3QgdHlwZSA9IHNlY29uZDtcbiAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGF0IGxlYXN0IGEgZ3VpZCwgZXZlbiBpZiB0aGUgZnVuY3Rpb24gaGFzbid0IGJlZW4gdXNlZFxuICAgICAgY29uc3QgZm4gPSBGbi5iaW5kKHRoaXMsIHRoaXJkKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBkaXNwb3NlIGxpc3RlbmVyIG9uIHRoaXMgY29tcG9uZW50LFxuICAgICAgLy8gd2hpY2ggd2FzIGdpdmVuIHRoZSBzYW1lIGd1aWQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyXG4gICAgICB0aGlzLm9mZignZGlzcG9zZScsIGZuKTtcblxuICAgICAgaWYgKGZpcnN0Lm5vZGVOYW1lKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgICAgRXZlbnRzLm9mZih0YXJnZXQsIHR5cGUsIGZuKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW5lciBmb3IgY2xlYW5pbmcgdGhlIGRpc3Bvc2UgbGlzdGVuZXJcbiAgICAgICAgRXZlbnRzLm9mZih0YXJnZXQsICdkaXNwb3NlJywgZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Lm9mZih0eXBlLCBmbik7XG4gICAgICAgIHRhcmdldC5vZmYoJ2Rpc3Bvc2UnLCBmbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGJlIHRyaWdnZXJlZCBvbmx5IG9uY2UgYW5kIHRoZW4gcmVtb3ZlZFxuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub25lKCdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5IHlvdSBjYW4gYWRkIGEgbGlzdGVuZXIgdG8gYW5vdGhlciBlbGVtZW50IG9yIGNvbXBvbmVudFxuICAgKiB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIG9ubHkgb25jZS5cbiAgICpcbiAgICogICAgIG15Q29tcG9uZW50Lm9uZShvdGhlckVsZW1lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKiAgICAgbXlDb21wb25lbnQub25lKG90aGVyQ29tcG9uZW50LCAnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfENvbXBvbmVudH0gIGZpcnN0ICAgVGhlIGV2ZW50IHR5cGUgb3Igb3RoZXIgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufFN0cmluZ30gICAgICAgc2Vjb25kICBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3IgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbj19ICAgICAgICAgICAgIHRoaXJkICAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciBvdGhlciBjb21wb25lbnRcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKi9cbiAgb25lKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIEV2ZW50cy5vbmUodGhpcy5lbF8sIGZpcnN0LCBGbi5iaW5kKHRoaXMsIHNlY29uZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBmaXJzdDtcbiAgICAgIGNvbnN0IHR5cGUgPSBzZWNvbmQ7XG4gICAgICBjb25zdCBmbiA9IEZuLmJpbmQodGhpcywgdGhpcmQpO1xuXG4gICAgICBjb25zdCBuZXdGdW5jID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9mZih0YXJnZXQsIHR5cGUsIG5ld0Z1bmMpO1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgLy8gS2VlcCB0aGUgc2FtZSBmdW5jdGlvbiBJRCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICBuZXdGdW5jLmd1aWQgPSBmbi5ndWlkO1xuXG4gICAgICB0aGlzLm9uKHRhcmdldCwgdHlwZSwgbmV3RnVuYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhbiBldmVudCBvbiBhbiBlbGVtZW50XG4gICAqXG4gICAqICAgICBteUNvbXBvbmVudC50cmlnZ2VyKCdldmVudE5hbWUnKTtcbiAgICogICAgIG15Q29tcG9uZW50LnRyaWdnZXIoeyd0eXBlJzonZXZlbnROYW1lJ30pO1xuICAgKlxuICAgKiBAcGFyYW0gIHtFdmVudHxPYmplY3R8U3RyaW5nfSBldmVudCAgQSBzdHJpbmcgKHRoZSB0eXBlKSBvciBhbiBldmVudCBvYmplY3Qgd2l0aCBhIHR5cGUgYXR0cmlidXRlXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gICAgICAgc2VsZlxuICAgKi9cbiAgdHJpZ2dlcihldmVudCkge1xuICAgIEV2ZW50cy50cmlnZ2VyKHRoaXMuZWxfLCBldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQmluZCBhIGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByZWFkeSBzdGF0ZVxuICAgKlxuICAgKiBEaWZmZXJlbnQgZnJvbSBldmVudCBsaXN0ZW5lcnMgaW4gdGhhdCBpZiB0aGUgcmVhZHkgZXZlbnQgaGFzIGFscmVhZHkgaGFwcGVuZWRcbiAgICogaXQgd2lsbCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuIFJlYWR5IGxpc3RlbmVyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIHJlYWR5KGZuKSB7XG4gICAgaWYgKGZuKSB7XG4gICAgICBpZiAodGhpcy5pc1JlYWR5Xykge1xuICAgICAgICBmbi5jYWxsKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IHRoaXMucmVhZHlRdWV1ZV8gfHwgW107XG4gICAgICAgIHRoaXMucmVhZHlRdWV1ZV8ucHVzaChmbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIHJlYWR5IGxpc3RlbmVyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICB0cmlnZ2VyUmVhZHkoKSB7XG4gICAgdGhpcy5pc1JlYWR5XyA9IHRydWU7XG5cbiAgICBsZXQgcmVhZHlRdWV1ZSA9IHRoaXMucmVhZHlRdWV1ZV87XG5cbiAgICBpZiAocmVhZHlRdWV1ZSAmJiByZWFkeVF1ZXVlLmxlbmd0aCA+IDApIHtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWFkeVF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlYWR5UXVldWVbaV0uY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgUmVhZHkgUXVldWVcbiAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSBbXTtcblxuICAgICAgLy8gQWxsb3cgZm9yIHVzaW5nIGV2ZW50IGxpc3RlbmVycyBhbHNvLCBpbiBjYXNlIHlvdSB3YW50IHRvIGRvIHNvbWV0aGluZyBldmVyeXRpbWUgYSBzb3VyY2UgaXMgcmVhZHkuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlYWR5Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tcG9uZW50J3MgZWxlbWVudCBoYXMgYSBDU1MgY2xhc3MgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb0NoZWNrIENsYXNzbmFtZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc1RvQ2hlY2spIHtcbiAgICByZXR1cm4gRG9tLmhhc0NsYXNzKHRoaXMuZWxfLCBjbGFzc1RvQ2hlY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIHRoZSBjb21wb25lbnQncyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc1RvQWRkIENsYXNzbmFtZSB0byBhZGRcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NUb0FkZCkge1xuICAgIERvbS5hZGRDbGFzcyh0aGlzLmVsXywgY2xhc3NUb0FkZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSB0aGUgY29tcG9uZW50J3MgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb1JlbW92ZSBDbGFzc25hbWUgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzVG9SZW1vdmUpIHtcbiAgICBEb20ucmVtb3ZlQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9SZW1vdmUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlmIGhpZGRlblxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjb21wb25lbnQgZWxlbWVudCBpZiBjdXJyZW50bHkgc2hvd2luZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrIGFuIGl0ZW0gaW4gaXRzIHZpc2libGUgc3RhdGVcbiAgICogVG8gYmUgdXNlZCB3aXRoIGZhZGVJbi9mYWRlT3V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsb2NrU2hvd2luZygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVW5sb2NrIGFuIGl0ZW0gdG8gYmUgaGlkZGVuXG4gICAqIFRvIGJlIHVzZWQgd2l0aCBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5sb2NrU2hvd2luZygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG9yIGdldCB0aGUgd2lkdGggb2YgdGhlIGNvbXBvbmVudCAoQ1NTIHZhbHVlcylcbiAgICpcbiAgICogU2V0dGluZyB0aGUgdmlkZW8gdGFnIGRpbWVuc2lvbiB2YWx1ZXMgb25seSB3b3JrcyB3aXRoIHZhbHVlcyBpbiBwaXhlbHMuXG4gICAqIFBlcmNlbnQgdmFsdWVzIHdpbGwgbm90IHdvcmsuXG4gICAqIFNvbWUgcGVyY2VudHMgY2FuIGJlIHVzZWQsIGJ1dCB3aWR0aCgpL2hlaWdodCgpIHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgKyAlLFxuICAgKiBub3QgdGhlIGFjdHVhbCBjb21wdXRlZCB3aWR0aC9oZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmc9fSBudW0gICBPcHRpb25hbCB3aWR0aCBudW1iZXJcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2tpcExpc3RlbmVycyBTa2lwIHRoZSAncmVzaXplJyBldmVudCB0cmlnZ2VyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gVGhpcyBjb21wb25lbnQsIHdoZW4gc2V0dGluZyB0aGUgd2lkdGhcbiAgICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gVGhlIHdpZHRoLCB3aGVuIGdldHRpbmdcbiAgICovXG4gIHdpZHRoKG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCBudW0sIHNraXBMaXN0ZW5lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IChDU1MgdmFsdWVzKVxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSB2aWRlbyB0YWcgZGltZW5zaW9uIHZhbHVlcyBvbmx5IHdvcmtzIHdpdGggdmFsdWVzIGluIHBpeGVscy5cbiAgICogUGVyY2VudCB2YWx1ZXMgd2lsbCBub3Qgd29yay5cbiAgICogU29tZSBwZXJjZW50cyBjYW4gYmUgdXNlZCwgYnV0IHdpZHRoKCkvaGVpZ2h0KCkgd2lsbCByZXR1cm4gdGhlIG51bWJlciArICUsXG4gICAqIG5vdCB0aGUgYWN0dWFsIGNvbXB1dGVkIHdpZHRoL2hlaWdodC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZz19IG51bSAgICAgTmV3IGNvbXBvbmVudCBoZWlnaHRcbiAgICogQHBhcmFtICB7Qm9vbGVhbj19IHNraXBMaXN0ZW5lcnMgU2tpcCB0aGUgcmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSBUaGlzIGNvbXBvbmVudCwgd2hlbiBzZXR0aW5nIHRoZSBoZWlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gVGhlIGhlaWdodCwgd2hlbiBnZXR0aW5nXG4gICAqL1xuICBoZWlnaHQobnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCBudW0sIHNraXBMaXN0ZW5lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXQgdGhlIHNhbWUgdGltZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBoZWlnaHRcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSBUaGUgY29tcG9uZW50XG4gICAqL1xuICBkaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBTa2lwIHJlc2l6ZSBsaXN0ZW5lcnMgb24gd2lkdGggZm9yIG9wdGltaXphdGlvblxuICAgIHJldHVybiB0aGlzLndpZHRoKHdpZHRoLCB0cnVlKS5oZWlnaHQoaGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdpZHRoIG9yIGhlaWdodFxuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhlIHdpZHRoKCkgYW5kIGhlaWdodCgpIG1ldGhvZHMuXG4gICAqIEFsbCBmb3IgYW4gaW50ZWdlciwgaW50ZWdlciArICdweCcgb3IgaW50ZWdlciArICclJztcbiAgICpcbiAgICogS25vd24gaXNzdWU6IEhpZGRlbiBlbGVtZW50cyBvZmZpY2lhbGx5IGhhdmUgYSB3aWR0aCBvZiAwLiBXZSdyZSBkZWZhdWx0aW5nXG4gICAqIHRvIHRoZSBzdHlsZS53aWR0aCB2YWx1ZSBhbmQgZmFsbGluZyBiYWNrIHRvIGNvbXB1dGVkU3R5bGUgd2hpY2ggaGFzIHRoZVxuICAgKiBoaWRkZW4gZWxlbWVudCBpc3N1ZS4gSW5mbywgYnV0IHByb2JhYmx5IG5vdCBhbiBlZmZpY2llbnQgZml4OlxuICAgKiBodHRwOi8vd3d3LmZvbGlvdGVrLmNvbS9kZXZibG9nL2dldHRpbmctdGhlLXdpZHRoLW9mLWEtaGlkZGVuLWVsZW1lbnQtd2l0aC1qcXVlcnktdXNpbmctd2lkdGgvXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gd2lkdGhPckhlaWdodCAgJ3dpZHRoJyBvciAnaGVpZ2h0J1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nPX0gbnVtICAgICBOZXcgZGltZW5zaW9uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW49fSBza2lwTGlzdGVuZXJzIFNraXAgcmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSBUaGUgY29tcG9uZW50IGlmIGEgZGltZW5zaW9uIHdhcyBzZXRcbiAgICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gVGhlIGRpbWVuc2lvbiBpZiBub3RoaW5nIHdhcyBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpbWVuc2lvbih3aWR0aE9ySGVpZ2h0LCBudW0sIHNraXBMaXN0ZW5lcnMpIHtcbiAgICBpZiAobnVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFNldCB0byB6ZXJvIGlmIG51bGwgb3IgbGl0ZXJhbGx5IE5hTiAoTmFOICE9PSBOYU4pXG4gICAgICBpZiAobnVtID09PSBudWxsIHx8IG51bSAhPT0gbnVtKSB7XG4gICAgICAgIG51bSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHVzaW5nIGNzcyB3aWR0aC9oZWlnaHQgKCUgb3IgcHgpIGFuZCBhZGp1c3RcbiAgICAgIGlmICgoJycgKyBudW0pLmluZGV4T2YoJyUnKSAhPT0gLTEgfHwgKCcnICsgbnVtKS5pbmRleE9mKCdweCcpICE9PSAtMSkge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9IG51bTtcbiAgICAgIH0gZWxzZSBpZiAobnVtID09PSAnYXV0bycpIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgLy8gc2tpcExpc3RlbmVycyBhbGxvd3MgdXMgdG8gYXZvaWQgdHJpZ2dlcmluZyB0aGUgcmVzaXplIGV2ZW50IHdoZW4gc2V0dGluZyBib3RoIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIGlmICghc2tpcExpc3RlbmVycykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gY29tcG9uZW50XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBOb3Qgc2V0dGluZyBhIHZhbHVlLCBzbyBnZXR0aW5nIGl0XG4gICAgLy8gTWFrZSBzdXJlIGVsZW1lbnQgZXhpc3RzXG4gICAgaWYgKCF0aGlzLmVsXykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gR2V0IGRpbWVuc2lvbiB2YWx1ZSBmcm9tIHN0eWxlXG4gICAgbGV0IHZhbCA9IHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdO1xuICAgIGxldCBweEluZGV4ID0gdmFsLmluZGV4T2YoJ3B4Jyk7XG5cbiAgICBpZiAocHhJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgcGl4ZWwgdmFsdWUgd2l0aCBubyAncHgnXG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsLnNsaWNlKDAsIHB4SW5kZXgpLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gTm8gcHggc28gdXNpbmcgJSBvciBubyBzdHlsZSB3YXMgc2V0LCBzbyBmYWxsaW5nIGJhY2sgdG8gb2Zmc2V0V2lkdGgvaGVpZ2h0XG4gICAgLy8gSWYgY29tcG9uZW50IGhhcyBkaXNwbGF5Om5vbmUsIG9mZnNldCB3aWxsIHJldHVybiAwXG4gICAgLy8gVE9ETzogaGFuZGxlIGRpc3BsYXk6bm9uZSBhbmQgbm8gZGltZW5zaW9uIHN0eWxlIHVzaW5nIHB4XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZWxfWydvZmZzZXQnICsgdG9UaXRsZUNhc2Uod2lkdGhPckhlaWdodCldLCAxMCk7XG5cbiAgICAvLyBDb21wdXRlZFN0eWxlIHZlcnNpb24uXG4gICAgLy8gT25seSBkaWZmZXJlbmNlIGlzIGlmIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBpdCB3aWxsIHJldHVyblxuICAgIC8vIHRoZSBwZXJjZW50IHZhbHVlIChlLmcuICcxMDAlJycpXG4gICAgLy8gaW5zdGVhZCBvZiB6ZXJvIGxpa2Ugb2Zmc2V0V2lkdGggcmV0dXJucy5cbiAgICAvLyB2YXIgdmFsID0gRG9tLmdldENvbXB1dGVkU3R5bGVWYWx1ZSh0aGlzLmVsXywgd2lkdGhPckhlaWdodCk7XG4gICAgLy8gdmFyIHB4SW5kZXggPSB2YWwuaW5kZXhPZigncHgnKTtcblxuICAgIC8vIGlmIChweEluZGV4ICE9PSAtMSkge1xuICAgIC8vICAgcmV0dXJuIHZhbC5zbGljZSgwLCBweEluZGV4KTtcbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgcmV0dXJuIHZhbDtcbiAgICAvLyB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdCAndGFwJyBldmVudHMgd2hlbiB0b3VjaCBldmVudHMgYXJlIHN1cHBvcnRlZFxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gc3VwcG9ydCB0b2dnbGluZyB0aGUgY29udHJvbHMgdGhyb3VnaCBhIHRhcCBvbiB0aGUgdmlkZW8uXG4gICAqXG4gICAqIFdlJ3JlIHJlcXVpcmluZyB0aGVtIHRvIGJlIGVuYWJsZWQgYmVjYXVzZSBvdGhlcndpc2UgZXZlcnkgY29tcG9uZW50IHdvdWxkXG4gICAqIGhhdmUgdGhpcyBleHRyYSBvdmVyaGVhZCB1bm5lY2Vzc2FyaWx5LCBvbiBtb2JpbGUgZGV2aWNlcyB3aGVyZSBleHRyYVxuICAgKiBvdmVyaGVhZCBpcyBlc3BlY2lhbGx5IGJhZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRUYXBFdmVudHMoKSB7XG4gICAgLy8gVHJhY2sgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVybWluZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgbGV0IHRvdWNoU3RhcnQgPSAwO1xuICAgIGxldCBmaXJzdFRvdWNoID0gbnVsbDtcblxuICAgIC8vIE1heGltdW0gbW92ZW1lbnQgYWxsb3dlZCBkdXJpbmcgYSB0b3VjaCBldmVudCB0byBzdGlsbCBiZSBjb25zaWRlcmVkIGEgdGFwXG4gICAgLy8gT3RoZXIgcG9wdWxhciBsaWJzIHVzZSBhbnl3aGVyZSBmcm9tIDIgKGhhbW1lci5qcykgdG8gMTUsIHNvIDEwIHNlZW1zIGxpa2UgYSBuaWNlLCByb3VuZCBudW1iZXIuXG4gICAgY29uc3QgdGFwTW92ZW1lbnRUaHJlc2hvbGQgPSAxMDtcblxuICAgIC8vIFRoZSBtYXhpbXVtIGxlbmd0aCBhIHRvdWNoIGNhbiBiZSB3aGlsZSBzdGlsbCBiZWluZyBjb25zaWRlcmVkIGEgdGFwXG4gICAgY29uc3QgdG91Y2hUaW1lVGhyZXNob2xkID0gMjAwO1xuXG4gICAgbGV0IGNvdWxkQmVUYXA7XG5cbiAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBDb3B5IHRoZSB0b3VjaGVzIG9iamVjdCB0byBwcmV2ZW50IG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgZmlyc3RUb3VjaCA9IGFzc2lnbih7fSwgZXZlbnQudG91Y2hlc1swXSk7XG4gICAgICAgIC8vIFJlY29yZCBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlY3QgYSB0YXAgdnMuIFwidG91Y2ggYW5kIGhvbGRcIlxuICAgICAgICB0b3VjaFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIFJlc2V0IGNvdWxkQmVUYXAgdHJhY2tpbmdcbiAgICAgICAgY291bGRCZVRhcCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0VG91Y2gpIHtcbiAgICAgICAgLy8gU29tZSBkZXZpY2VzIHdpbGwgdGhyb3cgdG91Y2htb3ZlcyBmb3IgYWxsIGJ1dCB0aGUgc2xpZ2h0ZXN0IG9mIHRhcHMuXG4gICAgICAgIC8vIFNvLCBpZiB3ZSBtb3ZlZCBvbmx5IGEgc21hbGwgZGlzdGFuY2UsIHRoaXMgY291bGQgc3RpbGwgYmUgYSB0YXBcbiAgICAgICAgY29uc3QgeGRpZmYgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZmlyc3RUb3VjaC5wYWdlWDtcbiAgICAgICAgY29uc3QgeWRpZmYgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZmlyc3RUb3VjaC5wYWdlWTtcbiAgICAgICAgY29uc3QgdG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydCh4ZGlmZiAqIHhkaWZmICsgeWRpZmYgKiB5ZGlmZik7XG5cbiAgICAgICAgaWYgKHRvdWNoRGlzdGFuY2UgPiB0YXBNb3ZlbWVudFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9UYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogTGlzdGVuIHRvIHRoZSBvcmlnaW5hbCB0YXJnZXQuIGh0dHA6Ly95b3V0dS5iZS9EdWpmcFhPS1VwOD90PTEzbThzXG4gICAgdGhpcy5vbigndG91Y2hsZWF2ZScsIG5vVGFwKTtcbiAgICB0aGlzLm9uKCd0b3VjaGNhbmNlbCcsIG5vVGFwKTtcblxuICAgIC8vIFdoZW4gdGhlIHRvdWNoIGVuZHMsIG1lYXN1cmUgaG93IGxvbmcgaXQgdG9vayBhbmQgdHJpZ2dlciB0aGUgYXBwcm9wcmlhdGVcbiAgICAvLyBldmVudFxuICAgIHRoaXMub24oJ3RvdWNoZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgLy8gUHJvY2VlZCBvbmx5IGlmIHRoZSB0b3VjaG1vdmUvbGVhdmUvY2FuY2VsIGV2ZW50IGRpZG4ndCBoYXBwZW5cbiAgICAgIGlmIChjb3VsZEJlVGFwID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE1lYXN1cmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgICAgICBjb25zdCB0b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnQ7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0b3VjaCB3YXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgICAgICBpZiAodG91Y2hUaW1lIDwgdG91Y2hUaW1lVGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgbGV0IGJyb3dzZXIgdHVybiB0aGlzIGludG8gYSBjbGlja1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd0YXAnKTtcbiAgICAgICAgICAvLyBJdCBtYXkgYmUgZ29vZCB0byBjb3B5IHRoZSB0b3VjaGVuZCBldmVudCBvYmplY3QgYW5kIGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyB0eXBlIHRvIHRhcCwgaWYgdGhlIG90aGVyIGV2ZW50IHByb3BlcnRpZXMgYXJlbid0IGV4YWN0IGFmdGVyXG4gICAgICAgICAgLy8gRXZlbnRzLmZpeEV2ZW50IHJ1bnMgKGUuZy4gZXZlbnQudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwb3J0IHVzZXIgdG91Y2ggYWN0aXZpdHkgd2hlbiB0b3VjaCBldmVudHMgb2NjdXJcbiAgICpcbiAgICogVXNlciBhY3Rpdml0eSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGVuIGNvbnRyb2xzIHNob3VsZCBzaG93L2hpZGUuIEl0J3NcbiAgICogcmVsYXRpdmVseSBzaW1wbGUgd2hlbiBpdCBjb21lcyB0byBtb3VzZSBldmVudHMsIGJlY2F1c2UgYW55IG1vdXNlIGV2ZW50XG4gICAqIHNob3VsZCBzaG93IHRoZSBjb250cm9scy4gU28gd2UgY2FwdHVyZSBtb3VzZSBldmVudHMgdGhhdCBidWJibGUgdXAgdG8gdGhlXG4gICAqIHBsYXllciBhbmQgcmVwb3J0IGFjdGl2aXR5IHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBXaXRoIHRvdWNoIGV2ZW50cyBpdCBpc24ndCBhcyBlYXN5LiBXZSBjYW4ndCByZWx5IG9uIHRvdWNoIGV2ZW50cyBhdCB0aGVcbiAgICogcGxheWVyIGxldmVsLCBiZWNhdXNlIGEgdGFwICh0b3VjaHN0YXJ0ICsgdG91Y2hlbmQpIG9uIHRoZSB2aWRlbyBpdHNlbGYgb25cbiAgICogbW9iaWxlIGRldmljZXMgaXMgbWVhbnQgdG8gdHVybiBjb250cm9scyBvZmYgKGFuZCBvbikuIFVzZXIgYWN0aXZpdHkgaXNcbiAgICogY2hlY2tlZCBhc3luY2hyb25vdXNseSwgc28gd2hhdCBjb3VsZCBoYXBwZW4gaXMgYSB0YXAgZXZlbnQgb24gdGhlIHZpZGVvXG4gICAqIHR1cm5zIHRoZSBjb250cm9scyBvZmYsIHRoZW4gdGhlIHRvdWNoZW5kIGV2ZW50IGJ1YmJsZXMgdXAgdG8gdGhlIHBsYXllcixcbiAgICogd2hpY2ggaWYgaXQgcmVwb3J0ZWQgdXNlciBhY3Rpdml0eSwgd291bGQgdHVybiB0aGUgY29udHJvbHMgcmlnaHQgYmFjayBvbi5cbiAgICogKFdlIGFsc28gZG9uJ3Qgd2FudCB0byBjb21wbGV0ZWx5IGJsb2NrIHRvdWNoIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwKVxuICAgKlxuICAgKiBBbHNvIGEgdG91Y2htb3ZlLCB0b3VjaCtob2xkLCBhbmQgYW55dGhpbmcgb3RoZXIgdGhhbiBhIHRhcCBpcyBub3Qgc3VwcG9zZWRcbiAgICogdG8gdHVybiB0aGUgY29udHJvbHMgYmFjayBvbiBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gICAqXG4gICAqIEhlcmUgd2UncmUgc2V0dGluZyB0aGUgZGVmYXVsdCBjb21wb25lbnQgYmVoYXZpb3IgdG8gcmVwb3J0IHVzZXIgYWN0aXZpdHlcbiAgICogd2hlbmV2ZXIgdG91Y2ggZXZlbnRzIGhhcHBlbiwgYW5kIHRoaXMgY2FuIGJlIHR1cm5lZCBvZmYgYnkgY29tcG9uZW50cyB0aGF0XG4gICAqIHdhbnQgdG91Y2ggZXZlbnRzIHRvIGFjdCBkaWZmZXJlbnRseS5cbiAgICovXG4gIGVuYWJsZVRvdWNoQWN0aXZpdHkoKSB7XG4gICAgLy8gRG9uJ3QgY29udGludWUgaWYgdGhlIHJvb3QgcGxheWVyIGRvZXNuJ3Qgc3VwcG9ydCByZXBvcnRpbmcgdXNlciBhY3Rpdml0eVxuICAgIGlmICghdGhpcy5wbGF5ZXIoKSB8fCAhdGhpcy5wbGF5ZXIoKS5yZXBvcnRVc2VyQWN0aXZpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBsaXN0ZW5lciBmb3IgcmVwb3J0aW5nIHRoYXQgdGhlIHVzZXIgaXMgYWN0aXZlXG4gICAgY29uc3QgcmVwb3J0ID0gRm4uYmluZCh0aGlzLnBsYXllcigpLCB0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICBsZXQgdG91Y2hIb2xkaW5nO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgICAvLyByZXBvcnQgYXQgdGhlIHNhbWUgaW50ZXJ2YWwgYXMgYWN0aXZpdHlDaGVja1xuICAgICAgdG91Y2hIb2xkaW5nID0gdGhpcy5zZXRJbnRlcnZhbChyZXBvcnQsIDI1MCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b3VjaEVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICByZXBvcnQoKTtcbiAgICAgIC8vIHN0b3AgdGhlIGludGVydmFsIHRoYXQgbWFpbnRhaW5zIGFjdGl2aXR5IGlmIHRoZSB0b3VjaCBpcyBob2xkaW5nXG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwodG91Y2hIb2xkaW5nKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbigndG91Y2htb3ZlJywgcmVwb3J0KTtcbiAgICB0aGlzLm9uKCd0b3VjaGVuZCcsIHRvdWNoRW5kKTtcbiAgICB0aGlzLm9uKCd0b3VjaGNhbmNlbCcsIHRvdWNoRW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRpbWVvdXQgYW5kIHNldHMgdXAgZGlzcG9zYWwgYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgdGltZW91dC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgTnVtYmVyIG9mIG1zIHRvIGRlbGF5IGJlZm9yZSBleGVjdXRpbmcgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHRpbWVvdXQgSURcbiAgICovXG4gIHNldFRpbWVvdXQoZm4sIHRpbWVvdXQpIHtcbiAgICBmbiA9IEZuLmJpbmQodGhpcywgZm4pO1xuXG4gICAgLy8gd2luZG93LnNldFRpbWVvdXQgd291bGQgYmUgcHJlZmVyYWJsZSBoZXJlLCBidXQgZHVlIHRvIHNvbWUgYml6YXJyZSBpc3N1ZSB3aXRoIFNpbm9uIGFuZC9vciBQaGFudG9tanMsIHdlIGNhbid0LlxuICAgIGxldCB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZW91dCk7XG5cbiAgICBjb25zdCBkaXNwb3NlRm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gYHZqcy10aW1lb3V0LSR7dGltZW91dElkfWA7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiB0aW1lb3V0SWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGEgdGltZW91dCBhbmQgcmVtb3ZlcyB0aGUgYXNzb2NpYXRlZCBkaXNwb3NlIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0SWQgVGhlIGlkIG9mIHRoZSB0aW1lb3V0IHRvIGNsZWFyXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgdGltZW91dCBJRFxuICAgKi9cbiAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCkge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgIGNvbnN0IGRpc3Bvc2VGbiA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9IGB2anMtdGltZW91dC0ke3RpbWVvdXRJZH1gO1xuXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGludGVydmFsIGFuZCBzZXRzIHVwIGRpc3Bvc2FsIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBydW4gZXZlcnkgTiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWwgTnVtYmVyIG9mIG1zIHRvIGRlbGF5IGJlZm9yZSBleGVjdXRpbmcgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGludGVydmFsIElEXG4gICAqL1xuICBzZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpIHtcbiAgICBmbiA9IEZuLmJpbmQodGhpcywgZm4pO1xuXG4gICAgbGV0IGludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKTtcblxuICAgIGNvbnN0IGRpc3Bvc2VGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH07XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9IGB2anMtaW50ZXJ2YWwtJHtpbnRlcnZhbElkfWA7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbiBpbnRlcnZhbCBhbmQgcmVtb3ZlcyB0aGUgYXNzb2NpYXRlZCBkaXNwb3NlIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbElkIFRoZSBpZCBvZiB0aGUgaW50ZXJ2YWwgdG8gY2xlYXJcbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBpbnRlcnZhbCBJRFxuICAgKi9cbiAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG5cbiAgICBjb25zdCBkaXNwb3NlRm4gPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSBgdmpzLWludGVydmFsLSR7aW50ZXJ2YWxJZH1gO1xuXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIGludGVydmFsSWQ7XG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXJDb21wb25lbnQobmFtZSwgY29tcCkge1xuICAgIGlmICghQ29tcG9uZW50LmNvbXBvbmVudHNfKSB7XG4gICAgICBDb21wb25lbnQuY29tcG9uZW50c18gPSB7fTtcbiAgICB9XG5cbiAgICBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0gPSBjb21wO1xuICAgIHJldHVybiBjb21wO1xuICB9XG5cbiAgc3RhdGljIGdldENvbXBvbmVudChuYW1lKSB7XG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzXyAmJiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cudmlkZW9qcyAmJiB3aW5kb3cudmlkZW9qc1tuYW1lXSkge1xuICAgICAgbG9nLndhcm4oYFRoZSAke25hbWV9IGNvbXBvbmVudCB3YXMgYWRkZWQgdG8gdGhlIHZpZGVvanMgb2JqZWN0IHdoZW4gaXQgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpYCk7XG4gICAgICByZXR1cm4gd2luZG93LnZpZGVvanNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGV4dGVuZChwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgLy8gU2V0IHVwIHRoZSBjb25zdHJ1Y3RvciB1c2luZyB0aGUgc3VwcGxpZWQgaW5pdCBtZXRob2RcbiAgICAvLyBvciB1c2luZyB0aGUgaW5pdCBvZiB0aGUgcGFyZW50IG9iamVjdFxuICAgIC8vIE1ha2Ugc3VyZSB0byBjaGVjayB0aGUgdW5vYmZ1c2NhdGVkIHZlcnNpb24gZm9yIGV4dGVybmFsIGxpYnNcbiAgICBsZXQgaW5pdCA9IHByb3BzLmluaXQgfHwgcHJvcHMuaW5pdCB8fCB0aGlzLnByb3RvdHlwZS5pbml0IHx8IHRoaXMucHJvdG90eXBlLmluaXQgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICAvLyBJbiBSZXNpZydzIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZSAocHJldmlvdXNseSB1c2VkKSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyAgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIGB0aGlzLmluaXQuYXBwbHkoYXJndW1lbnRzKWBcbiAgICAvLyBIb3dldmVyIHRoYXQgd291bGQgcHJldmVudCB1cyBmcm9tIHVzaW5nIGBQYXJlbnRPYmplY3QuY2FsbCh0aGlzKTtgXG4gICAgLy8gIGluIGEgQ2hpbGQgY29uc3RydWN0b3IgYmVjYXVzZSB0aGUgYHRoaXNgIGluIGB0aGlzLmluaXRgXG4gICAgLy8gIHdvdWxkIHN0aWxsIHJlZmVyIHRvIHRoZSBDaGlsZCBhbmQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcC5cbiAgICAvLyBXZSB3b3VsZCBpbnN0ZWFkIGhhdmUgdG8gZG9cbiAgICAvLyAgICBgUGFyZW50T2JqZWN0LnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7YFxuICAgIC8vICBCbGVoLiBXZSdyZSBub3QgY3JlYXRpbmcgYSBfc3VwZXIoKSBmdW5jdGlvbiwgc28gaXQncyBnb29kIHRvIGtlZXBcbiAgICAvLyAgdGhlIHBhcmVudCBjb25zdHJ1Y3RvciByZWZlcmVuY2Ugc2ltcGxlLlxuICAgIGxldCBzdWJPYmogPSBmdW5jdGlvbigpIHtcbiAgICAgIGluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgLy8gSW5oZXJpdCBmcm9tIHRoaXMgb2JqZWN0J3MgcHJvdG90eXBlXG4gICAgc3ViT2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgIC8vIFJlc2V0IHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3Igc3ViT2JqIG90aGVyd2lzZVxuICAgIC8vIGluc3RhbmNlcyBvZiBzdWJPYmogd291bGQgaGF2ZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIHBhcmVudCBPYmplY3RcbiAgICBzdWJPYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViT2JqO1xuXG4gICAgLy8gTWFrZSB0aGUgY2xhc3MgZXh0ZW5kYWJsZVxuICAgIHN1Yk9iai5leHRlbmQgPSBDb21wb25lbnQuZXh0ZW5kO1xuICAgIC8vIE1ha2UgYSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgaW5zdGFuY2VzXG4gICAgLy8gc3ViT2JqLmNyZWF0ZSA9IENvcmVPYmplY3QuY3JlYXRlO1xuXG4gICAgLy8gRXh0ZW5kIHN1Yk9iaidzIHByb3RvdHlwZSB3aXRoIGZ1bmN0aW9ucyBhbmQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHByb3BzXG4gICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHN1Yk9iai5wcm90b3R5cGVbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3ViT2JqO1xuICB9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ29tcG9uZW50JywgQ29tcG9uZW50KTtcbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50LmpzJztcblxuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbmltcG9ydCBQbGF5VG9nZ2xlIGZyb20gJy4vcGxheS10b2dnbGUuanMnO1xuaW1wb3J0IEN1cnJlbnRUaW1lRGlzcGxheSBmcm9tICcuL3RpbWUtY29udHJvbHMvY3VycmVudC10aW1lLWRpc3BsYXkuanMnO1xuaW1wb3J0IER1cmF0aW9uRGlzcGxheSBmcm9tICcuL3RpbWUtY29udHJvbHMvZHVyYXRpb24tZGlzcGxheS5qcyc7XG5pbXBvcnQgVGltZURpdmlkZXIgZnJvbSAnLi90aW1lLWNvbnRyb2xzL3RpbWUtZGl2aWRlci5qcyc7XG5pbXBvcnQgUmVtYWluaW5nVGltZURpc3BsYXkgZnJvbSAnLi90aW1lLWNvbnRyb2xzL3JlbWFpbmluZy10aW1lLWRpc3BsYXkuanMnO1xuaW1wb3J0IExpdmVEaXNwbGF5IGZyb20gJy4vbGl2ZS1kaXNwbGF5LmpzJztcbmltcG9ydCBQcm9ncmVzc0NvbnRyb2wgZnJvbSAnLi9wcm9ncmVzcy1jb250cm9sL3Byb2dyZXNzLWNvbnRyb2wuanMnO1xuaW1wb3J0IEZ1bGxzY3JlZW5Ub2dnbGUgZnJvbSAnLi9mdWxsc2NyZWVuLXRvZ2dsZS5qcyc7XG5pbXBvcnQgVm9sdW1lQ29udHJvbCBmcm9tICcuL3ZvbHVtZS1jb250cm9sL3ZvbHVtZS1jb250cm9sLmpzJztcbmltcG9ydCBWb2x1bWVNZW51QnV0dG9uIGZyb20gJy4vdm9sdW1lLW1lbnUtYnV0dG9uLmpzJztcbmltcG9ydCBNdXRlVG9nZ2xlIGZyb20gJy4vbXV0ZS10b2dnbGUuanMnO1xuaW1wb3J0IENoYXB0ZXJzQnV0dG9uIGZyb20gJy4vdGV4dC10cmFjay1jb250cm9scy9jaGFwdGVycy1idXR0b24uanMnO1xuaW1wb3J0IFN1YnRpdGxlc0J1dHRvbiBmcm9tICcuL3RleHQtdHJhY2stY29udHJvbHMvc3VidGl0bGVzLWJ1dHRvbi5qcyc7XG5pbXBvcnQgQ2FwdGlvbnNCdXR0b24gZnJvbSAnLi90ZXh0LXRyYWNrLWNvbnRyb2xzL2NhcHRpb25zLWJ1dHRvbi5qcyc7XG5pbXBvcnQgUGxheWJhY2tSYXRlTWVudUJ1dHRvbiBmcm9tICcuL3BsYXliYWNrLXJhdGUtbWVudS9wbGF5YmFjay1yYXRlLW1lbnUtYnV0dG9uLmpzJztcbmltcG9ydCBDdXN0b21Db250cm9sU3BhY2VyIGZyb20gJy4vc3BhY2VyLWNvbnRyb2xzL2N1c3RvbS1jb250cm9sLXNwYWNlci5qcyc7XG5cbi8qKlxuICogQ29udGFpbmVyIG9mIG1haW4gY29udHJvbHNcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuY2xhc3MgQ29udHJvbEJhciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtYmFyJ1xuICAgIH0pO1xuICB9XG59XG5cbkNvbnRyb2xCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBsb2FkRXZlbnQ6ICdwbGF5JyxcbiAgY2hpbGRyZW46IFtcbiAgICAncGxheVRvZ2dsZScsXG4gICAgJ2N1cnJlbnRUaW1lRGlzcGxheScsXG4gICAgJ3RpbWVEaXZpZGVyJyxcbiAgICAnZHVyYXRpb25EaXNwbGF5JyxcbiAgICAncHJvZ3Jlc3NDb250cm9sJyxcbiAgICAnbGl2ZURpc3BsYXknLFxuICAgICdyZW1haW5pbmdUaW1lRGlzcGxheScsXG4gICAgJ2N1c3RvbUNvbnRyb2xTcGFjZXInLFxuICAgICdwbGF5YmFja1JhdGVNZW51QnV0dG9uJyxcbiAgICAnbXV0ZVRvZ2dsZScsXG4gICAgJ3ZvbHVtZUNvbnRyb2wnLFxuICAgICdjaGFwdGVyc0J1dHRvbicsXG4gICAgJ3N1YnRpdGxlc0J1dHRvbicsXG4gICAgJ2NhcHRpb25zQnV0dG9uJyxcbiAgICAndm9sdW1lTWVudUJ1dHRvbicsXG4gICAgJ2Z1bGxzY3JlZW5Ub2dnbGUnXG4gIF1cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ29udHJvbEJhcicsIENvbnRyb2xCYXIpO1xuZXhwb3J0IGRlZmF1bHQgQ29udHJvbEJhcjtcbiIsImltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50LmpzJztcblxuLyoqXG4gKiBUb2dnbGUgZnVsbHNjcmVlbiB2aWRlb1xuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyB2anMuQnV0dG9uXG4gKi9cbmNsYXNzIEZ1bGxzY3JlZW5Ub2dnbGUgZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIGB2anMtZnVsbHNjcmVlbi1jb250cm9sICR7c3VwZXIuYnVpbGRDU1NDbGFzcygpfWA7XG4gIH1cblxuICBoYW5kbGVDbGljaygpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICB0aGlzLmNvbnRyb2xUZXh0Xy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCdOb24tRnVsbHNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8uZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIHRoaXMuY29udHJvbFRleHRfLmlubmVySFRNTCA9IHRoaXMubG9jYWxpemUoJ0Z1bGxzY3JlZW4nKTtcbiAgICB9XG4gIH1cblxufVxuXG5GdWxsc2NyZWVuVG9nZ2xlLnByb3RvdHlwZS5idXR0b25UZXh0ID0gJ0Z1bGxzY3JlZW4nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0Z1bGxzY3JlZW5Ub2dnbGUnLCBGdWxsc2NyZWVuVG9nZ2xlKTtcbmV4cG9ydCBkZWZhdWx0IEZ1bGxzY3JlZW5Ub2dnbGU7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi4vdXRpbHMvZG9tLmpzJztcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgbGl2ZSBpbmRpY2F0b3JcbiAqIFRPRE8gLSBGdXR1cmUgbWFrZSBpdCBjbGljayB0byBzbmFwIHRvIGxpdmVcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBMaXZlRGlzcGxheSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBEb20uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWRpc3BsYXknLFxuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHt0aGlzLmxvY2FsaXplKCdTdHJlYW0gVHlwZScpfTwvc3Bhbj4ke3RoaXMubG9jYWxpemUoJ0xJVkUnKX1gLFxuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdMaXZlRGlzcGxheScsIExpdmVEaXNwbGF5KTtcbmV4cG9ydCBkZWZhdWx0IExpdmVEaXNwbGF5O1xuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24nO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgRG9tIGZyb20gJy4uL3V0aWxzL2RvbS5qcyc7XG5cbi8qKlxuICogQSBidXR0b24gY29tcG9uZW50IGZvciBtdXRpbmcgdGhlIGF1ZGlvXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE11dGVUb2dnbGUgZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucykge1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3ZvbHVtZWNoYW5nZScsIHRoaXMudXBkYXRlKTtcblxuICAgIC8vIGhpZGUgbXV0ZSB0b2dnbGUgaWYgdGhlIGN1cnJlbnQgdGVjaCBkb2Vzbid0IHN1cHBvcnQgdm9sdW1lIGNvbnRyb2xcbiAgICBpZiAocGxheWVyLnRlY2ggJiYgcGxheWVyLnRlY2hbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cblxuICAgIHRoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgZnVuY3Rpb24oKXtcbiAgICAgIGlmIChwbGF5ZXIudGVjaFsnZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKSxcbiAgICAgIGlubmVySFRNTDogYDxkaXY+PHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHt0aGlzLmxvY2FsaXplKCdNdXRlJyl9PC9zcGFuPjwvZGl2PmBcbiAgICB9KTtcbiAgfVxuXG4gIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIGB2anMtbXV0ZS1jb250cm9sICR7c3VwZXIuYnVpbGRDU1NDbGFzcygpfWA7XG4gIH1cblxuICBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLnBsYXllcl8ubXV0ZWQoIHRoaXMucGxheWVyXy5tdXRlZCgpID8gZmFsc2UgOiB0cnVlICk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdmFyIHZvbCA9IHRoaXMucGxheWVyXy52b2x1bWUoKSxcbiAgICAgICAgbGV2ZWwgPSAzO1xuXG4gICAgaWYgKHZvbCA9PT0gMCB8fCB0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgbGV2ZWwgPSAwO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC4zMykge1xuICAgICAgbGV2ZWwgPSAxO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC42Nykge1xuICAgICAgbGV2ZWwgPSAyO1xuICAgIH1cblxuICAgIC8vIERvbid0IHJld3JpdGUgdGhlIGJ1dHRvbiB0ZXh0IGlmIHRoZSBhY3R1YWwgdGV4dCBkb2Vzbid0IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNhdXNlcyB1bm5lY2Vzc2FyeSBhbmQgY29uZnVzaW5nIGluZm9ybWF0aW9uIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSB2b2x1bWUgbGV2ZWwgaXMgY2hhbmdlZC5cbiAgICBsZXQgdG9NdXRlID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgPyAnVW5tdXRlJyA6ICdNdXRlJztcbiAgICBsZXQgbG9jYWxpemVkTXV0ZSA9IHRoaXMubG9jYWxpemUodG9NdXRlKTtcbiAgICBpZiAodGhpcy5lbF8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MICE9PSBsb2NhbGl6ZWRNdXRlKSB7XG4gICAgICB0aGlzLmVsXy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBsb2NhbGl6ZWRNdXRlO1xuICAgIH1cblxuICAgIC8qIFRPRE8gaW1wcm92ZSBtdXRlZCBpY29uIGNsYXNzZXMgKi9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuZWxfLCBgdmpzLXZvbC0ke2l9YCk7XG4gICAgfVxuICAgIERvbS5hZGRDbGFzcyh0aGlzLmVsXywgYHZqcy12b2wtJHtsZXZlbH1gKTtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTXV0ZVRvZ2dsZScsIE11dGVUb2dnbGUpO1xuZXhwb3J0IGRlZmF1bHQgTXV0ZVRvZ2dsZTtcbiIsImltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50LmpzJztcblxuLyoqXG4gKiBCdXR0b24gdG8gdG9nZ2xlIGJldHdlZW4gcGxheSBhbmQgcGF1c2VcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFBsYXlUb2dnbGUgZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMub24ocGxheWVyLCAncGxheScsIHRoaXMuaGFuZGxlUGxheSk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdwYXVzZScsIHRoaXMuaGFuZGxlUGF1c2UpO1xuICB9XG5cbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gYHZqcy1wbGF5LWNvbnRyb2wgJHtzdXBlci5idWlsZENTU0NsYXNzKCl9YDtcbiAgfVxuXG4gIC8vIGhhbmRsZUNsaWNrIC0gVG9nZ2xlIGJldHdlZW4gcGxheSBhbmQgcGF1c2VcbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlUGxheSAtIEFkZCB0aGUgdmpzLXBsYXlpbmcgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlXG4gIGhhbmRsZVBsYXkoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5lbF8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgnUGF1c2UnKTsgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlBhdXNlXCJcbiAgfVxuXG4gIC8vIGhhbmRsZVBhdXNlIC0gQWRkIHRoZSB2anMtcGF1c2VkIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZVxuICBoYW5kbGVQYXVzZSgpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICB0aGlzLmVsXy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCdQbGF5Jyk7IC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQbGF5XCJcbiAgfVxuXG59XG5cblBsYXlUb2dnbGUucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnUGxheSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheVRvZ2dsZScsIFBsYXlUb2dnbGUpO1xuZXhwb3J0IGRlZmF1bHQgUGxheVRvZ2dsZTtcbiIsImltcG9ydCBNZW51QnV0dG9uIGZyb20gJy4uLy4uL21lbnUvbWVudS1idXR0b24uanMnO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi4vLi4vbWVudS9tZW51LmpzJztcbmltcG9ydCBQbGF5YmFja1JhdGVNZW51SXRlbSBmcm9tICcuL3BsYXliYWNrLXJhdGUtbWVudS1pdGVtLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIERvbSBmcm9tICcuLi8uLi91dGlscy9kb20uanMnO1xuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSBwbGF5YmFjayByYXRlXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gZXh0ZW5kcyBNZW51QnV0dG9uIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIHRoaXMudXBkYXRlVmlzaWJpbGl0eSk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdyYXRlY2hhbmdlJywgdGhpcy51cGRhdGVMYWJlbCk7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICBsZXQgZWwgPSBzdXBlci5jcmVhdGVFbCgpO1xuXG4gICAgdGhpcy5sYWJlbEVsXyA9IERvbS5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBsYXliYWNrLXJhdGUtdmFsdWUnLFxuICAgICAgaW5uZXJIVE1MOiAxLjBcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMubGFiZWxFbF8pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLy8gTWVudSBjcmVhdGlvblxuICBjcmVhdGVNZW51KCkge1xuICAgIGxldCBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXIoKSk7XG4gICAgbGV0IHJhdGVzID0gdGhpcy5wbGF5ZXIoKS5vcHRpb25zKClbJ3BsYXliYWNrUmF0ZXMnXTtcblxuICAgIGlmIChyYXRlcykge1xuICAgICAgZm9yIChsZXQgaSA9IHJhdGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG1lbnUuYWRkQ2hpbGQoXG4gICAgICAgICAgbmV3IFBsYXliYWNrUmF0ZU1lbnVJdGVtKHRoaXMucGxheWVyKCksIHsgJ3JhdGUnOiByYXRlc1tpXSArICd4J30pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH1cblxuICB1cGRhdGVBUklBQXR0cmlidXRlcygpIHtcbiAgICAvLyBDdXJyZW50IHBsYXliYWNrIHJhdGVcbiAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSk7XG4gIH1cblxuICBoYW5kbGVDbGljaygpIHtcbiAgICAvLyBzZWxlY3QgbmV4dCByYXRlIG9wdGlvblxuICAgIGxldCBjdXJyZW50UmF0ZSA9IHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCk7XG4gICAgbGV0IHJhdGVzID0gdGhpcy5wbGF5ZXIoKS5vcHRpb25zKClbJ3BsYXliYWNrUmF0ZXMnXTtcbiAgICAvLyB0aGlzIHdpbGwgc2VsZWN0IGZpcnN0IG9uZSBpZiB0aGUgbGFzdCBvbmUgY3VycmVudGx5IHNlbGVjdGVkXG4gICAgbGV0IG5ld1JhdGUgPSByYXRlc1swXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8cmF0ZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICBpZiAocmF0ZXNbaV0gPiBjdXJyZW50UmF0ZSkge1xuICAgICAgICBuZXdSYXRlID0gcmF0ZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZShuZXdSYXRlKTtcbiAgfVxuXG4gIHBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXIoKS50ZWNoXG4gICAgICAmJiB0aGlzLnBsYXllcigpLnRlY2hbJ2ZlYXR1cmVzUGxheWJhY2tSYXRlJ11cbiAgICAgICYmIHRoaXMucGxheWVyKCkub3B0aW9ucygpWydwbGF5YmFja1JhdGVzJ11cbiAgICAgICYmIHRoaXMucGxheWVyKCkub3B0aW9ucygpWydwbGF5YmFja1JhdGVzJ10ubGVuZ3RoID4gMFxuICAgIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHBsYXliYWNrIHJhdGUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vIHBsYXliYWNrIHJhdGUgb3B0aW9ucyB0byBzZWxlY3RcbiAgICovXG4gIHVwZGF0ZVZpc2liaWxpdHkoKSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYnV0dG9uIGxhYmVsIHdoZW4gcmF0ZSBjaGFuZ2VkXG4gICAqL1xuICB1cGRhdGVMYWJlbCgpIHtcbiAgICBpZiAodGhpcy5wbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhpcy5sYWJlbEVsXy5pbm5lckhUTUwgPSB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpICsgJ3gnO1xuICAgIH1cbiAgfVxuXG59XG5cblBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnUGxheWJhY2sgUmF0ZSc7XG5QbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jbGFzc05hbWUgPSAndmpzLXBsYXliYWNrLXJhdGUnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IFBsYXliYWNrUmF0ZU1lbnVCdXR0b247XG4iLCJpbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi4vLi4vbWVudS9tZW51LWl0ZW0uanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuXG4vKipcbiAqIFRoZSBzcGVjaWZpYyBtZW51IGl0ZW0gdHlwZSBmb3Igc2VsZWN0aW5nIGEgcGxheWJhY2sgcmF0ZVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQbGF5YmFja1JhdGVNZW51SXRlbSBleHRlbmRzIE1lbnVJdGVtIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIGxldCBsYWJlbCA9IG9wdGlvbnNbJ3JhdGUnXTtcbiAgICBsZXQgcmF0ZSA9IHBhcnNlRmxvYXQobGFiZWwsIDEwKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnNbJ2xhYmVsJ10gPSBsYWJlbDtcbiAgICBvcHRpb25zWydzZWxlY3RlZCddID0gcmF0ZSA9PT0gMTtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMucmF0ZSA9IHJhdGU7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCB0aGlzLnVwZGF0ZSk7XG4gIH1cblxuICBoYW5kbGVDbGljaygpIHtcbiAgICBzdXBlci5oYW5kbGVDbGljaygpO1xuICAgIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKHRoaXMucmF0ZSk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpID09PSB0aGlzLnJhdGUpO1xuICB9XG5cbn1cblxuUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmNvbnRlbnRFbFR5cGUgPSAnYnV0dG9uJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5YmFja1JhdGVNZW51SXRlbScsIFBsYXliYWNrUmF0ZU1lbnVJdGVtKTtcbmV4cG9ydCBkZWZhdWx0IFBsYXliYWNrUmF0ZU1lbnVJdGVtO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgRG9tIGZyb20gJy4uLy4uL3V0aWxzL2RvbS5qcyc7XG5cbi8qKlxuICogU2hvd3MgbG9hZCBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBMb2FkUHJvZ3Jlc3NCYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3Byb2dyZXNzJywgdGhpcy51cGRhdGUpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZC1wcm9ncmVzcycsXG4gICAgICBpbm5lckhUTUw6IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48c3Bhbj4ke3RoaXMubG9jYWxpemUoJ0xvYWRlZCcpfTwvc3Bhbj46IDAlPC9zcGFuPmBcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgYnVmZmVyZWQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWQoKTtcbiAgICBsZXQgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICBsZXQgYnVmZmVyZWRFbmQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWRFbmQoKTtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmVsXy5jaGlsZHJlbjtcblxuICAgIC8vIGdldCB0aGUgcGVyY2VudCB3aWR0aCBvZiBhIHRpbWUgY29tcGFyZWQgdG8gdGhlIHRvdGFsIGVuZFxuICAgIGxldCBwZXJjZW50aWZ5ID0gZnVuY3Rpb24gKHRpbWUsIGVuZCl7XG4gICAgICBsZXQgcGVyY2VudCA9ICh0aW1lIC8gZW5kKSB8fCAwOyAvLyBubyBOYU5cbiAgICAgIHJldHVybiAoKHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50KSAqIDEwMCkgKyAnJSc7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICAgIHRoaXMuZWxfLnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShidWZmZXJlZEVuZCwgZHVyYXRpb24pO1xuXG4gICAgLy8gYWRkIGNoaWxkIGVsZW1lbnRzIHRvIHJlcHJlc2VudCB0aGUgaW5kaXZpZHVhbCBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgbGV0IGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgIGxldCBwYXJ0ID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBwYXJ0ID0gdGhpcy5lbF8uYXBwZW5kQ2hpbGQoRG9tLmNyZWF0ZUVsKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIHBlcmNlbnQgYmFzZWQgb24gdGhlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXIgKGJ1ZmZlcmVkRW5kKVxuICAgICAgcGFydC5zdHlsZS5sZWZ0ID0gcGVyY2VudGlmeShzdGFydCwgYnVmZmVyZWRFbmQpO1xuICAgICAgcGFydC5zdHlsZS53aWR0aCA9IHBlcmNlbnRpZnkoZW5kIC0gc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdW51c2VkIGJ1ZmZlcmVkIHJhbmdlIGVsZW1lbnRzXG4gICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA+IGJ1ZmZlcmVkLmxlbmd0aDsgaS0tKSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVDaGlsZChjaGlsZHJlbltpLTFdKTtcbiAgICB9XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRQcm9ncmVzc0JhcicsIExvYWRQcm9ncmVzc0Jhcik7XG5leHBvcnQgZGVmYXVsdCBMb2FkUHJvZ3Jlc3NCYXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5cbi8qKlxuICogU2hvd3MgcGxheSBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQbGF5UHJvZ3Jlc3NCYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBsYXktcHJvZ3Jlc3MnLFxuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JHt0aGlzLmxvY2FsaXplKCdQcm9ncmVzcycpfTwvc3Bhbj46IDAlPC9zcGFuPmBcbiAgICB9KTtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheVByb2dyZXNzQmFyJywgUGxheVByb2dyZXNzQmFyKTtcbmV4cG9ydCBkZWZhdWx0IFBsYXlQcm9ncmVzc0JhcjtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCBTZWVrQmFyIGZyb20gJy4vc2Vlay1iYXIuanMnO1xuXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQcm9ncmVzc0NvbnRyb2wgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wcm9ncmVzcy1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuICB9XG59XG5cblByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiB7XG4gICAgJ3NlZWtCYXInOiB7fVxuICB9XG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1Byb2dyZXNzQ29udHJvbCcsIFByb2dyZXNzQ29udHJvbCk7XG5leHBvcnQgZGVmYXVsdCBQcm9ncmVzc0NvbnRyb2w7XG4iLCJpbXBvcnQgU2xpZGVyIGZyb20gJy4uLy4uL3NsaWRlci9zbGlkZXIuanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuaW1wb3J0IExvYWRQcm9ncmVzc0JhciBmcm9tICcuL2xvYWQtcHJvZ3Jlc3MtYmFyLmpzJztcbmltcG9ydCBQbGF5UHJvZ3Jlc3NCYXIgZnJvbSAnLi9wbGF5LXByb2dyZXNzLWJhci5qcyc7XG5pbXBvcnQgU2Vla0hhbmRsZSBmcm9tICcuL3NlZWstaGFuZGxlLmpzJztcbmltcG9ydCAqIGFzIEZuIGZyb20gJy4uLy4uL3V0aWxzL2ZuLmpzJztcbmltcG9ydCBmb3JtYXRUaW1lIGZyb20gJy4uLy4uL3V0aWxzL2Zvcm1hdC10aW1lLmpzJztcbmltcG9ydCByb3VuZEZsb2F0IGZyb20gJy4uLy4uL3V0aWxzL3JvdW5kLWZsb2F0LmpzJztcblxuLyoqXG4gKiBTZWVrIEJhciBhbmQgaG9sZGVyIGZvciB0aGUgcHJvZ3Jlc3MgYmFyc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTZWVrQmFyIGV4dGVuZHMgU2xpZGVyIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGVBUklBQXR0cmlidXRlcyk7XG4gICAgcGxheWVyLnJlYWR5KEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGVBUklBQXR0cmlidXRlcykpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtaG9sZGVyJyxcbiAgICAgICdhcmlhLWxhYmVsJzogJ3ZpZGVvIHByb2dyZXNzIGJhcidcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCkge1xuICAgICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgICAgbGV0IHRpbWUgPSAodGhpcy5wbGF5ZXJfLnNjcnViYmluZygpKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCByb3VuZEZsb2F0KHRoaXMuZ2V0UGVyY2VudCgpKjEwMCwgMikpOyAvLyBtYWNoaW5lIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAocGVyY2VudGFnZSBjb21wbGV0ZSlcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCBmb3JtYXRUaW1lKHRpbWUsIHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSk7IC8vIGh1bWFuIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAodGltZSBjb21wbGV0ZSlcbiAgfVxuXG4gIGdldFBlcmNlbnQoKSB7XG4gICAgbGV0IHBlcmNlbnQgPSB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIHJldHVybiBwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudDtcbiAgfVxuXG4gIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHN1cGVyLmhhbmRsZU1vdXNlRG93bihldmVudCk7XG5cbiAgICB0aGlzLnBsYXllcl8uc2NydWJiaW5nKHRydWUpO1xuXG4gICAgdGhpcy52aWRlb1dhc1BsYXlpbmcgPSAhdGhpcy5wbGF5ZXJfLnBhdXNlZCgpO1xuICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICB9XG5cbiAgaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgbGV0IG5ld1RpbWUgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSAqIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgLy8gRG9uJ3QgbGV0IHZpZGVvIGVuZCB3aGlsZSBzY3J1YmJpbmcuXG4gICAgaWYgKG5ld1RpbWUgPT09IHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7IG5ld1RpbWUgPSBuZXdUaW1lIC0gMC4xOyB9XG5cbiAgICAvLyBTZXQgbmV3IHRpbWUgKHRlbGwgcGxheWVyIHRvIHNlZWsgdG8gbmV3IHRpbWUpXG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKG5ld1RpbWUpO1xuICB9XG5cbiAgaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHN1cGVyLmhhbmRsZU1vdXNlVXAoZXZlbnQpO1xuXG4gICAgdGhpcy5wbGF5ZXJfLnNjcnViYmluZyhmYWxzZSk7XG4gICAgaWYgKHRoaXMudmlkZW9XYXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0ZXBGb3J3YXJkKCkge1xuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSh0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSArIDUpOyAvLyBtb3JlIHF1aWNrbHkgZmFzdCBmb3J3YXJkIGZvciBrZXlib2FyZC1vbmx5IHVzZXJzXG4gIH1cblxuICBzdGVwQmFjaygpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLSA1KTsgLy8gbW9yZSBxdWlja2x5IHJld2luZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICB9XG5cbn1cblxuU2Vla0Jhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiB7XG4gICAgJ2xvYWRQcm9ncmVzc0Jhcic6IHt9LFxuICAgICdwbGF5UHJvZ3Jlc3NCYXInOiB7fSxcbiAgICAnc2Vla0hhbmRsZSc6IHt9XG4gIH0sXG4gICdiYXJOYW1lJzogJ3BsYXlQcm9ncmVzc0JhcicsXG4gICdoYW5kbGVOYW1lJzogJ3NlZWtIYW5kbGUnXG59O1xuXG5TZWVrQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd0aW1ldXBkYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTZWVrQmFyJywgU2Vla0Jhcik7XG5leHBvcnQgZGVmYXVsdCBTZWVrQmFyO1xuIiwiaW1wb3J0IFNsaWRlckhhbmRsZSBmcm9tICcuLi8uLi9zbGlkZXIvc2xpZGVyLWhhbmRsZS5qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgZm9ybWF0VGltZSBmcm9tICcuLi8uLi91dGlscy9mb3JtYXQtdGltZS5qcyc7XG5cbi8qKlxuICogVGhlIFNlZWsgSGFuZGxlIHNob3dzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZCBkdXJpbmcgcGxheWJhY2ssXG4gKiBhbmQgY2FuIGJlIGRyYWdnZWQgdG8gYWRqdXN0IHRoZSBwbGF5aGVhZC5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU2Vla0hhbmRsZSBleHRlbmRzIFNsaWRlckhhbmRsZSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXNlZWstaGFuZGxlJyxcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQ29udGVudCgpIHtcbiAgICBsZXQgdGltZSA9ICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5lbF8uaW5uZXJIVE1MID0gYDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiR7Zm9ybWF0VGltZSh0aW1lLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSl9PC9zcGFuPmA7XG4gIH1cblxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgaGFuZGxlIGNvbnRlbnQsIHdoaWNoIG1heSBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblNlZWtIYW5kbGUucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9ICcwMDowMCc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU2Vla0hhbmRsZScsIFNlZWtIYW5kbGUpO1xuZXhwb3J0IGRlZmF1bHQgU2Vla0hhbmRsZTtcbiIsImltcG9ydCBTcGFjZXIgZnJvbSAnLi9zcGFjZXIuanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuXG4vKipcbiAqIFNwYWNlciBzcGVjaWZpY2FsbHkgbWVhbnQgdG8gYmUgdXNlZCBhcyBhbiBpbnNlcnRpb24gcG9pbnQgZm9yIG5ldyBwbHVnaW5zLCBldGMuXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JlY3Q9fSBvcHRpb25zXG4gKi9cbmNsYXNzIEN1c3RvbUNvbnRyb2xTcGFjZXIgZXh0ZW5kcyBTcGFjZXIge1xuICBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiBgdmpzLWN1c3RvbS1jb250cm9sLXNwYWNlciAke3N1cGVyLmJ1aWxkQ1NTQ2xhc3MoKX1gO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9KTtcbiAgfVxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0N1c3RvbUNvbnRyb2xTcGFjZXInLCBDdXN0b21Db250cm9sU3BhY2VyKTtcbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUNvbnRyb2xTcGFjZXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5cbi8qKlxuICogSnVzdCBhbiBlbXB0eSBzcGFjZXIgZWxlbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGFwcGVuZCBwb2ludCBmb3IgcGx1Z2lucywgZXRjLlxuICogQWxzbyBjYW4gYmUgdXNlZCB0byBjcmVhdGUgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKi9cbmNsYXNzIFNwYWNlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIGB2anMtc3BhY2VyICR7c3VwZXIuYnVpbGRDU1NDbGFzcygpfWA7XG4gIH1cblxuICBjcmVhdGVFbChwcm9wcykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuICB9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3BhY2VyJywgU3BhY2VyKTtcblxuZXhwb3J0IGRlZmF1bHQgU3BhY2VyO1xuIiwiaW1wb3J0IFRleHRUcmFja01lbnVJdGVtIGZyb20gJy4vdGV4dC10cmFjay1tZW51LWl0ZW0uanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuXG5jbGFzcyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zWyd0cmFjayddID0ge1xuICAgICAgJ2tpbmQnOiBvcHRpb25zWydraW5kJ10sXG4gICAgICAncGxheWVyJzogcGxheWVyLFxuICAgICAgJ2xhYmVsJzogb3B0aW9uc1sna2luZCddICsgJyBzZXR0aW5ncycsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy10ZXh0dHJhY2stc2V0dGluZ3MnKTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMucGxheWVyKCkuZ2V0Q2hpbGQoJ3RleHRUcmFja1NldHRpbmdzJykuc2hvdygpO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDYXB0aW9uU2V0dGluZ3NNZW51SXRlbScsIENhcHRpb25TZXR0aW5nc01lbnVJdGVtKTtcbmV4cG9ydCBkZWZhdWx0IENhcHRpb25TZXR0aW5nc01lbnVJdGVtO1xuIiwiaW1wb3J0IFRleHRUcmFja0J1dHRvbiBmcm9tICcuL3RleHQtdHJhY2stYnV0dG9uLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSBmcm9tICcuL2NhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzJztcblxuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjYXB0aW9uc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDYXB0aW9uc0J1dHRvbiBleHRlbmRzIFRleHRUcmFja0J1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCByZWFkeSl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywnQ2FwdGlvbnMgTWVudScpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGxldCB0aHJlc2hvbGQgPSAyO1xuICAgIHN1cGVyLnVwZGF0ZSgpO1xuXG4gICAgLy8gaWYgbmF0aXZlLCB0aGVuIHRocmVzaG9sZCBpcyAxIGJlY2F1c2Ugbm8gc2V0dGluZ3MgYnV0dG9uXG4gICAgaWYgKHRoaXMucGxheWVyKCkudGVjaCAmJiB0aGlzLnBsYXllcigpLnRlY2hbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gdGhyZXNob2xkKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlSXRlbXMoKSB7XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICBpZiAoISh0aGlzLnBsYXllcigpLnRlY2ggJiYgdGhpcy5wbGF5ZXIoKS50ZWNoWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyAna2luZCc6IHRoaXMua2luZF8gfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5jcmVhdGVJdGVtcyhpdGVtcyk7XG4gIH1cblxufVxuXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2FwdGlvbnMnO1xuQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnQ2FwdGlvbnMnO1xuQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNsYXNzTmFtZSA9ICd2anMtY2FwdGlvbnMtYnV0dG9uJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDYXB0aW9uc0J1dHRvbicsIENhcHRpb25zQnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IENhcHRpb25zQnV0dG9uO1xuIiwiaW1wb3J0IFRleHRUcmFja0J1dHRvbiBmcm9tICcuL3RleHQtdHJhY2stYnV0dG9uLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCBUZXh0VHJhY2tNZW51SXRlbSBmcm9tICcuL3RleHQtdHJhY2stbWVudS1pdGVtLmpzJztcbmltcG9ydCBDaGFwdGVyc1RyYWNrTWVudUl0ZW0gZnJvbSAnLi9jaGFwdGVycy10cmFjay1tZW51LWl0ZW0uanMnO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi4vLi4vbWVudS9tZW51LmpzJztcbmltcG9ydCAqIGFzIERvbSBmcm9tICcuLi8uLi91dGlscy9kb20uanMnO1xuaW1wb3J0ICogYXMgRm4gZnJvbSAnLi4vLi4vdXRpbHMvZm4uanMnO1xuaW1wb3J0IHRvVGl0bGVDYXNlIGZyb20gJy4uLy4uL3V0aWxzL3RvLXRpdGxlLWNhc2UuanMnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxuLy8gQ2hhcHRlcnMgYWN0IG11Y2ggZGlmZmVyZW50bHkgdGhhbiBvdGhlciB0ZXh0IHRyYWNrc1xuLy8gQ3VlcyBhcmUgbmF2aWdhdGlvbiB2cy4gb3RoZXIgdHJhY2tzIG9mIGFsdGVybmF0aXZlIGxhbmd1YWdlc1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjaGFwdGVyc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDaGFwdGVyc0J1dHRvbiBleHRlbmRzIFRleHRUcmFja0J1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCByZWFkeSl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywnQ2hhcHRlcnMgTWVudScpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIHRleHQgdHJhY2tcbiAgY3JlYXRlSXRlbXMoKSB7XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICBsZXQgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgIGlmICh0cmFja1sna2luZCddID09PSB0aGlzLmtpbmRfKSB7XG4gICAgICAgIGl0ZW1zLnB1c2gobmV3IFRleHRUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICAgICd0cmFjayc6IHRyYWNrXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBjcmVhdGVNZW51KCkge1xuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpIHx8IFtdO1xuICAgIGxldCBjaGFwdGVyc1RyYWNrO1xuICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT09IHRoaXMua2luZF8pIHtcbiAgICAgICAgaWYgKCF0cmFjay5jdWVzKSB7XG4gICAgICAgICAgdHJhY2tbJ21vZGUnXSA9ICdoaWRkZW4nO1xuICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgICAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgd2F5IG9mIGRvaW5nIHRoaXMgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzE4NjRcbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChGbi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVNZW51KCk7XG4gICAgICAgICAgfSksIDEwMCk7XG4gICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOmZhbHNlICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhcHRlcnNUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1lbnUgPSB0aGlzLm1lbnU7XG4gICAgaWYgKG1lbnUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyXyk7XG4gICAgICBtZW51LmNvbnRlbnRFbCgpLmFwcGVuZENoaWxkKERvbS5jcmVhdGVFbCgnbGknLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LXRpdGxlJyxcbiAgICAgICAgaW5uZXJIVE1MOiB0b1RpdGxlQ2FzZSh0aGlzLmtpbmRfKSxcbiAgICAgICAgdGFiaW5kZXg6IC0xXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYXB0ZXJzVHJhY2spIHtcbiAgICAgIGxldCBjdWVzID0gY2hhcHRlcnNUcmFja1snY3VlcyddLCBjdWU7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgICBsZXQgbWkgPSBuZXcgQ2hhcHRlcnNUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICAgICd0cmFjayc6IGNoYXB0ZXJzVHJhY2ssXG4gICAgICAgICAgJ2N1ZSc6IGN1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtcy5wdXNoKG1pKTtcblxuICAgICAgICBtZW51LmFkZENoaWxkKG1pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH1cblxufVxuXG5DaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2hhcHRlcnMnO1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnQ2hhcHRlcnMnO1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNsYXNzTmFtZSA9ICd2anMtY2hhcHRlcnMtYnV0dG9uJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDaGFwdGVyc0J1dHRvbicsIENoYXB0ZXJzQnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IENoYXB0ZXJzQnV0dG9uO1xuIiwiaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4uLy4uL21lbnUvbWVudS1pdGVtLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIEZuIGZyb20gJy4uLy4uL3V0aWxzL2ZuLmpzJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQ2hhcHRlcnNUcmFja01lbnVJdGVtIGV4dGVuZHMgTWVudUl0ZW0ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgbGV0IHRyYWNrID0gb3B0aW9uc1sndHJhY2snXTtcbiAgICBsZXQgY3VlID0gb3B0aW9uc1snY3VlJ107XG4gICAgbGV0IGN1cnJlbnRUaW1lID0gcGxheWVyLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zWydsYWJlbCddID0gY3VlLnRleHQ7XG4gICAgb3B0aW9uc1snc2VsZWN0ZWQnXSA9IChjdWVbJ3N0YXJ0VGltZSddIDw9IGN1cnJlbnRUaW1lICYmIGN1cnJlbnRUaW1lIDwgY3VlWydlbmRUaW1lJ10pO1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgdGhpcy5jdWUgPSBjdWU7XG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZSkpO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgc3VwZXIuaGFuZGxlQ2xpY2soKTtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5jdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGxldCBjdWUgPSB0aGlzLmN1ZTtcbiAgICBsZXQgY3VycmVudFRpbWUgPSB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIC8vIHZqcy5sb2coY3VycmVudFRpbWUsIGN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMuc2VsZWN0ZWQoY3VlWydzdGFydFRpbWUnXSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZVsnZW5kVGltZSddKTtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNUcmFja01lbnVJdGVtJywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcbmV4cG9ydCBkZWZhdWx0IENoYXB0ZXJzVHJhY2tNZW51SXRlbTtcbiIsImltcG9ydCBUZXh0VHJhY2tNZW51SXRlbSBmcm9tICcuL3RleHQtdHJhY2stbWVudS1pdGVtLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWwgbWVudSBpdGVtIGZvciB0dXJuaW5nIG9mIGEgc3BlY2lmaWMgdHlwZSBvZiB0ZXh0IHRyYWNrXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE9mZlRleHRUcmFja01lbnVJdGVtIGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW0ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgLy8gQ3JlYXRlIHBzZXVkbyB0cmFjayBpbmZvXG4gICAgLy8gUmVxdWlyZXMgb3B0aW9uc1sna2luZCddXG4gICAgb3B0aW9uc1sndHJhY2snXSA9IHtcbiAgICAgICdraW5kJzogb3B0aW9uc1sna2luZCddLFxuICAgICAgJ3BsYXllcic6IHBsYXllcixcbiAgICAgICdsYWJlbCc6IG9wdGlvbnNbJ2tpbmQnXSArICcgb2ZmJyxcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICAnbW9kZSc6ICdkaXNhYmxlZCdcbiAgICB9O1xuXG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLnNlbGVjdGVkKHRydWUpO1xuICB9XG5cbiAgaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KXtcbiAgICBsZXQgdHJhY2tzID0gdGhpcy5wbGF5ZXIoKS50ZXh0VHJhY2tzKCk7XG4gICAgbGV0IHNlbGVjdGVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT09IHRoaXMudHJhY2tbJ2tpbmQnXSAmJiB0cmFja1snbW9kZSddID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZChzZWxlY3RlZCk7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ09mZlRleHRUcmFja01lbnVJdGVtJywgT2ZmVGV4dFRyYWNrTWVudUl0ZW0pO1xuZXhwb3J0IGRlZmF1bHQgT2ZmVGV4dFRyYWNrTWVudUl0ZW07XG4iLCJpbXBvcnQgVGV4dFRyYWNrQnV0dG9uIGZyb20gJy4vdGV4dC10cmFjay1idXR0b24uanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIHN1YnRpdGxlc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTdWJ0aXRsZXNCdXR0b24gZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucywgcmVhZHkpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucywgcmVhZHkpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsJ1N1YnRpdGxlcyBNZW51Jyk7XG4gIH1cblxufVxuXG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ3N1YnRpdGxlcyc7XG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnU3VidGl0bGVzJztcblN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ3Zqcy1zdWJ0aXRsZXMtYnV0dG9uJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJ0aXRsZXNCdXR0b24nLCBTdWJ0aXRsZXNCdXR0b24pO1xuZXhwb3J0IGRlZmF1bHQgU3VidGl0bGVzQnV0dG9uO1xuIiwiaW1wb3J0IE1lbnVCdXR0b24gZnJvbSAnLi4vLi4vbWVudS9tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBGbiBmcm9tICcuLi8uLi91dGlscy9mbi5qcyc7XG5pbXBvcnQgVGV4dFRyYWNrTWVudUl0ZW0gZnJvbSAnLi90ZXh0LXRyYWNrLW1lbnUtaXRlbS5qcyc7XG5pbXBvcnQgT2ZmVGV4dFRyYWNrTWVudUl0ZW0gZnJvbSAnLi9vZmYtdGV4dC10cmFjay1tZW51LWl0ZW0uanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHRleHQgdHJhY2sgdHlwZXMgKGUuZy4gc3VidGl0bGVzKVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUZXh0VHJhY2tCdXR0b24gZXh0ZW5kcyBNZW51QnV0dG9uIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICBsZXQgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA8PSAxKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB1cGRhdGVIYW5kbGVyID0gRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZSk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG5cbiAgICB0aGlzLnBsYXllcl8ub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICBjcmVhdGVJdGVtcyhpdGVtcz1bXSkge1xuICAgIC8vIEFkZCBhbiBPRkYgbWVudSBpdGVtIHRvIHR1cm4gYWxsIHRyYWNrcyBvZmZcbiAgICBpdGVtcy5wdXNoKG5ldyBPZmZUZXh0VHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsgJ2tpbmQnOiB0aGlzLmtpbmRfIH0pKTtcblxuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAvLyBvbmx5IGFkZCB0cmFja3MgdGhhdCBhcmUgb2YgdGhlIGFwcHJvcHJpYXRlIGtpbmQgYW5kIGhhdmUgYSBsYWJlbFxuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT09IHRoaXMua2luZF8pIHtcbiAgICAgICAgaXRlbXMucHVzaChuZXcgVGV4dFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgICAgJ3RyYWNrJzogdHJhY2tcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrQnV0dG9uJywgVGV4dFRyYWNrQnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IFRleHRUcmFja0J1dHRvbjtcbiIsImltcG9ydCBNZW51SXRlbSBmcm9tICcuLi8uLi9tZW51L21lbnUtaXRlbS5qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBGbiBmcm9tICcuLi8uLi91dGlscy9mbi5qcyc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBsYW5ndWFnZSB3aXRoaW4gYSB0ZXh0IHRyYWNrIGtpbmRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVGV4dFRyYWNrTWVudUl0ZW0gZXh0ZW5kcyBNZW51SXRlbSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBsZXQgdHJhY2sgPSBvcHRpb25zWyd0cmFjayddO1xuICAgIGxldCB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9uc1snbGFiZWwnXSA9IHRyYWNrWydsYWJlbCddIHx8IHRyYWNrWydsYW5ndWFnZSddIHx8ICdVbmtub3duJztcbiAgICBvcHRpb25zWydzZWxlY3RlZCddID0gdHJhY2tbJ2RlZmF1bHQnXSB8fCB0cmFja1snbW9kZSddID09PSAnc2hvd2luZyc7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcblxuICAgIGlmICh0cmFja3MpIHtcbiAgICAgIGxldCBjaGFuZ2VIYW5kbGVyID0gRm4uYmluZCh0aGlzLCB0aGlzLmhhbmRsZVRyYWNrc0NoYW5nZSk7XG5cbiAgICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaU9TNyBkb2Vzbid0IGRpc3BhdGNoIGNoYW5nZSBldmVudHMgdG8gVGV4dFRyYWNrTGlzdHMgd2hlbiBhblxuICAgIC8vIGFzc29jaWF0ZWQgdHJhY2sncyBtb2RlIGNoYW5nZXMuIFdpdGhvdXQgc29tZXRoaW5nIGxpa2VcbiAgICAvLyBPYmplY3Qub2JzZXJ2ZSgpIChhbHNvIG5vdCBwcmVzZW50IG9uIGlPUzcpLCBpdCdzIG5vdFxuICAgIC8vIHBvc3NpYmxlIHRvIGRldGVjdCBjaGFuZ2VzIHRvIHRoZSBtb2RlIGF0dHJpYnV0ZSBhbmQgcG9seWZpbGxcbiAgICAvLyB0aGUgY2hhbmdlIGV2ZW50LiBBcyBhIHBvb3Igc3Vic3RpdHV0ZSwgd2UgbWFudWFsbHkgZGlzcGF0Y2hcbiAgICAvLyBjaGFuZ2UgZXZlbnRzIHdoZW5ldmVyIHRoZSBjb250cm9scyBtb2RpZnkgdGhlIG1vZGUuXG4gICAgaWYgKHRyYWNrcyAmJiB0cmFja3Mub25jaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGV2ZW50O1xuXG4gICAgICB0aGlzLm9uKFsndGFwJywgJ2NsaWNrJ10sIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5FdmVudCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBBbmRyb2lkIDIuMyB0aHJvd3MgYW4gSWxsZWdhbCBDb25zdHJ1Y3RvciBlcnJvciBmb3Igd2luZG93LkV2ZW50XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IHdpbmRvdy5FdmVudCgnY2hhbmdlJyk7XG4gICAgICAgICAgfSBjYXRjaChlcnIpe31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnY2hhbmdlJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFja3MuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGxldCBraW5kID0gdGhpcy50cmFja1sna2luZCddO1xuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgc3VwZXIuaGFuZGxlQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKCF0cmFja3MpIHJldHVybjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFja1sna2luZCddICE9PSBraW5kKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2sgPT09IHRoaXMudHJhY2spIHtcbiAgICAgICAgdHJhY2tbJ21vZGUnXSA9ICdzaG93aW5nJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNrWydtb2RlJ10gPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCl7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnRyYWNrWydtb2RlJ10gPT09ICdzaG93aW5nJyk7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja01lbnVJdGVtJywgVGV4dFRyYWNrTWVudUl0ZW0pO1xuZXhwb3J0IGRlZmF1bHQgVGV4dFRyYWNrTWVudUl0ZW07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi4vLi4vdXRpbHMvZG9tLmpzJztcbmltcG9ydCBmb3JtYXRUaW1lIGZyb20gJy4uLy4uL3V0aWxzL2Zvcm1hdC10aW1lLmpzJztcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgY3VycmVudCB0aW1lXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQ3VycmVudFRpbWVEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jdXJyZW50LXRpbWUgdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IERvbS5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWN1cnJlbnQtdGltZS1kaXNwbGF5JyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPkN1cnJlbnQgVGltZSA8L3NwYW4+JyArICcwOjAwJywgLy8gbGFiZWwgdGhlIGN1cnJlbnQgdGltZSBmb3Igc2NyZWVuIHJlYWRlciB1c2Vyc1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnIC8vIHRlbGwgc2NyZWVuIHJlYWRlcnMgbm90IHRvIGF1dG9tYXRpY2FsbHkgcmVhZCB0aGUgdGltZSBhcyBpdCBjaGFuZ2VzXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHVwZGF0ZUNvbnRlbnQoKSB7XG4gICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgIGxldCB0aW1lID0gKHRoaXMucGxheWVyXy5zY3J1YmJpbmcpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcbiAgICBsZXQgbG9jYWxpemVkVGV4dCA9IHRoaXMubG9jYWxpemUoJ0N1cnJlbnQgVGltZScpO1xuICAgIGxldCBmb3JtYXR0ZWRUaW1lID0gZm9ybWF0VGltZSh0aW1lLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gICAgdGhpcy5jb250ZW50RWxfLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke2xvY2FsaXplZFRleHR9PC9zcGFuPiAke2Zvcm1hdHRlZFRpbWV9YDtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ3VycmVudFRpbWVEaXNwbGF5JywgQ3VycmVudFRpbWVEaXNwbGF5KTtcbmV4cG9ydCBkZWZhdWx0IEN1cnJlbnRUaW1lRGlzcGxheTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIERvbSBmcm9tICcuLi8uLi91dGlscy9kb20uanMnO1xuaW1wb3J0IGZvcm1hdFRpbWUgZnJvbSAnLi4vLi4vdXRpbHMvZm9ybWF0LXRpbWUuanMnO1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBkdXJhdGlvblxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIER1cmF0aW9uRGlzcGxheSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gdGhpcyBtaWdodCBuZWVkIHRvIGJlIGNoYW5nZWQgdG8gJ2R1cmF0aW9uY2hhbmdlJyBpbnN0ZWFkIG9mICd0aW1ldXBkYXRlJyBldmVudHVhbGx5LFxuICAgIC8vIGhvd2V2ZXIgdGhlIGR1cmF0aW9uY2hhbmdlIGV2ZW50IGZpcmVzIGJlZm9yZSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSBpcyBzZXQsXG4gICAgLy8gc28gdGhlIHZhbHVlIGNhbm5vdCBiZSB3cml0dGVuIG91dCB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICAvLyBPbmNlIHRoZSBvcmRlciBvZiBkdXJhdGlvbmNoYW5nZSBhbmQgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkgYmVpbmcgc2V0IGlzIGZpZ3VyZWQgb3V0LFxuICAgIC8vIHRoaXMgY2FuIGJlIHVwZGF0ZWQuXG4gICAgdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGVDb250ZW50KTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIGxldCBlbCA9IHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtZHVyYXRpb24gdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IERvbS5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWR1cmF0aW9uLWRpc3BsYXknLFxuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHt0aGlzLmxvY2FsaXplKCdEdXJhdGlvbiBUaW1lJyl9PC9zcGFuPiAwOjAwYCwgLy8gbGFiZWwgdGhlIGR1cmF0aW9uIHRpbWUgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJyAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB1cGRhdGVDb250ZW50KCkge1xuICAgIGxldCBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgbGV0IGxvY2FsaXplZFRleHQgPSB0aGlzLmxvY2FsaXplKCdEdXJhdGlvbiBUaW1lJyk7XG4gICAgICBsZXQgZm9ybWF0dGVkVGltZSA9IGZvcm1hdFRpbWUoZHVyYXRpb24pO1xuICAgICAgdGhpcy5jb250ZW50RWxfLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke2xvY2FsaXplZFRleHR9PC9zcGFuPiAke2Zvcm1hdHRlZFRpbWV9YDsgLy8gbGFiZWwgdGhlIGR1cmF0aW9uIHRpbWUgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnNcbiAgICB9XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0R1cmF0aW9uRGlzcGxheScsIER1cmF0aW9uRGlzcGxheSk7XG5leHBvcnQgZGVmYXVsdCBEdXJhdGlvbkRpc3BsYXk7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi4vLi4vdXRpbHMvZG9tLmpzJztcbmltcG9ydCBmb3JtYXRUaW1lIGZyb20gJy4uLy4uL3V0aWxzL2Zvcm1hdC10aW1lLmpzJztcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgdGltZSBsZWZ0IGluIHRoZSB2aWRlb1xuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJlbWFpbmluZ1RpbWVEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1yZW1haW5pbmctdGltZSB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gRG9tLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcmVtYWluaW5nLXRpbWUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke3RoaXMubG9jYWxpemUoJ1JlbWFpbmluZyBUaW1lJyl9PC9zcGFuPiAtMDowMGAsIC8vIGxhYmVsIHRoZSByZW1haW5pbmcgdGltZSBmb3Igc2NyZWVuIHJlYWRlciB1c2Vyc1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnIC8vIHRlbGwgc2NyZWVuIHJlYWRlcnMgbm90IHRvIGF1dG9tYXRpY2FsbHkgcmVhZCB0aGUgdGltZSBhcyBpdCBjaGFuZ2VzXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHVwZGF0ZUNvbnRlbnQoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICBjb25zdCBsb2NhbGl6ZWRUZXh0ID0gdGhpcy5sb2NhbGl6ZSgnUmVtYWluaW5nIFRpbWUnKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBmb3JtYXRUaW1lKHRoaXMucGxheWVyXy5yZW1haW5pbmdUaW1lKCkpO1xuICAgICAgdGhpcy5jb250ZW50RWxfLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke2xvY2FsaXplZFRleHR9PC9zcGFuPiAtJHtmb3JtYXR0ZWRUaW1lfWA7XG4gICAgfVxuXG4gICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgIC8vIHZhciB0aW1lID0gKHRoaXMucGxheWVyXy5zY3J1YmJpbmcpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcbiAgICAvLyB0aGlzLmNvbnRlbnRFbF8uaW5uZXJIVE1MID0gdmpzLmZvcm1hdFRpbWUodGltZSwgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdSZW1haW5pbmdUaW1lRGlzcGxheScsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcbmV4cG9ydCBkZWZhdWx0IFJlbWFpbmluZ1RpbWVEaXNwbGF5O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuXG4vKipcbiAqIFRoZSBzZXBhcmF0b3IgYmV0d2VlbiB0aGUgY3VycmVudCB0aW1lIGFuZCBkdXJhdGlvblxuICpcbiAqIENhbiBiZSBoaWRkZW4gaWYgaXQncyBub3QgbmVlZGVkIGluIHRoZSBkZXNpZ24uXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFRpbWVEaXZpZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10aW1lLWNvbnRyb2wgdmpzLXRpbWUtZGl2aWRlcicsXG4gICAgICBpbm5lckhUTUw6ICc8ZGl2PjxzcGFuPi88L3NwYW4+PC9kaXY+J1xuICAgIH0pO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lRGl2aWRlcicsIFRpbWVEaXZpZGVyKTtcbmV4cG9ydCBkZWZhdWx0IFRpbWVEaXZpZGVyO1xuIiwiaW1wb3J0IFNsaWRlciBmcm9tICcuLi8uLi9zbGlkZXIvc2xpZGVyLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIEZuIGZyb20gJy4uLy4uL3V0aWxzL2ZuLmpzJztcbmltcG9ydCByb3VuZEZsb2F0IGZyb20gJy4uLy4uL3V0aWxzL3JvdW5kLWZsb2F0LmpzJztcblxuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbmltcG9ydCBWb2x1bWVIYW5kbGUgZnJvbSAnLi92b2x1bWUtaGFuZGxlLmpzJztcbmltcG9ydCBWb2x1bWVMZXZlbCBmcm9tICcuL3ZvbHVtZS1sZXZlbC5qcyc7XG5cbi8qKlxuICogVGhlIGJhciB0aGF0IGNvbnRhaW5zIHRoZSB2b2x1bWUgbGV2ZWwgYW5kIGNhbiBiZSBjbGlja2VkIG9uIHRvIGFkanVzdCB0aGUgbGV2ZWxcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lQmFyIGV4dGVuZHMgU2xpZGVyIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICd2b2x1bWVjaGFuZ2UnLCB0aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKTtcbiAgICBwbGF5ZXIucmVhZHkoRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKSk7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtYmFyJyxcbiAgICAgICdhcmlhLWxhYmVsJzogJ3ZvbHVtZSBsZXZlbCdcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKGZhbHNlKTtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpKTtcbiAgfVxuXG4gIGdldFBlcmNlbnQoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgICB9XG4gIH1cblxuICBzdGVwRm9yd2FyZCgpIHtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMucGxheWVyXy52b2x1bWUoKSArIDAuMSk7XG4gIH1cblxuICBzdGVwQmFjaygpIHtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMucGxheWVyXy52b2x1bWUoKSAtIDAuMSk7XG4gIH1cblxuICB1cGRhdGVBUklBQXR0cmlidXRlcygpIHtcbiAgICAvLyBDdXJyZW50IHZhbHVlIG9mIHZvbHVtZSBiYXIgYXMgYSBwZXJjZW50YWdlXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93Jywgcm91bmRGbG9hdCh0aGlzLnBsYXllcl8udm9sdW1lKCkqMTAwLCAyKSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIHJvdW5kRmxvYXQodGhpcy5wbGF5ZXJfLnZvbHVtZSgpKjEwMCwgMikrJyUnKTtcbiAgfVxuXG59XG5cblZvbHVtZUJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiB7XG4gICAgJ3ZvbHVtZUxldmVsJzoge30sXG4gICAgJ3ZvbHVtZUhhbmRsZSc6IHt9XG4gIH0sXG4gICdiYXJOYW1lJzogJ3ZvbHVtZUxldmVsJyxcbiAgJ2hhbmRsZU5hbWUnOiAndm9sdW1lSGFuZGxlJ1xufTtcblxuVm9sdW1lQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd2b2x1bWVjaGFuZ2UnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUJhcicsIFZvbHVtZUJhcik7XG5leHBvcnQgZGVmYXVsdCBWb2x1bWVCYXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG5pbXBvcnQgVm9sdW1lQmFyIGZyb20gJy4vdm9sdW1lLWJhci5qcyc7XG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgdGhlIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBWb2x1bWVDb250cm9sIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICAvLyBoaWRlIHZvbHVtZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCB0ZWNoXG4gICAgaWYgKHBsYXllci50ZWNoICYmIHBsYXllci50ZWNoWydmZWF0dXJlc1ZvbHVtZUNvbnRyb2wnXSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9XG4gICAgdGhpcy5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCBmdW5jdGlvbigpe1xuICAgICAgaWYgKHBsYXllci50ZWNoWydmZWF0dXJlc1ZvbHVtZUNvbnRyb2wnXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG4gIH1cblxufVxuXG5Wb2x1bWVDb250cm9sLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IHtcbiAgICAndm9sdW1lQmFyJzoge31cbiAgfVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVDb250cm9sJywgVm9sdW1lQ29udHJvbCk7XG5leHBvcnQgZGVmYXVsdCBWb2x1bWVDb250cm9sO1xuIiwiaW1wb3J0IFNsaWRlckhhbmRsZSBmcm9tICcuLi8uLi9zbGlkZXIvc2xpZGVyLWhhbmRsZS5qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5cbi8qKlxuICogVGhlIHZvbHVtZSBoYW5kbGUgY2FuIGJlIGRyYWdnZWQgdG8gYWRqdXN0IHRoZSB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lSGFuZGxlIGV4dGVuZHMgU2xpZGVySGFuZGxlIHtcblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWhhbmRsZSdcbiAgICB9KTtcbiAgfVxuXG59XG5cblZvbHVtZUhhbmRsZS5wcm90b3R5cGUuZGVmYXVsdFZhbHVlID0gJzAwOjAwJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVIYW5kbGUnLCBWb2x1bWVIYW5kbGUpO1xuZXhwb3J0IGRlZmF1bHQgVm9sdW1lSGFuZGxlO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuXG4vKipcbiAqIFNob3dzIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBWb2x1bWVMZXZlbCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWxldmVsJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjwvc3Bhbj4nXG4gICAgfSk7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUxldmVsJywgVm9sdW1lTGV2ZWwpO1xuZXhwb3J0IGRlZmF1bHQgVm9sdW1lTGV2ZWw7XG4iLCJpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi5qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgTWVudSBmcm9tICcuLi9tZW51L21lbnUuanMnO1xuaW1wb3J0IE1lbnVCdXR0b24gZnJvbSAnLi4vbWVudS9tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgTXV0ZVRvZ2dsZSBmcm9tICcuL211dGUtdG9nZ2xlLmpzJztcbmltcG9ydCBWb2x1bWVCYXIgZnJvbSAnLi92b2x1bWUtY29udHJvbC92b2x1bWUtYmFyLmpzJztcblxuLyoqXG4gKiBNZW51IGJ1dHRvbiB3aXRoIGEgcG9wdXAgZm9yIHNob3dpbmcgdGhlIHZvbHVtZSBzbGlkZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lTWVudUJ1dHRvbiBleHRlbmRzIE1lbnVCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIC8vIFNhbWUgbGlzdGVuZXJzIGFzIE11dGVUb2dnbGVcbiAgICB0aGlzLm9uKHBsYXllciwgJ3ZvbHVtZWNoYW5nZScsIHRoaXMudm9sdW1lVXBkYXRlKTtcblxuICAgIC8vIGhpZGUgbXV0ZSB0b2dnbGUgaWYgdGhlIGN1cnJlbnQgdGVjaCBkb2Vzbid0IHN1cHBvcnQgdm9sdW1lIGNvbnRyb2xcbiAgICBpZiAocGxheWVyLnRlY2ggJiYgcGxheWVyLnRlY2hbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgICB0aGlzLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZiAocGxheWVyLnRlY2hbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLW1lbnUtYnV0dG9uJyk7XG4gIH1cblxuICBjcmVhdGVNZW51KCkge1xuICAgIGxldCBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfLCB7XG4gICAgICBjb250ZW50RWxUeXBlOiAnZGl2J1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHZvbHVtZUJhciBpcyB2ZXJ0aWNhbCBieSBkZWZhdWx0IGluIHRoZSBiYXNlIHRoZW1lIHdoZW4gdXNlZCB3aXRoIGEgVm9sdW1lTWVudUJ1dHRvblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zX1sndm9sdW1lQmFyJ10gfHwge307XG4gICAgb3B0aW9uc1sndmVydGljYWwnXSA9IG9wdGlvbnNbJ3ZlcnRpY2FsJ10gfHwgdHJ1ZTtcblxuICAgIGxldCB2YyA9IG5ldyBWb2x1bWVCYXIodGhpcy5wbGF5ZXJfLCBvcHRpb25zKTtcblxuICAgIHZjLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCkge1xuICAgICAgbWVudS5sb2NrU2hvd2luZygpO1xuICAgIH0pO1xuICAgIHZjLm9uKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICBtZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICB9KTtcbiAgICBtZW51LmFkZENoaWxkKHZjKTtcbiAgICByZXR1cm4gbWVudTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIE11dGVUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gICAgc3VwZXIuaGFuZGxlQ2xpY2soKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1tZW51LWJ1dHRvbiB2anMtbWVudS1idXR0b24gdmpzLWNvbnRyb2wgdmpzLWJ1dHRvbicsXG4gICAgICBpbm5lckhUTUw6IGA8ZGl2PjxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiR7dGhpcy5sb2NhbGl6ZSgnTXV0ZScpfTwvc3Bhbj48L2Rpdj5gXG4gICAgfSk7XG4gIH1cblxufVxuXG5Wb2x1bWVNZW51QnV0dG9uLnByb3RvdHlwZS52b2x1bWVVcGRhdGUgPSBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGU7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lTWVudUJ1dHRvbicsIFZvbHVtZU1lbnVCdXR0b24pO1xuZXhwb3J0IGRlZmF1bHQgVm9sdW1lTWVudUJ1dHRvbjtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgRG9tIGZyb20gJy4vdXRpbHMvZG9tLmpzJztcblxuLyoqXG4gKiBEaXNwbGF5IHRoYXQgYW4gZXJyb3IgaGFzIG9jY3VycmVkIG1ha2luZyB0aGUgdmlkZW8gdW5wbGF5YWJsZVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEVycm9yRGlzcGxheSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdlcnJvcicsIHRoaXMudXBkYXRlKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHZhciBlbCA9IHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtZXJyb3ItZGlzcGxheSdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IERvbS5jcmVhdGVFbCgnZGl2Jyk7XG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIoKS5lcnJvcigpKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8uaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSh0aGlzLnBsYXllcigpLmVycm9yKCkubWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRXJyb3JEaXNwbGF5JywgRXJyb3JEaXNwbGF5KTtcbmV4cG9ydCBkZWZhdWx0IEVycm9yRGlzcGxheTtcbiIsImltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuL3V0aWxzL2V2ZW50cy5qcyc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbigpIHt9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge307XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYXMgYmVmb3JlIGNhbGxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICBsZXQgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIEV2ZW50cy5vbih0aGlzLCB0eXBlLCBmbik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gIEV2ZW50cy5vZmYodGhpcywgdHlwZSwgZm4pO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gIEV2ZW50cy5vbmUodGhpcywgdHlwZSwgZm4pO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgbGV0IHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7XG4gICAgICB0eXBlOiB0eXBlXG4gICAgfTtcbiAgfVxuICBldmVudCA9IEV2ZW50cy5maXhFdmVudChldmVudCk7XG5cbiAgaWYgKHRoaXMuYWxsb3dlZEV2ZW50c19bdHlwZV0gJiYgdGhpc1snb24nICsgdHlwZV0pIHtcbiAgICB0aGlzWydvbicgKyB0eXBlXShldmVudCk7XG4gIH1cblxuICBFdmVudHMudHJpZ2dlcih0aGlzLCBldmVudCk7XG59O1xuLy8gVGhlIHN0YW5kYXJkIERPTSBFdmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KCkgaXMgYWxpYXNlZCB0byB0cmlnZ2VyKClcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUudHJpZ2dlcjtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuIiwiLyoqXG4gKiBBIGNvbWJpbmF0aW9uIG9mIG5vZGUgaW5oZXJpdHMgYW5kIGJhYmVsJ3MgaW5oZXJpdHMgKGFmdGVyIHRyYW5zcGlsZSkuXG4gKiBCb3RoIHdvcmsgdGhlIHNhbWUgYnV0IG5vZGUgYWRkcyBgc3VwZXJfYCB0byB0aGUgc3ViQ2xhc3NcbiAqIGFuZCBCYWJsZSBhZGRzIHRoZSBzdXBlckNsYXNzIGFzIF9fcHJvdG9fXy4gQm90aCBzZWVtIHVzZWZ1bC5cbiAqL1xuY29uc3QgX2luaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChzdXBlckNsYXNzKSB7XG4gICAgLy8gbm9kZVxuICAgIHN1YkNsYXNzLnN1cGVyXyA9IHN1cGVyQ2xhc3M7XG4gIH1cbn07XG5cbi8qKlxuICogRnVuY3Rpb24gZm9yIHN1YmNsYXNzaW5nIHVzaW5nIHRoZSBzYW1lIGluaGVyaXRhbmNlIHRoYXRcbiAqIHZpZGVvanMgdXNlcyBpbnRlcm5hbGx5XG4gKlxuICogYGBgXG4gKiB2YXIgQnV0dG9uID0gdmlkZW9qcy5nZXRDb21wb25lbnQoJ0J1dHRvbicpO1xuICpcbiAqIHZhciBNeUJ1dHRvbiA9IHZpZGVvanMuZXh0ZW5kcyhCdXR0b24sIHtcbiAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHBsYXllciwgb3B0aW9ucykge1xuICogICAgIEJ1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG4gKiAgIH0sXG4gKlxuICogICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAvLyBkb1NvbWV0aGluZ1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICovXG5jb25zdCBleHRlbmRzRm4gPSBmdW5jdGlvbihzdXBlckNsYXNzLCBzdWJDbGFzc01ldGhvZHM9e30pIHtcbiAgbGV0IHN1YkNsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgc3VwZXJDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBsZXQgbWV0aG9kcyA9IHt9O1xuXG4gIGlmIChzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3IgIT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICBzdWJDbGFzcyA9IHN1YkNsYXNzTWV0aG9kcy5jb25zdHJ1Y3RvcjtcbiAgICBtZXRob2RzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJDbGFzc01ldGhvZHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdWJDbGFzcyA9IHN1YkNsYXNzTWV0aG9kcztcbiAgfVxuXG4gIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG5cbiAgLy8gRXh0ZW5kIHN1Yk9iaidzIHByb3RvdHlwZSB3aXRoIGZ1bmN0aW9ucyBhbmQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHByb3BzXG4gIGZvciAodmFyIG5hbWUgaW4gbWV0aG9kcykge1xuICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBzdWJDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJDbGFzcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGV4dGVuZHNGbjtcbiIsImltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuXG4vKipcbiAqIFN0b3JlIHRoZSBicm93c2VyLXNwZWNpZmljIG1ldGhvZHMgZm9yIHRoZSBmdWxsc2NyZWVuIEFQSVxuICogQHR5cGUge09iamVjdHx1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5sZXQgRnVsbHNjcmVlbkFwaSA9IHt9O1xuXG4vLyBicm93c2VyIEFQSSBtZXRob2RzXG4vLyBtYXAgYXBwcm9hY2ggZnJvbSBTY3JlZW5mdWwuanMgLSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3NjcmVlbmZ1bGwuanNcbmNvbnN0IGFwaU1hcCA9IFtcbiAgLy8gU3BlYzogaHR0cHM6Ly9kdmNzLnczLm9yZy9oZy9mdWxsc2NyZWVuL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sXG4gIFtcbiAgICAncmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICdleGl0RnVsbHNjcmVlbicsXG4gICAgJ2Z1bGxzY3JlZW5FbGVtZW50JyxcbiAgICAnZnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICdmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAnZnVsbHNjcmVlbmVycm9yJ1xuICBdLFxuICAvLyBXZWJLaXRcbiAgW1xuICAgICd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsXG4gICAgJ3dlYmtpdEV4aXRGdWxsc2NyZWVuJyxcbiAgICAnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLFxuICAgICd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsXG4gICAgJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXG4gIF0sXG4gIC8vIE9sZCBXZWJLaXQgKFNhZmFyaSA1LjEpXG4gIFtcbiAgICAnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLFxuICAgICd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAnd2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50JyxcbiAgICAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsXG4gICAgJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXG4gIF0sXG4gIC8vIE1vemlsbGFcbiAgW1xuICAgICdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXG4gICAgJ21vekNhbmNlbEZ1bGxTY3JlZW4nLFxuICAgICdtb3pGdWxsU2NyZWVuRWxlbWVudCcsXG4gICAgJ21vekZ1bGxTY3JlZW5FbmFibGVkJyxcbiAgICAnbW96ZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgJ21vemZ1bGxzY3JlZW5lcnJvcidcbiAgXSxcbiAgLy8gTWljcm9zb2Z0XG4gIFtcbiAgICAnbXNSZXF1ZXN0RnVsbHNjcmVlbicsXG4gICAgJ21zRXhpdEZ1bGxzY3JlZW4nLFxuICAgICdtc0Z1bGxzY3JlZW5FbGVtZW50JyxcbiAgICAnbXNGdWxsc2NyZWVuRW5hYmxlZCcsXG4gICAgJ01TRnVsbHNjcmVlbkNoYW5nZScsXG4gICAgJ01TRnVsbHNjcmVlbkVycm9yJ1xuICBdXG5dO1xuXG5sZXQgc3BlY0FwaSA9IGFwaU1hcFswXTtcbmxldCBicm93c2VyQXBpO1xuXG4vLyBkZXRlcm1pbmUgdGhlIHN1cHBvcnRlZCBzZXQgb2YgZnVuY3Rpb25zXG5mb3IgKGxldCBpID0gMDsgaSA8IGFwaU1hcC5sZW5ndGg7IGkrKykge1xuICAvLyBjaGVjayBmb3IgZXhpdEZ1bGxzY3JlZW4gZnVuY3Rpb25cbiAgaWYgKGFwaU1hcFtpXVsxXSBpbiBkb2N1bWVudCkge1xuICAgIGJyb3dzZXJBcGkgPSBhcGlNYXBbaV07XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gbWFwIHRoZSBicm93c2VyIEFQSSBuYW1lcyB0byB0aGUgc3BlYyBBUEkgbmFtZXNcbmlmIChicm93c2VyQXBpKSB7XG4gIGZvciAobGV0IGk9MDsgaTxicm93c2VyQXBpLmxlbmd0aDsgaSsrKSB7XG4gICAgRnVsbHNjcmVlbkFwaVtzcGVjQXBpW2ldXSA9IGJyb3dzZXJBcGlbaV07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRnVsbHNjcmVlbkFwaTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG4vKiBMb2FkaW5nIFNwaW5uZXJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIExvYWRpbmcgc3Bpbm5lciBmb3Igd2FpdGluZyBldmVudHNcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIExvYWRpbmdTcGlubmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZGluZy1zcGlubmVyJ1xuICAgIH0pO1xuICB9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTG9hZGluZ1NwaW5uZXInLCBMb2FkaW5nU3Bpbm5lcik7XG5leHBvcnQgZGVmYXVsdCBMb2FkaW5nU3Bpbm5lcjtcbiIsImltcG9ydCBhc3NpZ24gZnJvbSAnb2JqZWN0LmFzc2lnbic7XG5cbi8qKlxuICogQ3VzdG9tIE1lZGlhRXJyb3IgdG8gbWltaWMgdGhlIEhUTUw1IE1lZGlhRXJyb3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBtZWRpYSBlcnJvciBjb2RlXG4gKi9cbmxldCBNZWRpYUVycm9yID0gZnVuY3Rpb24oY29kZSl7XG4gIGlmICh0eXBlb2YgY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xuICAgIC8vIGRlZmF1bHQgY29kZSBpcyB6ZXJvLCBzbyB0aGlzIGlzIGEgY3VzdG9tIGVycm9yXG4gICAgdGhpcy5tZXNzYWdlID0gY29kZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcpIHsgLy8gb2JqZWN0XG4gICAgYXNzaWduKHRoaXMsIGNvZGUpO1xuICB9XG5cbiAgaWYgKCF0aGlzLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBNZWRpYUVycm9yLmRlZmF1bHRNZXNzYWdlc1t0aGlzLmNvZGVdIHx8ICcnO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBlcnJvciBjb2RlIHRoYXQgcmVmZXJzIHR3byBvbmUgb2YgdGhlIGRlZmluZWRcbiAqIE1lZGlhRXJyb3IgdHlwZXNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLmNvZGUgPSAwO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gYmUgc2hvd24gd2l0aCB0aGUgZXJyb3IuXG4gKiBNZXNzYWdlIGlzIG5vdCBwYXJ0IG9mIHRoZSBIVE1MNSB2aWRlbyBzcGVjXG4gKiBidXQgYWxsb3dzIGZvciBtb3JlIGluZm9ybWF0aXZlIGN1c3RvbSBlcnJvcnMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgdGhhdCBjYW4gYmUgc2V0IGJ5IHBsdWdpbnNcbiAqIHRvIGFsbG93IGV2ZW4gbW9yZSBkZXRhaWwgYWJvdXQgdGhlIGVycm9yLlxuICogRm9yIGV4YW1wbGUgdGhlIEhMUyBwbHVnaW4gbWlnaHQgcHJvdmlkZSB0aGUgc3BlY2lmaWNcbiAqIEhUVFAgc3RhdHVzIGNvZGUgdGhhdCB3YXMgcmV0dXJuZWQgd2hlbiB0aGUgZXJyb3JcbiAqIG9jY3VycmVkLCB0aGVuIGFsbG93aW5nIGEgY3VzdG9tIGVycm9yIG92ZXJsYXlcbiAqIHRvIGRpc3BsYXkgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEB0eXBlIHtbdHlwZV19XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLnN0YXR1cyA9IG51bGw7XG5cbk1lZGlhRXJyb3IuZXJyb3JUeXBlcyA9IFtcbiAgJ01FRElBX0VSUl9DVVNUT00nLCAgICAgICAgICAgIC8vID0gMFxuICAnTUVESUFfRVJSX0FCT1JURUQnLCAgICAgICAgICAgLy8gPSAxXG4gICdNRURJQV9FUlJfTkVUV09SSycsICAgICAgICAgICAvLyA9IDJcbiAgJ01FRElBX0VSUl9ERUNPREUnLCAgICAgICAgICAgIC8vID0gM1xuICAnTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEJywgLy8gPSA0XG4gICdNRURJQV9FUlJfRU5DUllQVEVEJyAgICAgICAgICAvLyA9IDVcbl07XG5cbk1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzID0ge1xuICAxOiAnWW91IGFib3J0ZWQgdGhlIHZpZGVvIHBsYXliYWNrJyxcbiAgMjogJ0EgbmV0d29yayBlcnJvciBjYXVzZWQgdGhlIHZpZGVvIGRvd25sb2FkIHRvIGZhaWwgcGFydC13YXkuJyxcbiAgMzogJ1RoZSB2aWRlbyBwbGF5YmFjayB3YXMgYWJvcnRlZCBkdWUgdG8gYSBjb3JydXB0aW9uIHByb2JsZW0gb3IgYmVjYXVzZSB0aGUgdmlkZW8gdXNlZCBmZWF0dXJlcyB5b3VyIGJyb3dzZXIgZGlkIG5vdCBzdXBwb3J0LicsXG4gIDQ6ICdUaGUgdmlkZW8gY291bGQgbm90IGJlIGxvYWRlZCwgZWl0aGVyIGJlY2F1c2UgdGhlIHNlcnZlciBvciBuZXR3b3JrIGZhaWxlZCBvciBiZWNhdXNlIHRoZSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4nLFxuICA1OiAnVGhlIHZpZGVvIGlzIGVuY3J5cHRlZCBhbmQgd2UgZG8gbm90IGhhdmUgdGhlIGtleXMgdG8gZGVjcnlwdCBpdC4nXG59O1xuXG4vLyBBZGQgdHlwZXMgYXMgcHJvcGVydGllcyBvbiBNZWRpYUVycm9yXG4vLyBlLmcuIE1lZGlhRXJyb3IuTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEID0gNDtcbmZvciAodmFyIGVyck51bSA9IDA7IGVyck51bSA8IE1lZGlhRXJyb3IuZXJyb3JUeXBlcy5sZW5ndGg7IGVyck51bSsrKSB7XG4gIE1lZGlhRXJyb3JbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xuICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb24gYm90aCB0aGUgY2xhc3MgYW5kIGluc3RhbmNlXG4gIE1lZGlhRXJyb3IucHJvdG90eXBlW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVkaWFFcnJvcjtcbiIsImltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCBNZW51IGZyb20gJy4vbWVudS5qcyc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi4vdXRpbHMvZG9tLmpzJztcbmltcG9ydCAqIGFzIEZuIGZyb20gJy4uL3V0aWxzL2ZuLmpzJztcbmltcG9ydCB0b1RpdGxlQ2FzZSBmcm9tICcuLi91dGlscy90by10aXRsZS1jYXNlLmpzJztcblxuLyoqXG4gKiBBIGJ1dHRvbiBjbGFzcyB3aXRoIGEgcG9wdXAgbWVudVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE1lbnVCdXR0b24gZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB0aGlzLm9uKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGxldCBtZW51ID0gdGhpcy5jcmVhdGVNZW51KCk7XG5cbiAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMubWVudSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZW51ID0gbWVudTtcbiAgICB0aGlzLmFkZENoaWxkKG1lbnUpO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBtZW51IGJ1dHRvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZU1lbnUoKSB7XG4gICAgdmFyIG1lbnUgPSBuZXcgTWVudSh0aGlzLnBsYXllcl8pO1xuXG4gICAgLy8gQWRkIGEgdGl0bGUgbGlzdCBpdGVtIHRvIHRoZSB0b3BcbiAgICBpZiAodGhpcy5vcHRpb25zKCkudGl0bGUpIHtcbiAgICAgIG1lbnUuY29udGVudEVsKCkuYXBwZW5kQ2hpbGQoRG9tLmNyZWF0ZUVsKCdsaScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtdGl0bGUnLFxuICAgICAgICBpbm5lckhUTUw6IHRvVGl0bGVDYXNlKHRoaXMub3B0aW9ucygpLnRpdGxlKSxcbiAgICAgICAgdGFiaW5kZXg6IC0xXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVtcyA9IHRoaXNbJ2NyZWF0ZUl0ZW1zJ10oKTtcblxuICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICAvLyBBZGQgbWVudSBpdGVtcyB0byB0aGUgbWVudVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1lbnUuYWRkSXRlbSh0aGlzLml0ZW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVudTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGxpc3Qgb2YgbWVudSBpdGVtcy4gU3BlY2lmaWMgdG8gZWFjaCBzdWJjbGFzcy5cbiAgICovXG4gIGNyZWF0ZUl0ZW1zKCl7fVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNsYXNzTmFtZX0gdmpzLW1lbnUtYnV0dG9uICR7c3VwZXIuYnVpbGRDU1NDbGFzcygpfWA7XG4gIH1cblxuICAvLyBGb2N1cyAtIEFkZCBrZXlib2FyZCBmdW5jdGlvbmFsaXR5IHRvIGVsZW1lbnRcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgbmVlZGVkIGFueW1vcmUuIEluc3RlYWQsIHRoZSBrZXlib2FyZCBmdW5jdGlvbmFsaXR5IGlzIGhhbmRsZWQgYnlcbiAgLy8gdHJlYXRpbmcgdGhlIGJ1dHRvbiBhcyB0cmlnZ2VyaW5nIGEgc3VibWVudS4gV2hlbiB0aGUgYnV0dG9uIGlzIHByZXNzZWQsIHRoZSBzdWJtZW51XG4gIC8vIGFwcGVhcnMuIFByZXNzaW5nIHRoZSBidXR0b24gYWdhaW4gbWFrZXMgdGhlIHN1Ym1lbnUgZGlzYXBwZWFyLlxuICBoYW5kbGVGb2N1cygpIHt9XG5cbiAgLy8gQ2FuJ3QgdHVybiBvZmYgbGlzdCBkaXNwbGF5IHRoYXQgd2UgdHVybmVkIG9uIHdpdGggZm9jdXMsIGJlY2F1c2UgbGlzdCB3b3VsZCBnbyBhd2F5LlxuICBoYW5kbGVCbHVyKCkge31cblxuICBoYW5kbGVDbGljaygpIHtcbiAgICAvLyBXaGVuIHlvdSBjbGljayB0aGUgYnV0dG9uIGl0IGFkZHMgZm9jdXMsIHdoaWNoIHdpbGwgc2hvdyB0aGUgbWVudSBpbmRlZmluaXRlbHkuXG4gICAgLy8gU28gd2UnbGwgcmVtb3ZlIGZvY3VzIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgYnV0dG9uLlxuICAgIC8vIEZvY3VzIGlzIG5lZWRlZCBmb3IgdGFiIG5hdmlnYXRpb24uXG4gICAgdGhpcy5vbmUoJ21vdXNlb3V0JywgRm4uYmluZCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5tZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMuZWxfLmJsdXIoKTtcbiAgICB9KSk7XG4gICAgaWYgKHRoaXMuYnV0dG9uUHJlc3NlZF8pe1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gQ2hlY2sgZm9yIHNwYWNlIGJhciAoMzIpIG9yIGVudGVyICgxMykga2V5c1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXyl7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyBDaGVjayBmb3IgZXNjYXBlICgyNykga2V5XG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMjcpe1xuICAgICAgaWYgKHRoaXMuYnV0dG9uUHJlc3NlZF8pe1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgcHJlc3NCdXR0b24oKSB7XG4gICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IHRydWU7XG4gICAgdGhpcy5tZW51LmxvY2tTaG93aW5nKCk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCB0cnVlKTtcbiAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuaXRlbXNbMF0uZWwoKS5mb2N1cygpOyAvLyBzZXQgdGhlIGZvY3VzIHRvIHRoZSB0aXRsZSBvZiB0aGUgc3VibWVudVxuICAgIH1cbiAgfVxuXG4gIHVucHJlc3NCdXR0b24oKSB7XG4gICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IGZhbHNlO1xuICAgIHRoaXMubWVudS51bmxvY2tTaG93aW5nKCk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCBmYWxzZSk7XG4gIH1cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51QnV0dG9uJywgTWVudUJ1dHRvbik7XG5leHBvcnQgZGVmYXVsdCBNZW51QnV0dG9uO1xuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24uanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQuanMnO1xuaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QuYXNzaWduJztcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBhIG1lbnUgaXRlbS4gYDxsaT5gXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTWVudUl0ZW0gZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucykge1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5zZWxlY3RlZChvcHRpb25zWydzZWxlY3RlZCddKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBjcmVhdGVFbCh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnbGknLCBhc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtaXRlbScsXG4gICAgICBpbm5lckhUTUw6IHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zX1snbGFiZWwnXSlcbiAgICB9LCBwcm9wcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIHRoZSBtZW51IGl0ZW0sIGFuZCBzZXQgaXQgdG8gc2VsZWN0ZWRcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoaXMgbWVudSBpdGVtIGFzIHNlbGVjdGVkIG9yIG5vdFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBzZWxlY3RlZFxuICAgKi9cbiAgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zZWxlY3RlZCcpO1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyx0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLGZhbHNlKTtcbiAgICB9XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVJdGVtJywgTWVudUl0ZW0pO1xuZXhwb3J0IGRlZmF1bHQgTWVudUl0ZW07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi4vdXRpbHMvZG9tLmpzJztcbmltcG9ydCAqIGFzIEZuIGZyb20gJy4uL3V0aWxzL2ZuLmpzJztcbmltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuLi91dGlscy9ldmVudHMuanMnO1xuXG4vKiBNZW51XG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiBUaGUgTWVudSBjb21wb25lbnQgaXMgdXNlZCB0byBidWlsZCBwb3AgdXAgbWVudXMsIGluY2x1ZGluZyBzdWJ0aXRsZSBhbmRcbiAqIGNhcHRpb25zIHNlbGVjdGlvbiBtZW51cy5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBNZW51IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogQWRkIGEgbWVudSBpdGVtIHRvIHRoZSBtZW51XG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29tcG9uZW50IENvbXBvbmVudCBvciBjb21wb25lbnQgdHlwZSB0byBhZGRcbiAgICovXG4gIGFkZEl0ZW0oY29tcG9uZW50KSB7XG4gICAgdGhpcy5hZGRDaGlsZChjb21wb25lbnQpO1xuICAgIGNvbXBvbmVudC5vbignY2xpY2snLCBGbi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLnVubG9ja1Nob3dpbmcoKTtcbiAgICB9KSk7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICBsZXQgY29udGVudEVsVHlwZSA9IHRoaXMub3B0aW9ucygpLmNvbnRlbnRFbFR5cGUgfHwgJ3VsJztcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBEb20uY3JlYXRlRWwoY29udGVudEVsVHlwZSwge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtY29udGVudCdcbiAgICB9KTtcbiAgICB2YXIgZWwgPSBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgYXBwZW5kOiB0aGlzLmNvbnRlbnRFbF8sXG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudSdcbiAgICB9KTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuXG4gICAgLy8gUHJldmVudCBjbGlja3MgZnJvbSBidWJibGluZyB1cC4gTmVlZGVkIGZvciBNZW51IEJ1dHRvbnMsXG4gICAgLy8gd2hlcmUgYSBjbGljayBvbiB0aGUgcGFyZW50IGlzIHNpZ25pZmljYW50XG4gICAgRXZlbnRzLm9uKGVsLCAnY2xpY2snLCBmdW5jdGlvbihldmVudCl7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH1cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51JywgTWVudSk7XG5leHBvcnQgZGVmYXVsdCBNZW51O1xuIiwiaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xubGV0IG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cbi8qKlxuICogR2xvYmFsIFBsYXllciBpbnN0YW5jZSBvcHRpb25zLCBzdXJmYWNlZCBmcm9tIFBsYXllci5wcm90b3R5cGUub3B0aW9uc19cbiAqIG9wdGlvbnMgPSBQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfXG4gKiBBbGwgb3B0aW9ucyBzaG91bGQgdXNlIHN0cmluZyBrZXlzIHNvIHRoZXkgYXZvaWRcbiAqIHJlbmFtaW5nIGJ5IGNsb3N1cmUgY29tcGlsZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gRGVmYXVsdCBvcmRlciBvZiBmYWxsYmFjayB0ZWNobm9sb2d5XG4gICd0ZWNoT3JkZXInOiBbJ2h0bWw1JywnZmxhc2gnXSxcbiAgLy8gdGVjaE9yZGVyOiBbJ2ZsYXNoJywnaHRtbDUnXSxcblxuICAnaHRtbDUnOiB7fSxcbiAgJ2ZsYXNoJzoge30sXG5cbiAgLy8gZGVmYXVsdFZvbHVtZTogMC44NSxcbiAgJ2RlZmF1bHRWb2x1bWUnOiAwLjAwLCAvLyBUaGUgZnJlYWtpbiBzZWFndWxzIGFyZSBkcml2aW5nIG1lIGNyYXp5IVxuXG4gIC8vIGRlZmF1bHQgaW5hY3Rpdml0eSB0aW1lb3V0XG4gICdpbmFjdGl2aXR5VGltZW91dCc6IDIwMDAsXG5cbiAgLy8gZGVmYXVsdCBwbGF5YmFjayByYXRlc1xuICAncGxheWJhY2tSYXRlcyc6IFtdLFxuICAvLyBBZGQgcGxheWJhY2sgcmF0ZSBzZWxlY3Rpb24gYnkgYWRkaW5nIHJhdGVzXG4gIC8vICdwbGF5YmFja1JhdGVzJzogWzAuNSwgMSwgMS41LCAyXSxcblxuICAvLyBJbmNsdWRlZCBjb250cm9sIHNldHNcbiAgJ2NoaWxkcmVuJzoge1xuICAgICdtZWRpYUxvYWRlcic6IHt9LFxuICAgICdwb3N0ZXJJbWFnZSc6IHt9LFxuICAgICd0ZXh0VHJhY2tEaXNwbGF5Jzoge30sXG4gICAgJ2xvYWRpbmdTcGlubmVyJzoge30sXG4gICAgJ2JpZ1BsYXlCdXR0b24nOiB7fSxcbiAgICAnY29udHJvbEJhcic6IHt9LFxuICAgICdlcnJvckRpc3BsYXknOiB7fSxcbiAgICAndGV4dFRyYWNrU2V0dGluZ3MnOiB7fVxuICB9LFxuXG4gICdsYW5ndWFnZSc6IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0uZ2V0QXR0cmlidXRlKCdsYW5nJykgfHwgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLmxhbmd1YWdlIHx8ICdlbicsXG5cbiAgLy8gbG9jYWxlcyBhbmQgdGhlaXIgbGFuZ3VhZ2UgdHJhbnNsYXRpb25zXG4gICdsYW5ndWFnZXMnOiB7fSxcblxuICAvLyBEZWZhdWx0IG1lc3NhZ2UgdG8gc2hvdyB3aGVuIGEgdmlkZW8gY2Fubm90IGJlIHBsYXllZC5cbiAgJ25vdFN1cHBvcnRlZE1lc3NhZ2UnOiAnTm8gY29tcGF0aWJsZSBzb3VyY2Ugd2FzIGZvdW5kIGZvciB0aGlzIHZpZGVvLidcbn07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuL3V0aWxzL2V2ZW50cy5qcyc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi91dGlscy9kb20uanMnO1xuaW1wb3J0ICogYXMgRm4gZnJvbSAnLi91dGlscy9mbi5qcyc7XG5pbXBvcnQgKiBhcyBHdWlkIGZyb20gJy4vdXRpbHMvZ3VpZC5qcyc7XG5pbXBvcnQgKiBhcyBicm93c2VyIGZyb20gJy4vdXRpbHMvYnJvd3Nlci5qcyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vdXRpbHMvbG9nLmpzJztcbmltcG9ydCB0b1RpdGxlQ2FzZSBmcm9tICcuL3V0aWxzL3RvLXRpdGxlLWNhc2UuanMnO1xuaW1wb3J0IHsgY3JlYXRlVGltZVJhbmdlIH0gZnJvbSAnLi91dGlscy90aW1lLXJhbmdlcy5qcyc7XG5pbXBvcnQgRnVsbHNjcmVlbkFwaSBmcm9tICcuL2Z1bGxzY3JlZW4tYXBpLmpzJztcbmltcG9ydCBNZWRpYUVycm9yIGZyb20gJy4vbWVkaWEtZXJyb3IuanMnO1xuaW1wb3J0IE9wdGlvbnMgZnJvbSAnLi9vcHRpb25zLmpzJztcbmltcG9ydCBzYWZlUGFyc2VUdXBsZSBmcm9tICdzYWZlLWpzb24tcGFyc2UvdHVwbGUnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QuYXNzaWduJztcbmltcG9ydCBtZXJnZU9wdGlvbnMgZnJvbSAnLi91dGlscy9tZXJnZS1vcHRpb25zLmpzJztcblxuLy8gSW5jbHVkZSByZXF1aXJlZCBjaGlsZCBjb21wb25lbnRzXG5pbXBvcnQgTWVkaWFMb2FkZXIgZnJvbSAnLi90ZWNoL2xvYWRlci5qcyc7XG5pbXBvcnQgUG9zdGVyIGZyb20gJy4vcG9zdGVyLWltYWdlLmpzJztcbmltcG9ydCBUZXh0VHJhY2tEaXNwbGF5IGZyb20gJy4vdHJhY2tzL3RleHQtdHJhY2stZGlzcGxheS5qcyc7XG5pbXBvcnQgTG9hZGluZ1NwaW5uZXIgZnJvbSAnLi9sb2FkaW5nLXNwaW5uZXIuanMnO1xuaW1wb3J0IEJpZ1BsYXlCdXR0b24gZnJvbSAnLi9iaWctcGxheS1idXR0b24uanMnO1xuaW1wb3J0IGNvbnRyb2xCYXIgZnJvbSAnLi9jb250cm9sLWJhci9jb250cm9sLWJhci5qcyc7XG5pbXBvcnQgRXJyb3JEaXNwbGF5IGZyb20gJy4vZXJyb3ItZGlzcGxheS5qcyc7XG5pbXBvcnQgVGV4dFRyYWNrU2V0dGluZ3MgZnJvbSAnLi90cmFja3MvdGV4dC10cmFjay1zZXR0aW5ncy5qcyc7XG4vLyBSZXF1aXJlIGh0bWw1IGZvciBkaXNwb3NpbmcgdGhlIG9yaWdpbmFsIHZpZGVvIHRhZ1xuaW1wb3J0IEh0bWw1IGZyb20gJy4vdGVjaC9odG1sNS5qcyc7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIGBQbGF5ZXJgIGNsYXNzIGlzIGNyZWF0ZWQgd2hlbiBhbnkgb2YgdGhlIFZpZGVvLmpzIHNldHVwIG1ldGhvZHMgYXJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBhIHZpZGVvLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbXlQbGF5ZXIgPSB2aWRlb2pzKCdleGFtcGxlX3ZpZGVvXzEnKTtcbiAqIGBgYFxuICpcbiAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgdGhlIGBkYXRhLXNldHVwYCBhdHRyaWJ1dGUgdGVsbHMgdGhlIFZpZGVvLmpzIGxpYnJhcnkgdG8gY3JlYXRlIGEgcGxheWVyIGluc3RhbmNlIHdoZW4gdGhlIGxpYnJhcnkgaXMgcmVhZHkuXG4gKlxuICogYGBgaHRtbFxuICogPHZpZGVvIGlkPVwiZXhhbXBsZV92aWRlb18xXCIgZGF0YS1zZXR1cD0ne30nIGNvbnRyb2xzPlxuICogICA8c291cmNlIHNyYz1cIm15LXNvdXJjZS5tcDRcIiB0eXBlPVwidmlkZW8vbXA0XCI+XG4gKiA8L3ZpZGVvPlxuICogYGBgXG4gKlxuICogQWZ0ZXIgYW4gaW5zdGFuY2UgaGFzIGJlZW4gY3JlYXRlZCBpdCBjYW4gYmUgYWNjZXNzZWQgZ2xvYmFsbHkgdXNpbmcgYFZpZGVvKCdleGFtcGxlX3ZpZGVvXzEnKWAuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuY2xhc3MgUGxheWVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogcGxheWVyJ3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICpcbiAgICogQGNvbnN0cnVjdHNcbiAgICogQG1ldGhvZCBpbml0XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnICAgICAgICBUaGUgb3JpZ2luYWwgdmlkZW8gdGFnIHVzZWQgZm9yIGNvbmZpZ3VyaW5nIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zICAgIFBsYXllciBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeSAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IodGFnLCBvcHRpb25zLCByZWFkeSl7XG4gICAgLy8gTWFrZSBzdXJlIHRhZyBJRCBleGlzdHNcbiAgICB0YWcuaWQgPSB0YWcuaWQgfHwgYHZqc192aWRlb18ke0d1aWQubmV3R1VJRCgpfWA7XG5cbiAgICAvLyBTZXQgT3B0aW9uc1xuICAgIC8vIFRoZSBvcHRpb25zIGFyZ3VtZW50IG92ZXJyaWRlcyBvcHRpb25zIHNldCBpbiB0aGUgdmlkZW8gdGFnXG4gICAgLy8gd2hpY2ggb3ZlcnJpZGVzIGdsb2JhbGx5IHNldCBvcHRpb25zLlxuICAgIC8vIFRoaXMgbGF0dGVyIHBhcnQgY29pbmNpZGVzIHdpdGggdGhlIGxvYWQgb3JkZXJcbiAgICAvLyAodGFnIG11c3QgZXhpc3QgYmVmb3JlIFBsYXllcilcbiAgICBvcHRpb25zID0gYXNzaWduKFBsYXllci5nZXRUYWdTZXR0aW5ncyh0YWcpLCBvcHRpb25zKTtcblxuICAgIC8vIERlbGF5IHRoZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZHJlbiBiZWNhdXNlIHdlIG5lZWQgdG8gc2V0IHVwXG4gICAgLy8gcGxheWVyIHByb3BlcnRpZXMgZmlyc3QsIGFuZCBjYW4ndCB1c2UgYHRoaXNgIGJlZm9yZSBgc3VwZXIoKWBcbiAgICBvcHRpb25zLmluaXRDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgLy8gU2FtZSB3aXRoIGNyZWF0aW5nIHRoZSBlbGVtZW50XG4gICAgb3B0aW9ucy5jcmVhdGVFbCA9IGZhbHNlO1xuXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgcGxheWVyIHRvIHJlcG9ydCB0b3VjaCBhY3Rpdml0eSBvbiBpdHNlbGZcbiAgICAvLyBzZWUgZW5hYmxlVG91Y2hBY3Rpdml0eSBpbiBDb21wb25lbnRcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcblxuICAgIC8vIFJ1biBiYXNlIGNvbXBvbmVudCBpbml0aWFsaXppbmcgd2l0aCBuZXcgb3B0aW9uc1xuICAgIHN1cGVyKG51bGwsIG9wdGlvbnMsIHJlYWR5KTtcblxuXG4gICAgLy8gaWYgdGhlIGdsb2JhbCBvcHRpb24gb2JqZWN0IHdhcyBhY2NpZGVudGFsbHkgYmxvd24gYXdheSBieVxuICAgIC8vIHNvbWVvbmUsIGJhaWwgZWFybHkgd2l0aCBhbiBpbmZvcm1hdGl2ZSBlcnJvclxuICAgIGlmICghdGhpcy5vcHRpb25zXyB8fFxuICAgICAgICAhdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIgfHxcbiAgICAgICAgIXRoaXMub3B0aW9uc18udGVjaE9yZGVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0ZWNoT3JkZXIgc3BlY2lmaWVkLiBEaWQgeW91IG92ZXJ3cml0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAndmlkZW9qcy5vcHRpb25zIGluc3RlYWQgb2YganVzdCBjaGFuZ2luZyB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnRpZXMgeW91IHdhbnQgdG8gb3ZlcnJpZGU/Jyk7XG4gICAgfVxuXG4gICAgdGhpcy50YWcgPSB0YWc7IC8vIFN0b3JlIHRoZSBvcmlnaW5hbCB0YWcgdXNlZCB0byBzZXQgb3B0aW9uc1xuXG4gICAgLy8gU3RvcmUgdGhlIHRhZyBhdHRyaWJ1dGVzIHVzZWQgdG8gcmVzdG9yZSBodG1sNSBlbGVtZW50XG4gICAgdGhpcy50YWdBdHRyaWJ1dGVzID0gdGFnICYmIERvbS5nZXRFbGVtZW50QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgLy8gVXBkYXRlIEN1cnJlbnQgTGFuZ3VhZ2VcbiAgICB0aGlzLmxhbmd1YWdlXyA9IG9wdGlvbnNbJ2xhbmd1YWdlJ10gfHwgT3B0aW9uc1snbGFuZ3VhZ2UnXTtcblxuICAgIC8vIFVwZGF0ZSBTdXBwb3J0ZWQgTGFuZ3VhZ2VzXG4gICAgdGhpcy5sYW5ndWFnZXNfID0gb3B0aW9uc1snbGFuZ3VhZ2VzJ10gfHwgT3B0aW9uc1snbGFuZ3VhZ2VzJ107XG5cbiAgICAvLyBDYWNoZSBmb3IgdmlkZW8gcHJvcGVydHkgdmFsdWVzLlxuICAgIHRoaXMuY2FjaGVfID0ge307XG5cbiAgICAvLyBTZXQgcG9zdGVyXG4gICAgdGhpcy5wb3N0ZXJfID0gb3B0aW9uc1sncG9zdGVyJ10gfHwgJyc7XG5cbiAgICAvLyBTZXQgY29udHJvbHNcbiAgICB0aGlzLmNvbnRyb2xzXyA9ICEhb3B0aW9uc1snY29udHJvbHMnXTtcbiAgICAvLyBPcmlnaW5hbCB0YWcgc2V0dGluZ3Mgc3RvcmVkIGluIG9wdGlvbnNcbiAgICAvLyBub3cgcmVtb3ZlIGltbWVkaWF0ZWx5IHNvIG5hdGl2ZSBjb250cm9scyBkb24ndCBmbGFzaC5cbiAgICAvLyBNYXkgYmUgdHVybmVkIGJhY2sgb24gYnkgSFRNTDUgdGVjaCBpZiBuYXRpdmVDb250cm9sc0ZvclRvdWNoIGlzIHRydWVcbiAgICB0YWcuY29udHJvbHMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICogU3RvcmUgdGhlIGludGVybmFsIHN0YXRlIG9mIHNjcnViYmluZ1xuICAgICogQHByaXZhdGVcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHVzZXIgaXMgc2NydWJiaW5nXG4gICAgKi9cbiAgICB0aGlzLnNjcnViYmluZ18gPSBmYWxzZTtcblxuICAgIHRoaXMuZWxfID0gdGhpcy5jcmVhdGVFbCgpO1xuXG4gICAgLy8gTG9hZCBwbHVnaW5zXG4gICAgaWYgKG9wdGlvbnNbJ3BsdWdpbnMnXSkge1xuICAgICAgbGV0IHBsdWdpbnMgPSBvcHRpb25zWydwbHVnaW5zJ107XG5cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG4gICAgICAgIHRoaXNbbmFtZV0ocGx1Z2luc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRDaGlsZHJlbigpO1xuXG4gICAgLy8gU2V0IGlzQXVkaW8gYmFzZWQgb24gd2hldGhlciBvciBub3QgYW4gYXVkaW8gdGFnIHdhcyB1c2VkXG4gICAgdGhpcy5pc0F1ZGlvKHRhZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYXVkaW8nKTtcblxuICAgIC8vIFVwZGF0ZSBjb250cm9scyBjbGFzc05hbWUuIENhbid0IGRvIHRoaXMgd2hlbiB0aGUgY29udHJvbHMgYXJlIGluaXRpYWxseVxuICAgIC8vIHNldCBiZWNhdXNlIHRoZSBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgeWV0LlxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQXVkaW8oKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWF1ZGlvJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmxleE5vdFN1cHBvcnRlZF8oKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLW5vLWZsZXgnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgc21hcnRlci4gVG9nZ2xlIHVzZXIgc3RhdGUgYmV0d2VlbiB0b3VjaGluZy9tb3VzaW5nXG4gICAgLy8gdXNpbmcgZXZlbnRzLCBzaW5jZSBkZXZpY2VzIGNhbiBoYXZlIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50cy5cbiAgICAvLyBpZiAoYnJvd3Nlci5UT1VDSF9FTkFCTEVEKSB7XG4gICAgLy8gICB0aGlzLmFkZENsYXNzKCd2anMtdG91Y2gtZW5hYmxlZCcpO1xuICAgIC8vIH1cblxuICAgIC8vIE1ha2UgcGxheWVyIGVhc2lseSBmaW5kYWJsZSBieSBJRFxuICAgIFBsYXllci5wbGF5ZXJzW3RoaXMuaWRfXSA9IHRoaXM7XG5cbiAgICAvLyBXaGVuIHRoZSBwbGF5ZXIgaXMgZmlyc3QgaW5pdGlhbGl6ZWQsIHRyaWdnZXIgYWN0aXZpdHkgc28gY29tcG9uZW50c1xuICAgIC8vIGxpa2UgdGhlIGNvbnRyb2wgYmFyIHNob3cgdGhlbXNlbHZlcyBpZiBuZWVkZWRcbiAgICB0aGlzLnVzZXJBY3RpdmVfID0gdHJ1ZTtcbiAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICAgIHRoaXMubGlzdGVuRm9yVXNlckFjdGl2aXR5KCk7XG5cbiAgICB0aGlzLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICB0aGlzLm9uKCdzdGFnZWNsaWNrJywgdGhpcy5oYW5kbGVTdGFnZUNsaWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdmlkZW8gcGxheWVyIGFuZCBkb2VzIGFueSBuZWNlc3NhcnkgY2xlYW51cFxuICAgKlxuICAgKiAgICAgbXlQbGF5ZXIuZGlzcG9zZSgpO1xuICAgKlxuICAgKiBUaGlzIGlzIGVzcGVjaWFsbHkgaGVscGZ1bCBpZiB5b3UgYXJlIGR5bmFtaWNhbGx5IGFkZGluZyBhbmQgcmVtb3ZpbmcgdmlkZW9zXG4gICAqIHRvL2Zyb20gdGhlIERPTS5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkaXNwb3NlJyk7XG4gICAgLy8gcHJldmVudCBkaXNwb3NlIGZyb20gYmVpbmcgY2FsbGVkIHR3aWNlXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnKTtcblxuICAgIC8vIEtpbGwgcmVmZXJlbmNlIHRvIHRoaXMgcGxheWVyXG4gICAgUGxheWVyLnBsYXllcnNbdGhpcy5pZF9dID0gbnVsbDtcbiAgICBpZiAodGhpcy50YWcgJiYgdGhpcy50YWdbJ3BsYXllciddKSB7IHRoaXMudGFnWydwbGF5ZXInXSA9IG51bGw7IH1cbiAgICBpZiAodGhpcy5lbF8gJiYgdGhpcy5lbF9bJ3BsYXllciddKSB7IHRoaXMuZWxfWydwbGF5ZXInXSA9IG51bGw7IH1cblxuICAgIGlmICh0aGlzLnRlY2gpIHsgdGhpcy50ZWNoLmRpc3Bvc2UoKTsgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gdGhpcy5lbF8gPSBzdXBlci5jcmVhdGVFbCgnZGl2Jyk7XG4gICAgbGV0IHRhZyA9IHRoaXMudGFnO1xuXG4gICAgLy8gUmVtb3ZlIHdpZHRoL2hlaWdodCBhdHRycyBmcm9tIHRhZyBzbyBDU1MgY2FuIG1ha2UgaXQgMTAwJSB3aWR0aC9oZWlnaHRcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIHRhZy5yZW1vdmVBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXG4gICAgLy8gQ29weSBvdmVyIGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZSB0YWcsIGluY2x1ZGluZyBJRCBhbmQgY2xhc3NcbiAgICAvLyBJRCB3aWxsIG5vdyByZWZlcmVuY2UgcGxheWVyIGJveCwgbm90IHRoZSB2aWRlbyB0YWdcbiAgICBjb25zdCBhdHRycyA9IERvbS5nZXRFbGVtZW50QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24oYXR0cil7XG4gICAgICAvLyB3b3JrYXJvdW5kIHNvIHdlIGRvbid0IHRvdGFsbHkgYnJlYWsgSUU3XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM2NTM0NDQvY3NzLXN0eWxlcy1ub3QtYXBwbGllZC1vbi1keW5hbWljLWVsZW1lbnRzLWluLWludGVybmV0LWV4cGxvcmVyLTdcbiAgICAgIGlmIChhdHRyID09PSAnY2xhc3MnKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJzW2F0dHJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0YWcgaWQvY2xhc3MgZm9yIHVzZSBhcyBIVE1MNSBwbGF5YmFjayB0ZWNoXG4gICAgLy8gTWlnaHQgdGhpbmsgd2Ugc2hvdWxkIGRvIHRoaXMgYWZ0ZXIgZW1iZWRkaW5nIGluIGNvbnRhaW5lciBzbyAudmpzLXRlY2ggY2xhc3NcbiAgICAvLyBkb2Vzbid0IGZsYXNoIDEwMCUgd2lkdGgvaGVpZ2h0LCBidXQgY2xhc3Mgb25seSBhcHBsaWVzIHdpdGggLnZpZGVvLWpzIHBhcmVudFxuICAgIHRhZy5pZCArPSAnX2h0bWw1X2FwaSc7XG4gICAgdGFnLmNsYXNzTmFtZSA9ICd2anMtdGVjaCc7XG5cbiAgICAvLyBNYWtlIHBsYXllciBmaW5kYWJsZSBvbiBlbGVtZW50c1xuICAgIHRhZ1sncGxheWVyJ10gPSBlbFsncGxheWVyJ10gPSB0aGlzO1xuICAgIC8vIERlZmF1bHQgc3RhdGUgb2YgdmlkZW8gaXMgcGF1c2VkXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuXG4gICAgLy8gQWRkIGEgc3R5bGUgZWxlbWVudCBpbiB0aGUgcGxheWVyIHRoYXQgd2UnbGwgdXNlIHRvIHNldCB0aGUgd2lkdGgvaGVpZ2h0XG4gICAgLy8gb2YgdGhlIHBsYXllciBpbiBhIHdheSB0aGF0J3Mgc3RpbGwgb3ZlcnJpZGVhYmxlIGJ5IENTUywganVzdCBsaWtlIHRoZVxuICAgIC8vIHZpZGVvIGVsZW1lbnRcbiAgICB0aGlzLnN0eWxlRWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlRWxfKTtcblxuICAgIC8vIFBhc3MgaW4gdGhlIHdpZHRoL2hlaWdodC9hc3BlY3RSYXRpbyBvcHRpb25zIHdoaWNoIHdpbGwgdXBkYXRlIHRoZSBzdHlsZSBlbFxuICAgIHRoaXMud2lkdGgodGhpcy5vcHRpb25zX1snd2lkdGgnXSk7XG4gICAgdGhpcy5oZWlnaHQodGhpcy5vcHRpb25zX1snaGVpZ2h0J10pO1xuICAgIHRoaXMuZmx1aWQodGhpcy5vcHRpb25zX1snZmx1aWQnXSk7XG4gICAgdGhpcy5hc3BlY3RSYXRpbyh0aGlzLm9wdGlvbnNfWydhc3BlY3RSYXRpbyddKTtcblxuICAgIC8vIGluc2VydEZpcnN0IHNlZW1zIHRvIGNhdXNlIHRoZSBuZXR3b3JrU3RhdGUgdG8gZmxpY2tlciBmcm9tIDMgdG8gMiwgc29cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBmb3IgbGF0ZXIgc28gd2UgY2FuIGtub3cgaWYgdGhlIHNvdXJjZSBvcmlnaW5hbGx5IGZhaWxlZFxuICAgIHRhZy5pbml0TmV0d29ya1N0YXRlXyA9IHRhZy5uZXR3b3JrU3RhdGU7XG5cbiAgICAvLyBXcmFwIHZpZGVvIHRhZyBpbiBkaXYgKGVsL2JveCkgY29udGFpbmVyXG4gICAgaWYgKHRhZy5wYXJlbnROb2RlKSB7XG4gICAgICB0YWcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhZyk7XG4gICAgfVxuICAgIERvbS5pbnNlcnRGaXJzdCh0YWcsIGVsKTsgLy8gQnJlYWtzIGlQaG9uZSwgZml4ZWQgaW4gSFRNTDUgc2V0dXAuXG5cbiAgICB0aGlzLmVsXyA9IGVsO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgd2lkdGgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ3dpZHRoJywgdmFsdWUpO1xuICB9XG5cbiAgaGVpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCB2YWx1ZSk7XG4gIH1cblxuICBkaW1lbnNpb24oZGltZW5zaW9uLCB2YWx1ZSkge1xuICAgIGxldCBwcml2RGltZW5zaW9uID0gZGltZW5zaW9uICsgJ18nO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZEaW1lbnNpb25dIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgLy8gSWYgYW4gZW1wdHkgc3RyaW5nIGlzIGdpdmVuLCByZXNldCB0aGUgZGltZW5zaW9uIHRvIGJlIGF1dG9tYXRpY1xuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhcnNlZFZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgICBpZiAoaXNOYU4ocGFyc2VkVmFsKSkge1xuICAgICAgICBsb2cuZXJyb3IoYEltcHJvcGVyIHZhbHVlIFwiJHt2YWx1ZX1cIiBzdXBwbGllZCBmb3IgZm9yICR7ZGltZW5zaW9ufWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHBhcnNlZFZhbDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmbHVpZChib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5mbHVpZF87XG4gICAgfVxuXG4gICAgdGhpcy5mbHVpZF8gPSAhIWJvb2w7XG5cbiAgICBpZiAoYm9vbCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWZsdWlkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mbHVpZCcpO1xuICAgIH1cbiAgfVxuXG4gIGFzcGVjdFJhdGlvKHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igd2lkdGg6aGVpZ2h0IGZvcm1hdFxuICAgIGlmICghL15cXGQrXFw6XFxkKyQvLnRlc3QocmF0aW8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcHJvcGVyIHZhbHVlIHN1cGxpZWQgZm9yIGFzcGVjdCByYXRpby4gVGhlIGZvcm1hdCBzaG91bGQgYmUgd2lkdGg6aGVpZ2h0LCBmb3IgZXhhbXBsZSAxNjo5LicpO1xuICAgIH1cbiAgICB0aGlzLmFzcGVjdFJhdGlvXyA9IHJhdGlvO1xuXG4gICAgLy8gV2UncmUgYXNzdW1pbmcgaWYgeW91IHNldCBhbiBhc3BlY3QgcmF0aW8geW91IHdhbnQgZmx1aWQgbW9kZSxcbiAgICAvLyBiZWNhdXNlIGluIGZpeGVkIG1vZGUgeW91IGNvdWxkIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IHlvdXJzZWxmLlxuICAgIHRoaXMuZmx1aWQodHJ1ZSk7XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gIH1cblxuICB1cGRhdGVTdHlsZUVsXygpIHtcbiAgICBsZXQgd2lkdGg7XG4gICAgbGV0IGhlaWdodDtcbiAgICBsZXQgYXNwZWN0UmF0aW87XG5cbiAgICAvLyBUaGUgYXNwZWN0IHJhdGlvIGlzIGVpdGhlciB1c2VkIGRpcmVjdGx5IG9yIHRvIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYXNwZWN0UmF0aW9fICE9PSAnYXV0bycpIHtcbiAgICAgIC8vIFVzZSBhbnkgYXNwZWN0UmF0aW8gdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9XaWR0aCgpKSB7XG4gICAgICAvLyBPdGhlcndpc2UgdHJ5IHRvIGdldCB0aGUgYXNwZWN0IHJhdGlvIGZyb20gdGhlIHZpZGVvIG1ldGFkYXRhXG4gICAgICBhc3BlY3RSYXRpbyA9IHRoaXMudmlkZW9XaWR0aCgpICsgJzonICsgdGhpcy52aWRlb0hlaWdodCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPciB1c2UgYSBkZWZhdWx0LiBUaGUgdmlkZW8gZWxlbWVudCdzIGlzIDI6MSwgYnV0IDE2OjkgaXMgbW9yZSBjb21tb24uXG4gICAgICBhc3BlY3RSYXRpbyA9ICcxNjo5JztcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIHJhdGlvIGFzIGEgZGVjaW1hbCB3ZSBjYW4gdXNlIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb25zXG4gICAgbGV0IHJhdGlvUGFydHMgPSBhc3BlY3RSYXRpby5zcGxpdCgnOicpO1xuICAgIGxldCByYXRpb011bHRpcGxpZXIgPSByYXRpb1BhcnRzWzFdIC8gcmF0aW9QYXJ0c1swXTtcblxuICAgIGlmICh0aGlzLndpZHRoXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBVc2UgYW55IHdpZHRoIHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aF87XG4gICAgfSBlbHNlIGlmICh0aGlzLmhlaWdodF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gT3IgY2FsdWxhdGUgdGhlIHdpZHRoIGZyb20gdGhlIGFzcGVjdCByYXRpbyBpZiBhIGhlaWdodCBoYXMgYmVlbiBzZXRcbiAgICAgIHdpZHRoID0gdGhpcy5oZWlnaHRfIC8gcmF0aW9NdWx0aXBsaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPciB1c2UgdGhlIHZpZGVvJ3MgbWV0YWRhdGEsIG9yIHVzZSB0aGUgdmlkZW8gZWwncyBkZWZhdWx0IG9mIDMwMFxuICAgICAgd2lkdGggPSB0aGlzLnZpZGVvV2lkdGgoKSB8fCAzMDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGVpZ2h0XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBVc2UgYW55IGhlaWdodCB0aGF0J3MgYmVlbiBzcGVjaWZpY2FsbHkgc2V0XG4gICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodF87XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIGhlaWdodCBmcm9tIHRoZSByYXRpbyBhbmQgdGhlIHdpZHRoXG4gICAgICBoZWlnaHQgPSB3aWR0aCAqIHJhdGlvTXVsdGlwbGllcjtcbiAgICB9XG5cbiAgICBsZXQgaWRDbGFzcyA9IHRoaXMuaWQoKSsnLWRpbWVuc2lvbnMnO1xuXG4gICAgLy8gRW5zdXJlIHRoZSByaWdodCBjbGFzcyBpcyBzdGlsbCBvbiB0aGUgcGxheWVyIGZvciB0aGUgc3R5bGUgZWxlbWVudFxuICAgIHRoaXMuYWRkQ2xhc3MoaWRDbGFzcyk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHdpZHRoL2hlaWdodCBDU1NcbiAgICB2YXIgY3NzID0gYC4ke2lkQ2xhc3N9IHsgd2lkdGg6ICR7d2lkdGh9cHg7IGhlaWdodDogJHtoZWlnaHR9cHg7IH1gO1xuICAgIC8vIEFkZCB0aGUgYXNwZWN0IHJhdGlvIENTUyBmb3Igd2hlbiB1c2luZyBhIGZsdWlkIGxheW91dFxuICAgIGNzcyArPSBgLiR7aWRDbGFzc30udmpzLWZsdWlkIHsgcGFkZGluZy10b3A6ICR7cmF0aW9NdWx0aXBsaWVyICogMTAwfSU7IH1gO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzdHlsZSBlbFxuICAgIGlmICh0aGlzLnN0eWxlRWxfLnN0eWxlU2hlZXQpe1xuICAgICAgdGhpcy5zdHlsZUVsXy5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8uaW5uZXJIVE1MID0gY3NzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBNZWRpYSBQbGF5YmFjayBUZWNobm9sb2d5ICh0ZWNoKVxuICAgKiBMb2FkL0NyZWF0ZSBhbiBpbnN0YW5jZSBvZiBwbGF5YmFjayB0ZWNobm9sb2d5IGluY2x1ZGluZyBlbGVtZW50IGFuZCBBUEkgbWV0aG9kc1xuICAgKiBBbmQgYXBwZW5kIHBsYXliYWNrIGVsZW1lbnQgaW4gcGxheWVyIGRpdi5cbiAgICovXG4gIGxvYWRUZWNoKHRlY2hOYW1lLCBzb3VyY2UpIHtcblxuICAgIC8vIFBhdXNlIGFuZCByZW1vdmUgY3VycmVudCBwbGF5YmFjayB0ZWNobm9sb2d5XG4gICAgaWYgKHRoaXMudGVjaCkge1xuICAgICAgdGhpcy51bmxvYWRUZWNoKCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHJpZCBvZiB0aGUgSFRNTDUgdmlkZW8gdGFnIGFzIHNvb24gYXMgd2UgYXJlIHVzaW5nIGFub3RoZXIgdGVjaFxuICAgIGlmICh0ZWNoTmFtZSAhPT0gJ0h0bWw1JyAmJiB0aGlzLnRhZykge1xuICAgICAgQ29tcG9uZW50LmdldENvbXBvbmVudCgnSHRtbDUnKS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMudGFnKTtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50ZWNoTmFtZSA9IHRlY2hOYW1lO1xuXG4gICAgLy8gVHVybiBvZmYgQVBJIGFjY2VzcyBiZWNhdXNlIHdlJ3JlIGxvYWRpbmcgYSBuZXcgdGVjaCB0aGF0IG1pZ2h0IGxvYWQgYXN5bmNocm9ub3VzbHlcbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICB2YXIgdGVjaFJlYWR5ID0gRm4uYmluZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlclJlYWR5KCk7XG4gICAgfSk7XG5cbiAgICAvLyBHcmFiIHRlY2gtc3BlY2lmaWMgb3B0aW9ucyBmcm9tIHBsYXllciBvcHRpb25zIGFuZCBhZGQgc291cmNlIGFuZCBwYXJlbnQgZWxlbWVudCB0byB1c2UuXG4gICAgdmFyIHRlY2hPcHRpb25zID0gYXNzaWduKHtcbiAgICAgICdzb3VyY2UnOiBzb3VyY2UsXG4gICAgICAncGxheWVySWQnOiB0aGlzLmlkKCksXG4gICAgICAndGV4dFRyYWNrcyc6IHRoaXMudGV4dFRyYWNrc19cbiAgICB9LCB0aGlzLm9wdGlvbnNfW3RlY2hOYW1lLnRvTG93ZXJDYXNlKCldKTtcblxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGVjaE9wdGlvbnMudGFnID0gdGhpcy50YWc7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5jdXJyZW50VHlwZV8gPSBzb3VyY2UudHlwZTtcbiAgICAgIGlmIChzb3VyY2Uuc3JjID09PSB0aGlzLmNhY2hlXy5zcmMgJiYgdGhpcy5jYWNoZV8uY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICAgIHRlY2hPcHRpb25zWydzdGFydFRpbWUnXSA9IHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhY2hlXy5zcmMgPSBzb3VyY2Uuc3JjO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGVjaCBpbnN0YW5jZVxuICAgIGxldCB0ZWNoQ29tcG9uZW50ID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG4gICAgdGhpcy50ZWNoID0gbmV3IHRlY2hDb21wb25lbnQodGVjaE9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdyZWFkeScsIHRoaXMuaGFuZGxlVGVjaFJlYWR5KTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3VzZW5hdGl2ZWNvbnRyb2xzJywgdGhpcy5oYW5kbGVUZWNoVXNlTmF0aXZlQ29udHJvbHMpO1xuXG4gICAgLy8gTGlzdGVuIHRvIGV2ZXJ5IEhUTUw1IGV2ZW50cyBhbmQgdHJpZ2dlciB0aGVtIGJhY2sgb24gdGhlIHBsYXllciBmb3IgdGhlIHBsdWdpbnNcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ2xvYWRzdGFydCcsIHRoaXMuaGFuZGxlVGVjaExvYWRTdGFydCk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICd3YWl0aW5nJywgdGhpcy5oYW5kbGVUZWNoV2FpdGluZyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdjYW5wbGF5JywgdGhpcy5oYW5kbGVUZWNoQ2FuUGxheSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3BsYXlpbmcnLCB0aGlzLmhhbmRsZVRlY2hQbGF5aW5nKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ2VuZGVkJywgdGhpcy5oYW5kbGVUZWNoRW5kZWQpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnc2Vla2luZycsIHRoaXMuaGFuZGxlVGVjaFNlZWtpbmcpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnc2Vla2VkJywgdGhpcy5oYW5kbGVUZWNoU2Vla2VkKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3BsYXknLCB0aGlzLmhhbmRsZVRlY2hQbGF5KTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ2ZpcnN0cGxheScsIHRoaXMuaGFuZGxlVGVjaEZpcnN0UGxheSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdwYXVzZScsIHRoaXMuaGFuZGxlVGVjaFBhdXNlKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3Byb2dyZXNzJywgdGhpcy5oYW5kbGVUZWNoUHJvZ3Jlc3MpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnZHVyYXRpb25jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdlcnJvcicsIHRoaXMuaGFuZGxlVGVjaEVycm9yKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3N1c3BlbmQnLCB0aGlzLmhhbmRsZVRlY2hTdXNwZW5kKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ2Fib3J0JywgdGhpcy5oYW5kbGVUZWNoQWJvcnQpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnZW1wdGllZCcsIHRoaXMuaGFuZGxlVGVjaEVtcHRpZWQpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnc3RhbGxlZCcsIHRoaXMuaGFuZGxlVGVjaFN0YWxsZWQpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnbG9hZGVkbWV0YWRhdGEnLCB0aGlzLmhhbmRsZVRlY2hMb2FkZWRNZXRhRGF0YSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdsb2FkZWRkYXRhJywgdGhpcy5oYW5kbGVUZWNoTG9hZGVkRGF0YSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICd0aW1ldXBkYXRlJywgdGhpcy5oYW5kbGVUZWNoVGltZVVwZGF0ZSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdyYXRlY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoUmF0ZUNoYW5nZSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICd2b2x1bWVjaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hWb2x1bWVDaGFuZ2UpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAndGV4dHRyYWNrY2hhbmdlJywgdGhpcy5vblRleHRUcmFja0NoYW5nZSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdsb2FkZWRtZXRhZGF0YScsIHRoaXMudXBkYXRlU3R5bGVFbF8pO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbHMoKSAmJiAhdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSB0ZWNoIGVsZW1lbnQgaW4gdGhlIERPTSBpZiBpdCB3YXMgbm90IGFscmVhZHkgdGhlcmVcbiAgICAvLyBNYWtlIHN1cmUgdG8gbm90IGluc2VydCB0aGUgb3JpZ2luYWwgdmlkZW8gZWxlbWVudCBpZiB1c2luZyBIdG1sNVxuICAgIGlmICh0aGlzLnRlY2guZWwoKS5wYXJlbnROb2RlICE9PSB0aGlzLmVsKCkgJiYgKHRlY2hOYW1lICE9PSAnSHRtbDUnIHx8ICF0aGlzLnRhZykpIHtcbiAgICAgIERvbS5pbnNlcnRGaXJzdCh0aGlzLnRlY2guZWwoKSwgdGhpcy5lbCgpKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcmlkIG9mIHRoZSBvcmlnaW5hbCB2aWRlbyB0YWcgcmVmZXJlbmNlIGFmdGVyIHRoZSBmaXJzdCB0ZWNoIGlzIGxvYWRlZFxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGhpcy50YWcucGxheWVyID0gbnVsbDtcbiAgICAgIHRoaXMudGFnID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnRlY2gucmVhZHkodGVjaFJlYWR5KTtcbiAgfVxuXG4gIHVubG9hZFRlY2goKSB7XG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCB0ZXh0IHRyYWNrcyBzbyB0aGF0IHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0ZXh0IHRyYWNrcyB3aXRoIHRoZSBuZXh0IHRlY2hcbiAgICB0aGlzLnRleHRUcmFja3NfID0gdGhpcy50ZXh0VHJhY2tzKCk7XG5cbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICB0aGlzLnRlY2guZGlzcG9zZSgpO1xuXG4gICAgdGhpcy50ZWNoID0gZmFsc2U7XG4gIH1cblxuICBhZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnMoKSB7XG4gICAgLy8gU29tZSBicm93c2VycyAoQ2hyb21lICYgSUUpIGRvbid0IHRyaWdnZXIgYSBjbGljayBvbiBhIGZsYXNoIHN3ZiwgYnV0IGRvXG4gICAgLy8gdHJpZ2dlciBtb3VzZWRvd24vdXAuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDQ0NTYyL2phdmFzY3JpcHQtb25jbGljay1ldmVudC1vdmVyLWZsYXNoLW9iamVjdFxuICAgIC8vIEFueSB0b3VjaCBldmVudHMgYXJlIHNldCB0byBibG9jayB0aGUgbW91c2Vkb3duIGV2ZW50IGZyb20gaGFwcGVuaW5nXG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGljayk7XG5cbiAgICAvLyBJZiB0aGUgY29udHJvbHMgd2VyZSBoaWRkZW4gd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGNoYW5nZSB3aXRob3V0IGEgdGFwIGV2ZW50XG4gICAgLy8gc28gd2UnbGwgY2hlY2sgaWYgdGhlIGNvbnRyb2xzIHdlcmUgYWxyZWFkeSBzaG93aW5nIGJlZm9yZSByZXBvcnRpbmcgdXNlclxuICAgIC8vIGFjdGl2aXR5XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydCk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmUpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZCk7XG5cbiAgICAvLyBUdXJuIG9uIGNvbXBvbmVudCB0YXAgZXZlbnRzXG4gICAgdGhpcy50ZWNoLmVtaXRUYXBFdmVudHMoKTtcblxuICAgIC8vIFRoZSB0YXAgbGlzdGVuZXIgbmVlZHMgdG8gY29tZSBhZnRlciB0aGUgdG91Y2hlbmQgbGlzdGVuZXIgYmVjYXVzZSB0aGUgdGFwXG4gICAgLy8gbGlzdGVuZXIgY2FuY2VscyBvdXQgYW55IHJlcG9ydGVkVXNlckFjdGl2aXR5IHdoZW4gc2V0dGluZyB1c2VyQWN0aXZlKGZhbHNlKVxuICAgIHRoaXMub24odGhpcy50ZWNoLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGxpc3RlbmVycyB1c2VkIGZvciBjbGljayBhbmQgdGFwIGNvbnRyb2xzLiBUaGlzIGlzIG5lZWRlZCBmb3JcbiAgICogdG9nZ2xpbmcgdG8gY29udHJvbHMgZGlzYWJsZWQsIHdoZXJlIGEgdGFwL3RvdWNoIHNob3VsZCBkbyBub3RoaW5nLlxuICAgKi9cbiAgcmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzKCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8ganVzdCB1c2UgYHRoaXMub2ZmKClgIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbmVlZGVkXG4gICAgLy8gbGlzdGVuZXJzIGFkZGVkIGJ5IHRlY2hzIHRoYXQgZXh0ZW5kIHRoaXMuXG4gICAgdGhpcy5vZmYodGhpcy50ZWNoLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2gsICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydCk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2gsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2gsICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGljayk7XG4gIH1cblxuICAvKipcbiAgICogUGxheWVyIHdhaXRzIGZvciB0aGUgdGVjaCB0byBiZSByZWFkeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVGVjaFJlYWR5KCkge1xuICAgIHRoaXMudHJpZ2dlclJlYWR5KCk7XG5cbiAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGhhdmUgaXNzdWVzIHdpdGggYXV0b3BsYXkuXG4gICAgLy8gSW4gU2FmYXJpICg1LjEuMSksIHdoZW4gd2UgbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXIgZGl2LCBhdXRvcGxheSBkb2Vzbid0IHdvcmsuXG4gICAgLy8gSW4gQ2hyb21lICgxNSksIGlmIHlvdSBoYXZlIGF1dG9wbGF5ICsgYSBwb3N0ZXIgKyBubyBjb250cm9scywgdGhlIHZpZGVvIGdldHMgaGlkZGVuIChidXQgYXVkaW8gcGxheXMpXG4gICAgLy8gVGhpcyBmaXhlcyBib3RoIGlzc3Vlcy4gTmVlZCB0byB3YWl0IGZvciBBUEksIHNvIGl0IHVwZGF0ZXMgZGlzcGxheXMgY29ycmVjdGx5XG4gICAgaWYgKHRoaXMudGFnICYmIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgJiYgdGhpcy5wYXVzZWQoKSkge1xuICAgICAgZGVsZXRlIHRoaXMudGFnLnBvc3RlcjsgLy8gQ2hyb21lIEZpeC4gRml4ZWQgaW4gQ2hyb21lIHYxNi5cbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBuYXRpdmUgY29udHJvbHMgYXJlIHVzZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRlY2hVc2VOYXRpdmVDb250cm9scygpIHtcbiAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHModHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBhZ2VudCBiZWdpbnMgbG9va2luZyBmb3IgbWVkaWEgZGF0YVxuICAgKiBAZXZlbnQgbG9hZHN0YXJ0XG4gICAqL1xuICBoYW5kbGVUZWNoTG9hZFN0YXJ0KCkge1xuICAgIC8vIFRPRE86IFVwZGF0ZSB0byB1c2UgYGVtcHRpZWRgIGV2ZW50IGluc3RlYWQuIFNlZSAjMTI3Ny5cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuXG4gICAgLy8gcmVzZXQgdGhlIGVycm9yIHN0YXRlXG4gICAgdGhpcy5lcnJvcihudWxsKTtcblxuICAgIC8vIElmIGl0J3MgYWxyZWFkeSBwbGF5aW5nIHdlIHdhbnQgdG8gdHJpZ2dlciBhIGZpcnN0cGxheSBldmVudCBub3cuXG4gICAgLy8gVGhlIGZpcnN0cGxheSBldmVudCByZWxpZXMgb24gYm90aCB0aGUgcGxheSBhbmQgbG9hZHN0YXJ0IGV2ZW50c1xuICAgIC8vIHdoaWNoIGNhbiBoYXBwZW4gaW4gYW55IG9yZGVyIGZvciBhIG5ldyBzb3VyY2VcbiAgICBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldCB0aGUgaGFzU3RhcnRlZCBzdGF0ZVxuICAgICAgdGhpcy5oYXNTdGFydGVkKGZhbHNlKTtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgfVxuICB9XG5cbiAgaGFzU3RhcnRlZChoYXNTdGFydGVkKSB7XG4gICAgaWYgKGhhc1N0YXJ0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gb25seSB1cGRhdGUgaWYgdGhpcyBpcyBhIG5ldyB2YWx1ZVxuICAgICAgaWYgKHRoaXMuaGFzU3RhcnRlZF8gIT09IGhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IGhhc1N0YXJ0ZWQ7XG4gICAgICAgIGlmIChoYXNTdGFydGVkKSB7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgICAgICAgLy8gdHJpZ2dlciB0aGUgZmlyc3RwbGF5IGV2ZW50IGlmIHRoaXMgbmV3bHkgaGFzIHBsYXllZFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmhhc1N0YXJ0ZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBiZWdpbnMgb3IgcmVzdW1lcyBwbGF5YmFja1xuICAgKiBAZXZlbnQgcGxheVxuICAgKi9cbiAgaGFuZGxlVGVjaFBsYXkoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG5cbiAgICAvLyBoaWRlIHRoZSBwb3N0ZXIgd2hlbiB0aGUgdXNlciBoaXRzIHBsYXlcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXlcbiAgICB0aGlzLmhhc1N0YXJ0ZWQodHJ1ZSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgYmVnaW5zIHdhaXRpbmdcbiAgICogQGV2ZW50IHdhaXRpbmdcbiAgICovXG4gIGhhbmRsZVRlY2hXYWl0aW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCd3YWl0aW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogQSBoYW5kbGVyIGZvciBldmVudHMgdGhhdCBzaWduYWwgdGhhdCB3YWl0aW5nIGhhcyBlbmRlZFxuICAgKiB3aGljaCBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICogQGV2ZW50IGNhbnBsYXlcbiAgICovXG4gIGhhbmRsZVRlY2hDYW5QbGF5KCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdjYW5wbGF5Jyk7XG4gIH1cblxuICAvKipcbiAgICogQSBoYW5kbGVyIGZvciBldmVudHMgdGhhdCBzaWduYWwgdGhhdCB3YWl0aW5nIGhhcyBlbmRlZFxuICAgKiB3aGljaCBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICogQGV2ZW50IGNhbnBsYXl0aHJvdWdoXG4gICAqL1xuICBoYW5kbGVUZWNoQ2FuUGxheVRocm91Z2goKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbnBsYXl0aHJvdWdoJyk7XG4gIH1cblxuICAvKipcbiAgICogQSBoYW5kbGVyIGZvciBldmVudHMgdGhhdCBzaWduYWwgdGhhdCB3YWl0aW5nIGhhcyBlbmRlZFxuICAgKiB3aGljaCBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICogQGV2ZW50IHBsYXlpbmdcbiAgICovXG4gIGhhbmRsZVRlY2hQbGF5aW5nKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdwbGF5aW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHBsYXllciBpcyBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICogQGV2ZW50IHNlZWtpbmdcbiAgICovXG4gIGhhbmRsZVRlY2hTZWVraW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdzZWVraW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBmaW5pc2hlZCBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICogQGV2ZW50IHNlZWtlZFxuICAgKi9cbiAgaGFuZGxlVGVjaFNlZWtlZCgpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2Vla2luZycpO1xuICAgIHRoaXMudHJpZ2dlcignc2Vla2VkJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgdGhlIGZpcnN0IHRpbWUgYSB2aWRlbyBpcyBwbGF5ZWRcbiAgICpcbiAgICogTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgd2UncmUgbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdFxuICAgKiBpbXBsZW1lbnRhdGlvbiB5ZXQsIHNvIHVzZSBzcGFyaW5nbHkuIElmIHlvdSBkb24ndCBoYXZlIGEgcmVhc29uIHRvXG4gICAqIHByZXZlbnQgcGxheWJhY2ssIHVzZSBgbXlQbGF5ZXIub25lKCdwbGF5Jyk7YCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZXZlbnQgZmlyc3RwbGF5XG4gICAqL1xuICBoYW5kbGVUZWNoRmlyc3RQbGF5KCkge1xuICAgIC8vSWYgdGhlIGZpcnN0IHN0YXJ0dGltZSBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkXG4gICAgLy90aGVuIHdlIHdpbGwgc3RhcnQgYXQgdGhlIGdpdmVuIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgaWYodGhpcy5vcHRpb25zX1snc3RhcnR0aW1lJ10pe1xuICAgICAgdGhpcy5jdXJyZW50VGltZSh0aGlzLm9wdGlvbnNfWydzdGFydHRpbWUnXSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgaGFzIGJlZW4gcGF1c2VkXG4gICAqIEBldmVudCBwYXVzZVxuICAgKi9cbiAgaGFuZGxlVGVjaFBhdXNlKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMudHJpZ2dlcigncGF1c2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGlsZSB0aGUgdXNlciBhZ2VudCBpcyBkb3dubG9hZGluZyBtZWRpYSBkYXRhXG4gICAqIEBldmVudCBwcm9ncmVzc1xuICAgKi9cbiAgaGFuZGxlVGVjaFByb2dyZXNzKCkge1xuICAgIHRoaXMudHJpZ2dlcigncHJvZ3Jlc3MnKTtcblxuICAgIC8vIEFkZCBjdXN0b20gZXZlbnQgZm9yIHdoZW4gc291cmNlIGlzIGZpbmlzaGVkIGRvd25sb2FkaW5nLlxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkUGVyY2VudCgpID09PSAxKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRlZGFsbGRhdGEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyByZWFjaGVkIChjdXJyZW50VGltZSA9PSBkdXJhdGlvbilcbiAgICogQGV2ZW50IGVuZGVkXG4gICAqL1xuICBoYW5kbGVUZWNoRW5kZWQoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgaWYgKHRoaXMub3B0aW9uc19bJ2xvb3AnXSkge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSgwKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2VuZGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZHVyYXRpb24gb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIGZpcnN0IGtub3duIG9yIGNoYW5nZWRcbiAgICogQGV2ZW50IGR1cmF0aW9uY2hhbmdlXG4gICAqL1xuICBoYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2UoKSB7XG4gICAgdGhpcy51cGRhdGVEdXJhdGlvbigpO1xuICAgIHRoaXMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgbWVkaWEgZWxlbWVudCB0byBwbGF5L3BhdXNlXG4gICAqL1xuICBoYW5kbGVUZWNoQ2xpY2soZXZlbnQpIHtcbiAgICAvLyBXZSdyZSB1c2luZyBtb3VzZWRvd24gdG8gZGV0ZWN0IGNsaWNrcyB0aGFua3MgdG8gRmxhc2gsIGJ1dCBtb3VzZWRvd25cbiAgICAvLyB3aWxsIGFsc28gYmUgdHJpZ2dlcmVkIHdpdGggcmlnaHQtY2xpY2tzLCBzbyB3ZSBuZWVkIHRvIHByZXZlbnQgdGhhdFxuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgIC8vIFdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkIGEgY2xpY2sgc2hvdWxkIG5vdCB0b2dnbGUgcGxheWJhY2sgYmVjYXVzZVxuICAgIC8vIHRoZSBjbGljayBpcyBjb25zaWRlcmVkIGEgY29udHJvbFxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkpIHtcbiAgICAgIGlmICh0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0YXAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHdpbGwgdG9nZ2xlIHRoZSB1c2VyXG4gICAqIGFjdGl2aXR5IHN0YXRlLCB3aGljaCBoaWRlcyBhbmQgc2hvd3MgdGhlIGNvbnRyb2xzLlxuICAgKi9cbiAgaGFuZGxlVGVjaFRhcCgpIHtcbiAgICB0aGlzLnVzZXJBY3RpdmUoIXRoaXMudXNlckFjdGl2ZSgpKTtcbiAgfVxuXG4gIGhhbmRsZVRlY2hUb3VjaFN0YXJ0KCkge1xuICAgIHRoaXMudXNlcldhc0FjdGl2ZSA9IHRoaXMudXNlckFjdGl2ZSgpO1xuICB9XG5cbiAgaGFuZGxlVGVjaFRvdWNoTW92ZSgpIHtcbiAgICBpZiAodGhpcy51c2VyV2FzQWN0aXZlKXtcbiAgICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlVGVjaFRvdWNoRW5kKGV2ZW50KSB7XG4gICAgLy8gU3RvcCB0aGUgbW91c2UgZXZlbnRzIGZyb20gYWxzbyBoYXBwZW5pbmdcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZHVyYXRpb24gb2YgdGhlIHBsYXllciB1c2luZyB0aGUgdGVjaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlRHVyYXRpb24oKSB7XG4gICAgLy8gQWxsb3dzIGZvciBjYWNoaW5nIHZhbHVlIGluc3RlYWQgb2YgYXNraW5nIHBsYXllciBlYWNoIHRpbWUuXG4gICAgLy8gV2UgbmVlZCB0byBnZXQgdGhlIHRlY2hHZXQgcmVzcG9uc2UgYW5kIGNoZWNrIGZvciBhIHZhbHVlIHNvIHdlIGRvbid0XG4gICAgLy8gYWNjaWRlbnRhbGx5IGNhdXNlIHRoZSBzdGFjayB0byBibG93IHVwLlxuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMudGVjaEdldCgnZHVyYXRpb24nKTtcbiAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgIGlmIChkdXJhdGlvbiA8IDApIHtcbiAgICAgICAgZHVyYXRpb24gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBzdHJlYW0gaXMgbGl2ZSBhbmQgcHJvcGFnYXRlIHN0eWxlcyBkb3duIHRvIFVJLlxuICAgICAgaWYgKGR1cmF0aW9uID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtbGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIHN3aXRjaGVzIGluIG9yIG91dCBvZiBmdWxsc2NyZWVuIG1vZGVcbiAgICogQGV2ZW50IGZ1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG4gIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIG5hdGl2ZSBjbGljayBldmVudHMgb24gdGhlIFNXRiBhcmVuJ3QgdHJpZ2dlcmVkIG9uIElFMTEsIFdpbjguMVJUXG4gICAqIHVzZSBzdGFnZWNsaWNrIGV2ZW50cyB0cmlnZ2VyZWQgZnJvbSBpbnNpZGUgdGhlIFNXRiBpbnN0ZWFkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTdGFnZUNsaWNrKCkge1xuICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gIH1cblxuICBoYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlb1xuICAgKiBAZXZlbnQgZXJyb3JcbiAgICovXG4gIGhhbmRsZVRlY2hFcnJvcigpIHtcbiAgICB0aGlzLmVycm9yKHRoaXMudGVjaC5lcnJvcigpLmNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgaW50ZW50aW9uYWxseSBub3QgZ2V0dGluZyBtZWRpYSBkYXRhXG4gICAqIEBldmVudCBzdXNwZW5kXG4gICAqL1xuICBoYW5kbGVUZWNoU3VzcGVuZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3N1c3BlbmQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvIGlzIGFib3J0ZWRcbiAgICogQGV2ZW50IGFib3J0XG4gICAqL1xuICBoYW5kbGVUZWNoQWJvcnQoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdhYm9ydCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgZW1wdHlcbiAgICogQGV2ZW50IGVtcHRpZWRcbiAgICovXG4gIGhhbmRsZVRlY2hFbXB0aWVkKCkge1xuICAgIHRoaXMudHJpZ2dlcignZW1wdGllZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgdHJ5aW5nIHRvIGdldCBtZWRpYSBkYXRhLCBidXQgZGF0YSBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBldmVudCBzdGFsbGVkXG4gICAqL1xuICBoYW5kbGVUZWNoU3RhbGxlZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3N0YWxsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgbWV0YSBkYXRhIGZvciB0aGUgYXVkaW8vdmlkZW9cbiAgICogQGV2ZW50IGxvYWRlZG1ldGFkYXRhXG4gICAqL1xuICBoYW5kbGVUZWNoTG9hZGVkTWV0YURhdGEoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdsb2FkZWRtZXRhZGF0YScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaGFzIGxvYWRlZCB0aGUgY3VycmVudCBmcmFtZSBvZiB0aGUgYXVkaW8vdmlkZW9cbiAgICogQGV2ZW50IGxvYWRkYXRhXG4gICAqL1xuICBoYW5kbGVUZWNoTG9hZGVkRGF0YSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2xvYWRlZGRhdGEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG4gICAqIEBldmVudCB0aW1ldXBkYXRlXG4gICAqL1xuICBoYW5kbGVUZWNoVGltZVVwZGF0ZSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3RpbWV1cGRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBwbGF5aW5nIHNwZWVkIG9mIHRoZSBhdWRpby92aWRlbyBpcyBjaGFuZ2VkXG4gICAqIEBldmVudCByYXRlY2hhbmdlXG4gICAqL1xuICBoYW5kbGVUZWNoUmF0ZUNoYW5nZSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3JhdGVjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSB2b2x1bWUgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAZXZlbnQgdm9sdW1lY2hhbmdlXG4gICAqL1xuICBoYW5kbGVUZWNoVm9sdW1lQ2hhbmdlKCkge1xuICAgIHRoaXMudHJpZ2dlcigndm9sdW1lY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgdGV4dCB0cmFjayBoYXMgYmVlbiBjaGFuZ2VkXG4gICAqIEBldmVudCB0ZXh0dHJhY2tjaGFuZ2VcbiAgICovXG4gIG9uVGV4dFRyYWNrQ2hhbmdlKCkge1xuICAgIHRoaXMudHJpZ2dlcigndGV4dHRyYWNrY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogT2JqZWN0IGZvciBjYWNoZWQgdmFsdWVzLlxuICAgKi9cbiAgZ2V0Q2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfO1xuICB9XG5cbiAgLy8gUGFzcyB2YWx1ZXMgdG8gdGhlIHBsYXliYWNrIHRlY2hcbiAgdGVjaENhbGwobWV0aG9kLCBhcmcpIHtcbiAgICAvLyBJZiBpdCdzIG5vdCByZWFkeSB5ZXQsIGNhbGwgbWV0aG9kIHdoZW4gaXQgaXNcbiAgICBpZiAodGhpcy50ZWNoICYmICF0aGlzLnRlY2guaXNSZWFkeV8pIHtcbiAgICAgIHRoaXMudGVjaC5yZWFkeShmdW5jdGlvbigpe1xuICAgICAgICB0aGlzW21ldGhvZF0oYXJnKTtcbiAgICAgIH0pO1xuXG4gICAgLy8gT3RoZXJ3aXNlIGNhbGwgbWV0aG9kIG5vd1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnRlY2hbbWV0aG9kXShhcmcpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxvZyhlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBHZXQgY2FsbHMgY2FuJ3Qgd2FpdCBmb3IgdGhlIHRlY2gsIGFuZCBzb21ldGltZXMgZG9uJ3QgbmVlZCB0by5cbiAgdGVjaEdldChtZXRob2QpIHtcbiAgICBpZiAodGhpcy50ZWNoICYmIHRoaXMudGVjaC5pc1JlYWR5Xykge1xuXG4gICAgICAvLyBGbGFzaCBsaWtlcyB0byBkaWUgYW5kIHJlbG9hZCB3aGVuIHlvdSBoaWRlIG9yIHJlcG9zaXRpb24gaXQuXG4gICAgICAvLyBJbiB0aGVzZSBjYXNlcyB0aGUgb2JqZWN0IG1ldGhvZHMgZ28gYXdheSBhbmQgd2UgZ2V0IGVycm9ycy5cbiAgICAgIC8vIFdoZW4gdGhhdCBoYXBwZW5zIHdlJ2xsIGNhdGNoIHRoZSBlcnJvcnMgYW5kIGluZm9ybSB0ZWNoIHRoYXQgaXQncyBub3QgcmVhZHkgYW55IG1vcmUuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZWNoW21ldGhvZF0oKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBXaGVuIGJ1aWxkaW5nIGFkZGl0aW9uYWwgdGVjaCBsaWJzLCBhbiBleHBlY3RlZCBtZXRob2QgbWF5IG5vdCBiZSBkZWZpbmVkIHlldFxuICAgICAgICBpZiAodGhpcy50ZWNoW21ldGhvZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxvZyhgVmlkZW8uanM6ICR7bWV0aG9kfSBtZXRob2Qgbm90IGRlZmluZWQgZm9yICR7dGhpcy50ZWNoTmFtZX0gcGxheWJhY2sgdGVjaG5vbG9neS5gLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuIGEgbWV0aG9kIGlzbid0IGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0IGl0IHRocm93cyBhIFR5cGVFcnJvclxuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgICBsb2coYFZpZGVvLmpzOiAke21ldGhvZH0gdW5hdmFpbGFibGUgb24gJHt0aGlzLnRlY2hOYW1lfSBwbGF5YmFjayB0ZWNobm9sb2d5IGVsZW1lbnQuYCwgZSk7XG4gICAgICAgICAgICB0aGlzLnRlY2guaXNSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdGFydCBtZWRpYSBwbGF5YmFja1xuICAgKlxuICAgKiAgICAgbXlQbGF5ZXIucGxheSgpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IHNlbGZcbiAgICovXG4gIHBsYXkoKSB7XG4gICAgdGhpcy50ZWNoQ2FsbCgncGxheScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSB2aWRlbyBwbGF5YmFja1xuICAgKlxuICAgKiAgICAgbXlQbGF5ZXIucGF1c2UoKTtcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICB0aGlzLnRlY2hDYWxsKCdwYXVzZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBwbGF5ZXIgaXMgcGF1c2VkXG4gICAqXG4gICAqICAgICB2YXIgaXNQYXVzZWQgPSBteVBsYXllci5wYXVzZWQoKTtcbiAgICogICAgIHZhciBpc1BsYXlpbmcgPSAhbXlQbGF5ZXIucGF1c2VkKCk7XG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZhbHNlIGlmIHRoZSBtZWRpYSBpcyBjdXJyZW50bHkgcGxheWluZywgb3IgdHJ1ZSBvdGhlcndpc2VcbiAgICovXG4gIHBhdXNlZCgpIHtcbiAgICAvLyBUaGUgaW5pdGlhbCBzdGF0ZSBvZiBwYXVzZWQgc2hvdWxkIGJlIHRydWUgKGluIFNhZmFyaSBpdCdzIGFjdHVhbGx5IGZhbHNlKVxuICAgIHJldHVybiAodGhpcy50ZWNoR2V0KCdwYXVzZWQnKSA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyBcInNjcnViYmluZ1wiLiBTY3J1YmJpbmcgaXMgd2hlbiB0aGUgdXNlclxuICAqIGhhcyBjbGlja2VkIHRoZSBwcm9ncmVzcyBiYXIgaGFuZGxlIGFuZCBpcyBkcmFnZ2luZyBpdCBhbG9uZyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzU2NydWJiaW5nICAgVHJ1ZS9mYWxzZSB0aGUgdXNlciBpcyBzY3J1YmJpbmdcbiAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgIFRoZSBzY3J1YmJpbmcgc3RhdHVzIHdoZW4gZ2V0dGluZ1xuICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgVGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgKi9cbiAgc2NydWJiaW5nKGlzU2NydWJiaW5nKSB7XG4gICAgaWYgKGlzU2NydWJiaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2NydWJiaW5nXyA9ICEhaXNTY3J1YmJpbmc7XG5cbiAgICAgIGlmIChpc1NjcnViYmluZykge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2NydWJiaW5nJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2NydWJiaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNjcnViYmluZ187XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCB0aW1lIChpbiBzZWNvbmRzKVxuICAgKlxuICAgKiAgICAgLy8gZ2V0XG4gICAqICAgICB2YXIgd2hlcmVZb3VBdCA9IG15UGxheWVyLmN1cnJlbnRUaW1lKCk7XG4gICAqXG4gICAqICAgICAvLyBzZXRcbiAgICogICAgIG15UGxheWVyLmN1cnJlbnRUaW1lKDEyMCk7IC8vIDIgbWludXRlcyBpbnRvIHRoZSB2aWRlb1xuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nPX0gc2Vjb25kcyBUaGUgdGltZSB0byBzZWVrIHRvXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgIFRoZSB0aW1lIGluIHNlY29uZHMsIHdoZW4gbm90IHNldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICBzZWxmLCB3aGVuIHRoZSBjdXJyZW50IHRpbWUgaXMgc2V0XG4gICAqL1xuICBjdXJyZW50VGltZShzZWNvbmRzKSB7XG4gICAgaWYgKHNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICB0aGlzLnRlY2hDYWxsKCdzZXRDdXJyZW50VGltZScsIHNlY29uZHMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBjYWNoZSBsYXN0IGN1cnJlbnRUaW1lIGFuZCByZXR1cm4uIGRlZmF1bHQgdG8gMCBzZWNvbmRzXG4gICAgLy9cbiAgICAvLyBDYWNoaW5nIHRoZSBjdXJyZW50VGltZSBpcyBtZWFudCB0byBwcmV2ZW50IGEgbWFzc2l2ZSBhbW91bnQgb2YgcmVhZHMgb24gdGhlIHRlY2gnc1xuICAgIC8vIGN1cnJlbnRUaW1lIHdoZW4gc2NydWJiaW5nLCBidXQgbWF5IG5vdCBwcm92aWRlIG11Y2ggcGVyZm9ybWFuY2UgYmVuZWZpdCBhZnRlcmFsbC5cbiAgICAvLyBTaG91bGQgYmUgdGVzdGVkLiBBbHNvIHNvbWV0aGluZyBoYXMgdG8gcmVhZCB0aGUgYWN0dWFsIGN1cnJlbnQgdGltZSBvciB0aGUgY2FjaGUgd2lsbFxuICAgIC8vIG5ldmVyIGdldCB1cGRhdGVkLlxuICAgIHJldHVybiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZSA9ICh0aGlzLnRlY2hHZXQoJ2N1cnJlbnRUaW1lJykgfHwgMCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsZW5ndGggaW4gdGltZSBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kc1xuICAgKlxuICAgKiAgICAgdmFyIGxlbmd0aE9mVmlkZW8gPSBteVBsYXllci5kdXJhdGlvbigpO1xuICAgKlxuICAgKiAqKk5PVEUqKjogVGhlIHZpZGVvIG11c3QgaGF2ZSBzdGFydGVkIGxvYWRpbmcgYmVmb3JlIHRoZSBkdXJhdGlvbiBjYW4gYmVcbiAgICoga25vd24sIGFuZCBpbiB0aGUgY2FzZSBvZiBGbGFzaCwgbWF5IG5vdCBiZSBrbm93biB1bnRpbCB0aGUgdmlkZW8gc3RhcnRzXG4gICAqIHBsYXlpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyBpbiBzZWNvbmRzXG4gICAqL1xuICBkdXJhdGlvbihzZWNvbmRzKSB7XG4gICAgaWYgKHNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAvLyBjYWNoZSB0aGUgbGFzdCBzZXQgdmFsdWUgZm9yIG9wdGltaXplZCBzY3J1YmJpbmcgKGVzcC4gRmxhc2gpXG4gICAgICB0aGlzLmNhY2hlXy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoc2Vjb25kcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhY2hlXy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUR1cmF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLmR1cmF0aW9uIHx8IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBob3cgbXVjaCB0aW1lIGlzIGxlZnQuXG4gICAqXG4gICAqICAgICB2YXIgdGltZUxlZnQgPSBteVBsYXllci5yZW1haW5pbmdUaW1lKCk7XG4gICAqXG4gICAqIE5vdCBhIG5hdGl2ZSB2aWRlbyBlbGVtZW50IGZ1bmN0aW9uLCBidXQgdXNlZnVsXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRpbWUgcmVtYWluaW5nIGluIHNlY29uZHNcbiAgICovXG4gIHJlbWFpbmluZ1RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24oKSAtIHRoaXMuY3VycmVudFRpbWUoKTtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvdmlkZW8uaHRtbCNkb20tbWVkaWEtYnVmZmVyZWRcbiAgLy8gQnVmZmVyZWQgcmV0dXJucyBhIHRpbWVyYW5nZSBvYmplY3QuXG4gIC8vIEtpbmQgb2YgbGlrZSBhbiBhcnJheSBvZiBwb3J0aW9ucyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCB3aXRoIHRoZSB0aW1lcyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZFxuICAgKlxuICAgKiBJZiB5b3UganVzdCB3YW50IHRoZSBwZXJjZW50IG9mIHRoZSB2aWRlbyB0aGF0J3MgYmVlbiBkb3dubG9hZGVkLFxuICAgKiB1c2UgYnVmZmVyZWRQZXJjZW50LlxuICAgKlxuICAgKiAgICAgLy8gTnVtYmVyIG9mIGRpZmZlcmVudCByYW5nZXMgb2YgdGltZSBoYXZlIGJlZW4gYnVmZmVyZWQuIFVzdWFsbHkgMS5cbiAgICogICAgIG51bWJlck9mUmFuZ2VzID0gYnVmZmVyZWRUaW1lUmFuZ2UubGVuZ3RoLFxuICAgKlxuICAgKiAgICAgLy8gVGltZSBpbiBzZWNvbmRzIHdoZW4gdGhlIGZpcnN0IHJhbmdlIHN0YXJ0cy4gVXN1YWxseSAwLlxuICAgKiAgICAgZmlyc3RSYW5nZVN0YXJ0ID0gYnVmZmVyZWRUaW1lUmFuZ2Uuc3RhcnQoMCksXG4gICAqXG4gICAqICAgICAvLyBUaW1lIGluIHNlY29uZHMgd2hlbiB0aGUgZmlyc3QgcmFuZ2UgZW5kc1xuICAgKiAgICAgZmlyc3RSYW5nZUVuZCA9IGJ1ZmZlcmVkVGltZVJhbmdlLmVuZCgwKSxcbiAgICpcbiAgICogICAgIC8vIExlbmd0aCBpbiBzZWNvbmRzIG9mIHRoZSBmaXJzdCB0aW1lIHJhbmdlXG4gICAqICAgICBmaXJzdFJhbmdlTGVuZ3RoID0gZmlyc3RSYW5nZUVuZCAtIGZpcnN0UmFuZ2VTdGFydDtcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBBIG1vY2sgVGltZVJhbmdlIG9iamVjdCAoZm9sbG93aW5nIEhUTUwgc3BlYylcbiAgICovXG4gIGJ1ZmZlcmVkKCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMudGVjaEdldCgnYnVmZmVyZWQnKTtcblxuICAgIGlmICghYnVmZmVyZWQgfHwgIWJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgYnVmZmVyZWQgPSBjcmVhdGVUaW1lUmFuZ2UoMCwwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50IChhcyBhIGRlY2ltYWwpIG9mIHRoZSB2aWRlbyB0aGF0J3MgYmVlbiBkb3dubG9hZGVkXG4gICAqXG4gICAqICAgICB2YXIgaG93TXVjaElzRG93bmxvYWRlZCA9IG15UGxheWVyLmJ1ZmZlcmVkUGVyY2VudCgpO1xuICAgKlxuICAgKiAwIG1lYW5zIG5vbmUsIDEgbWVhbnMgYWxsLlxuICAgKiAoVGhpcyBtZXRob2QgaXNuJ3QgaW4gdGhlIEhUTUw1IHNwZWMsIGJ1dCBpdCdzIHZlcnkgY29udmVuaWVudClcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxIHJlcHJlc2VudGluZyB0aGUgcGVyY2VudFxuICAgKi9cbiAgYnVmZmVyZWRQZXJjZW50KCkge1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSxcbiAgICAgICAgYnVmZmVyZWQgPSB0aGlzLmJ1ZmZlcmVkKCksXG4gICAgICAgIGJ1ZmZlcmVkRHVyYXRpb24gPSAwLFxuICAgICAgICBzdGFydCwgZW5kO1xuXG4gICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaT0wOyBpPGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKXtcbiAgICAgIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICBlbmQgICA9IGJ1ZmZlcmVkLmVuZChpKTtcblxuICAgICAgLy8gYnVmZmVyZWQgZW5kIGNhbiBiZSBiaWdnZXIgdGhhbiBkdXJhdGlvbiBieSBhIHZlcnkgc21hbGwgZnJhY3Rpb25cbiAgICAgIGlmIChlbmQgPiBkdXJhdGlvbikge1xuICAgICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgYnVmZmVyZWREdXJhdGlvbiArPSBlbmQgLSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWREdXJhdGlvbiAvIGR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIHRpbWUgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHByb2dyZXNzIGJhciB0byBlbmNhcHN1bGF0ZSBhbGwgdGltZSByYW5nZXMuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGVuZCBvZiB0aGUgbGFzdCBidWZmZXJlZCB0aW1lIHJhbmdlXG4gICAqL1xuICBidWZmZXJlZEVuZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLmJ1ZmZlcmVkKCksXG4gICAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpLFxuICAgICAgICBlbmQgPSBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoLTEpO1xuXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgdm9sdW1lIG9mIHRoZSBtZWRpYVxuICAgKlxuICAgKiAgICAgLy8gZ2V0XG4gICAqICAgICB2YXIgaG93TG91ZElzSXQgPSBteVBsYXllci52b2x1bWUoKTtcbiAgICpcbiAgICogICAgIC8vIHNldFxuICAgKiAgICAgbXlQbGF5ZXIudm9sdW1lKDAuNSk7IC8vIFNldCB2b2x1bWUgdG8gaGFsZlxuICAgKlxuICAgKiAwIGlzIG9mZiAobXV0ZWQpLCAxLjAgaXMgYWxsIHRoZSB3YXkgdXAsIDAuNSBpcyBoYWxmIHdheS5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSBwZXJjZW50QXNEZWNpbWFsIFRoZSBuZXcgdm9sdW1lIGFzIGEgZGVjaW1hbCBwZXJjZW50XG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICBUaGUgY3VycmVudCB2b2x1bWUsIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgICAgICAgICBzZWxmLCB3aGVuIHNldHRpbmdcbiAgICovXG4gIHZvbHVtZShwZXJjZW50QXNEZWNpbWFsKSB7XG4gICAgbGV0IHZvbDtcblxuICAgIGlmIChwZXJjZW50QXNEZWNpbWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZvbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHBhcnNlRmxvYXQocGVyY2VudEFzRGVjaW1hbCkpKTsgLy8gRm9yY2UgdmFsdWUgdG8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XG4gICAgICB0aGlzLnRlY2hDYWxsKCdzZXRWb2x1bWUnLCB2b2wpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIDEgd2hlbiByZXR1cm5pbmcgY3VycmVudCB2b2x1bWUuXG4gICAgdm9sID0gcGFyc2VGbG9hdCh0aGlzLnRlY2hHZXQoJ3ZvbHVtZScpKTtcbiAgICByZXR1cm4gKGlzTmFOKHZvbCkpID8gMSA6IHZvbDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBtdXRlZCBzdGF0ZSwgb3IgdHVybiBtdXRlIG9uIG9yIG9mZlxuICAgKlxuICAgKiAgICAgLy8gZ2V0XG4gICAqICAgICB2YXIgaXNWb2x1bWVNdXRlZCA9IG15UGxheWVyLm11dGVkKCk7XG4gICAqXG4gICAqICAgICAvLyBzZXRcbiAgICogICAgIG15UGxheWVyLm11dGVkKHRydWUpOyAvLyBtdXRlIHRoZSB2b2x1bWVcbiAgICpcbiAgICogQHBhcmFtICB7Qm9vbGVhbj19IG11dGVkIFRydWUgdG8gbXV0ZSwgZmFsc2UgdG8gdW5tdXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgbXV0ZSBpcyBvbiwgZmFsc2UgaWYgbm90LCB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmLCB3aGVuIHNldHRpbmcgbXV0ZVxuICAgKi9cbiAgbXV0ZWQobXV0ZWQpIHtcbiAgICBpZiAobXV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0TXV0ZWQnLCBtdXRlZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgnbXV0ZWQnKSB8fCBmYWxzZTsgLy8gRGVmYXVsdCB0byBmYWxzZVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXG4gIC8vIChlLmcuIHdpdGggYnVpbHQgaW4gY29udHJvbHMgbGlrZSBpT1MsIHNvIG5vdCBvdXIgZmxhc2ggc3dmKVxuICBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgnc3VwcG9ydHNGdWxsU2NyZWVuJykgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICpcbiAgICogICAgIC8vIGdldFxuICAgKiAgICAgdmFyIGZ1bGxzY3JlZW5Pck5vdCA9IG15UGxheWVyLmlzRnVsbHNjcmVlbigpO1xuICAgKlxuICAgKiAgICAgLy8gc2V0XG4gICAqICAgICBteVBsYXllci5pc0Z1bGxzY3JlZW4odHJ1ZSk7IC8vIHRlbGwgdGhlIHBsYXllciBpdCdzIGluIGZ1bGxzY3JlZW5cbiAgICpcbiAgICogTk9URTogQXMgb2YgdGhlIGxhdGVzdCBIVE1MNSBzcGVjLCBpc0Z1bGxzY3JlZW4gaXMgbm8gbG9uZ2VyIGFuIG9mZmljaWFsXG4gICAqIHByb3BlcnR5IGFuZCBpbnN0ZWFkIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IGlzIHVzZWQuIEJ1dCBpc0Z1bGxzY3JlZW4gaXNcbiAgICogc3RpbGwgYSB2YWx1YWJsZSBwcm9wZXJ0eSBmb3IgaW50ZXJuYWwgcGxheWVyIHdvcmtpbmdzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtCb29sZWFuPX0gaXNGUyBVcGRhdGUgdGhlIHBsYXllcidzIGZ1bGxzY3JlZW4gc3RhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBmdWxsc2NyZWVuLCBmYWxzZSBpZiBub3RcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmLCB3aGVuIHNldHRpbmdcbiAgICovXG4gIGlzRnVsbHNjcmVlbihpc0ZTKSB7XG4gICAgaWYgKGlzRlMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW5fID0gISFpc0ZTO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuaXNGdWxsc2NyZWVuXztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbGQgbmFtaW5nIGZvciBpc0Z1bGxzY3JlZW4oKVxuICAgKiBAZGVwcmVjYXRlZCBmb3IgbG93ZXJjYXNlICdzJyB2ZXJzaW9uXG4gICAqL1xuICBpc0Z1bGxTY3JlZW4oaXNGUykge1xuICAgIGxvZy53YXJuKCdwbGF5ZXIuaXNGdWxsU2NyZWVuKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHBsYXllci5pc0Z1bGxzY3JlZW4oKSB3aXRoIGEgbG93ZXJjYXNlIFwic1wiKScpO1xuICAgIHJldHVybiB0aGlzLmlzRnVsbHNjcmVlbihpc0ZTKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgdmlkZW8gdG8gZnVsbCBzY3JlZW5cbiAgICpcbiAgICogICAgIG15UGxheWVyLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAqXG4gICAqIEluIHNvbWUgYnJvd3NlcnMsIGZ1bGwgc2NyZWVuIGlzIG5vdCBzdXBwb3J0ZWQgbmF0aXZlbHksIHNvIGl0IGVudGVyc1xuICAgKiBcImZ1bGwgd2luZG93IG1vZGVcIiwgd2hlcmUgdGhlIHZpZGVvIGZpbGxzIHRoZSBicm93c2VyIHdpbmRvdy5cbiAgICogSW4gYnJvd3NlcnMgYW5kIGRldmljZXMgdGhhdCBzdXBwb3J0IG5hdGl2ZSBmdWxsIHNjcmVlbiwgc29tZXRpbWVzIHRoZVxuICAgKiBicm93c2VyJ3MgZGVmYXVsdCBjb250cm9scyB3aWxsIGJlIHNob3duLCBhbmQgbm90IHRoZSBWaWRlby5qcyBjdXN0b20gc2tpbi5cbiAgICogVGhpcyBpbmNsdWRlcyBtb3N0IG1vYmlsZSBkZXZpY2VzIChpT1MsIEFuZHJvaWQpIGFuZCBvbGRlciB2ZXJzaW9ucyBvZlxuICAgKiBTYWZhcmkuXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn0gc2VsZlxuICAgKi9cbiAgcmVxdWVzdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKHRydWUpO1xuXG4gICAgaWYgKGZzQXBpKSB7XG4gICAgICAvLyB0aGUgYnJvd3NlciBzdXBwb3J0cyBnb2luZyBmdWxsc2NyZWVuIGF0IHRoZSBlbGVtZW50IGxldmVsIHNvIHdlIGNhblxuICAgICAgLy8gdGFrZSB0aGUgY29udHJvbHMgZnVsbHNjcmVlbiBhcyB3ZWxsIGFzIHRoZSB2aWRlb1xuXG4gICAgICAvLyBUcmlnZ2VyIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgYWZ0ZXIgY2hhbmdlXG4gICAgICAvLyBXZSBoYXZlIHRvIHNwZWNpZmljYWxseSBhZGQgdGhpcyBlYWNoIHRpbWUsIGFuZCByZW1vdmVcbiAgICAgIC8vIHdoZW4gY2FuY2VsaW5nIGZ1bGxzY3JlZW4uIE90aGVyd2lzZSBpZiB0aGVyZSdzIG11bHRpcGxlXG4gICAgICAvLyBwbGF5ZXJzIG9uIGEgcGFnZSwgdGhleSB3b3VsZCBhbGwgYmUgcmVhY3RpbmcgdG8gdGhlIHNhbWUgZnVsbHNjcmVlblxuICAgICAgLy8gZXZlbnRzXG4gICAgICBFdmVudHMub24oZG9jdW1lbnQsIGZzQXBpWydmdWxsc2NyZWVuY2hhbmdlJ10sIEZuLmJpbmQodGhpcywgZnVuY3Rpb24gZG9jdW1lbnRGdWxsc2NyZWVuQ2hhbmdlKGUpe1xuICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbihkb2N1bWVudFtmc0FwaS5mdWxsc2NyZWVuRWxlbWVudF0pO1xuXG4gICAgICAgIC8vIElmIGNhbmNlbGxpbmcgZnVsbHNjcmVlbiwgcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBFdmVudHMub2ZmKGRvY3VtZW50LCBmc0FwaVsnZnVsbHNjcmVlbmNoYW5nZSddLCBkb2N1bWVudEZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgICB9KSk7XG5cbiAgICAgIHRoaXMuZWxfW2ZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuXSgpO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLnRlY2guc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcbiAgICAgIC8vIHdlIGNhbid0IHRha2UgdGhlIHZpZGVvLmpzIGNvbnRyb2xzIGZ1bGxzY3JlZW4gYnV0IHdlIGNhbiBnbyBmdWxsc2NyZWVuXG4gICAgICAvLyB3aXRoIG5hdGl2ZSBjb250cm9sc1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnZW50ZXJGdWxsU2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZ1bGxzY3JlZW4gaXNuJ3Qgc3VwcG9ydGVkIHNvIHdlJ2xsIGp1c3Qgc3RyZXRjaCB0aGUgdmlkZW8gZWxlbWVudCB0b1xuICAgICAgLy8gZmlsbCB0aGUgdmlld3BvcnRcbiAgICAgIHRoaXMuZW50ZXJGdWxsV2luZG93KCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbGQgbmFtaW5nIGZvciByZXF1ZXN0RnVsbHNjcmVlblxuICAgKiBAZGVwcmVjYXRlZCBmb3IgbG93ZXIgY2FzZSAncycgdmVyc2lvblxuICAgKi9cbiAgcmVxdWVzdEZ1bGxTY3JlZW4oKSB7XG4gICAgbG9nLndhcm4oJ3BsYXllci5yZXF1ZXN0RnVsbFNjcmVlbigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBwbGF5ZXIucmVxdWVzdEZ1bGxzY3JlZW4oKSB3aXRoIGEgbG93ZXJjYXNlIFwic1wiKScpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgKlxuICAgKiAgICAgbXlQbGF5ZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmXG4gICAqL1xuICBleGl0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZnNBcGkgPSBGdWxsc2NyZWVuQXBpO1xuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIGZvciBicm93c2VyIGVsZW1lbnQgZnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgaWYgKGZzQXBpKSB7XG4gICAgICBkb2N1bWVudFtmc0FwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaC5zdXBwb3J0c0Z1bGxTY3JlZW4oKSkge1xuICAgICB0aGlzLnRlY2hDYWxsKCdleGl0RnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgIHRoaXMuZXhpdEZ1bGxXaW5kb3coKTtcbiAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogT2xkIG5hbWluZyBmb3IgZXhpdEZ1bGxzY3JlZW5cbiAgICogQGRlcHJlY2F0ZWQgZm9yIGV4aXRGdWxsc2NyZWVuXG4gICAqL1xuICBjYW5jZWxGdWxsU2NyZWVuKCkge1xuICAgIGxvZy53YXJuKCdwbGF5ZXIuY2FuY2VsRnVsbFNjcmVlbigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBwbGF5ZXIuZXhpdEZ1bGxzY3JlZW4oKScpO1xuICAgIHJldHVybiB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gIH1cblxuICAvLyBXaGVuIGZ1bGxzY3JlZW4gaXNuJ3Qgc3VwcG9ydGVkIHdlIGNhbiBzdHJldGNoIHRoZSB2aWRlbyBjb250YWluZXIgdG8gYXMgd2lkZSBhcyB0aGUgYnJvd3NlciB3aWxsIGxldCB1cy5cbiAgZW50ZXJGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gdHJ1ZTtcblxuICAgIC8vIFN0b3Jpbmcgb3JpZ2luYWwgZG9jIG92ZXJmbG93IHZhbHVlIHRvIHJldHVybiB0byB3aGVuIGZ1bGxzY3JlZW4gaXMgb2ZmXG4gICAgdGhpcy5kb2NPcmlnT3ZlcmZsb3cgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cbiAgICAvLyBBZGQgbGlzdGVuZXIgZm9yIGVzYyBrZXkgdG8gZXhpdCBmdWxsc2NyZWVuXG4gICAgRXZlbnRzLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIEZuLmJpbmQodGhpcywgdGhpcy5mdWxsV2luZG93T25Fc2NLZXkpKTtcblxuICAgIC8vIEhpZGUgYW55IHNjcm9sbCBiYXJzXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAvLyBBcHBseSBmdWxsc2NyZWVuIHN0eWxlc1xuICAgIERvbS5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAndmpzLWZ1bGwtd2luZG93Jyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2VudGVyRnVsbFdpbmRvdycpO1xuICB9XG5cbiAgZnVsbFdpbmRvd09uRXNjS2V5KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXhpdEZ1bGxXaW5kb3coKSB7XG4gICAgdGhpcy5pc0Z1bGxXaW5kb3cgPSBmYWxzZTtcbiAgICBFdmVudHMub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KTtcblxuICAgIC8vIFVuaGlkZSBzY3JvbGwgYmFycy5cbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLmRvY09yaWdPdmVyZmxvdztcblxuICAgIC8vIFJlbW92ZSBmdWxsc2NyZWVuIHN0eWxlc1xuICAgIERvbS5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAndmpzLWZ1bGwtd2luZG93Jyk7XG5cbiAgICAvLyBSZXNpemUgdGhlIGJveCwgY29udHJvbGxlciwgYW5kIHBvc3RlciB0byBvcmlnaW5hbCBzaXplc1xuICAgIC8vIHRoaXMucG9zaXRpb25BbGwoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2V4aXRGdWxsV2luZG93Jyk7XG4gIH1cblxuICBzZWxlY3RTb3VyY2Uoc291cmNlcykge1xuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdGhlIG9wdGlvbnMgb3JkZXJcbiAgICBmb3IgKHZhciBpPTAsaj10aGlzLm9wdGlvbnNfWyd0ZWNoT3JkZXInXTtpPGoubGVuZ3RoO2krKykge1xuICAgICAgbGV0IHRlY2hOYW1lID0gdG9UaXRsZUNhc2UoaltpXSk7XG4gICAgICBsZXQgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICghdGVjaCkge1xuICAgICAgICBsb2cuZXJyb3IoYFRoZSBcIiR7dGVjaE5hbWV9XCIgdGVjaCBpcyB1bmRlZmluZWQuIFNraXBwZWQgYnJvd3NlciBzdXBwb3J0IGNoZWNrIGZvciB0aGF0IHRlY2guYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgIGlmICh0ZWNoLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggc291cmNlIG9iamVjdFxuICAgICAgICBmb3IgKHZhciBhPTAsYj1zb3VyY2VzO2E8Yi5sZW5ndGg7YSsrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGJbYV07XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBzb3VyY2UgY2FuIGJlIHBsYXllZCB3aXRoIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICAgIGlmICh0ZWNoWydjYW5QbGF5U291cmNlJ10oc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlOiBzb3VyY2UsIHRlY2g6IHRlY2hOYW1lIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgZnVuY3Rpb24gdXBkYXRlcyB0aGUgdmlkZW8gc291cmNlXG4gICAqXG4gICAqIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiB2YXJpYWJsZXMgeW91IGNhbiBwYXNzIGFzIHRoZSBhcmd1bWVudC5cbiAgICpcbiAgICogKipVUkwgU3RyaW5nKio6IEEgVVJMIHRvIHRoZSB0aGUgdmlkZW8gZmlsZS4gVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSBhcmUgc3VyZVxuICAgKiB0aGUgY3VycmVudCBwbGF5YmFjayB0ZWNobm9sb2d5IChIVE1MNS9GbGFzaCkgY2FuIHN1cHBvcnQgdGhlIHNvdXJjZSB5b3VcbiAgICogcHJvdmlkZS4gQ3VycmVudGx5IG9ubHkgTVA0IGZpbGVzIGNhbiBiZSB1c2VkIGluIGJvdGggSFRNTDUgYW5kIEZsYXNoLlxuICAgKlxuICAgKiAgICAgbXlQbGF5ZXIuc3JjKFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiKTtcbiAgICpcbiAgICogKipTb3VyY2UgT2JqZWN0IChvciBlbGVtZW50KToqKiBBIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb25cbiAgICogYWJvdXQgdGhlIHNvdXJjZSBmaWxlLiBVc2UgdGhpcyBtZXRob2QgaWYgeW91IHdhbnQgdGhlIHBsYXllciB0byBkZXRlcm1pbmUgaWZcbiAgICogaXQgY2FuIHN1cHBvcnQgdGhlIGZpbGUgdXNpbmcgdGhlIHR5cGUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqICAgICBteVBsYXllci5zcmMoeyB0eXBlOiBcInZpZGVvL21wNFwiLCBzcmM6IFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiIH0pO1xuICAgKlxuICAgKiAqKkFycmF5IG9mIFNvdXJjZSBPYmplY3RzOioqIFRvIHByb3ZpZGUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgdGhlIHNvdXJjZSBzb1xuICAgKiB0aGF0IGl0IGNhbiBiZSBwbGF5ZWQgdXNpbmcgSFRNTDUgYWNyb3NzIGJyb3dzZXJzIHlvdSBjYW4gdXNlIGFuIGFycmF5IG9mXG4gICAqIHNvdXJjZSBvYmplY3RzLiBWaWRlby5qcyB3aWxsIGRldGVjdCB3aGljaCB2ZXJzaW9uIGlzIHN1cHBvcnRlZCBhbmQgbG9hZCB0aGF0XG4gICAqIGZpbGUuXG4gICAqXG4gICAqICAgICBteVBsYXllci5zcmMoW1xuICAgKiAgICAgICB7IHR5cGU6IFwidmlkZW8vbXA0XCIsIHNyYzogXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIgfSxcbiAgICogICAgICAgeyB0eXBlOiBcInZpZGVvL3dlYm1cIiwgc3JjOiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vcGF0aC90by92aWRlby53ZWJtXCIgfSxcbiAgICogICAgICAgeyB0eXBlOiBcInZpZGVvL29nZ1wiLCBzcmM6IFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm9ndlwiIH1cbiAgICogICAgIF0pO1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fEFycmF5PX0gc291cmNlIFRoZSBzb3VyY2UgVVJMLCBvYmplY3QsIG9yIGFycmF5IG9mIHNvdXJjZXNcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY3VycmVudCB2aWRlbyBzb3VyY2Ugd2hlbiBnZXR0aW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICovXG4gIHNyYyhzb3VyY2U9dGhpcy50ZWNoR2V0KCdzcmMnKSkge1xuICAgIGxldCBjdXJyZW50VGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGhpcy50ZWNoTmFtZSk7XG5cbiAgICAvLyBjYXNlOiBBcnJheSBvZiBzb3VyY2Ugb2JqZWN0cyB0byBjaG9vc2UgZnJvbSBhbmQgcGljayB0aGUgYmVzdCB0byBwbGF5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgdGhpcy5zb3VyY2VMaXN0Xyhzb3VyY2UpO1xuXG4gICAgLy8gY2FzZTogVVJMIFN0cmluZyAoaHR0cDovL215dmlkZW8uLi4pXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gY3JlYXRlIGEgc291cmNlIG9iamVjdCBmcm9tIHRoZSBzdHJpbmdcbiAgICAgIHRoaXMuc3JjKHsgc3JjOiBzb3VyY2UgfSk7XG5cbiAgICAvLyBjYXNlOiBTb3VyY2Ugb2JqZWN0IHsgc3JjOiAnJywgdHlwZTogJycgLi4uIH1cbiAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHNvdXJjZSBoYXMgYSB0eXBlIGFuZCB0aGUgbG9hZGVkIHRlY2ggY2Fubm90IHBsYXkgdGhlIHNvdXJjZVxuICAgICAgLy8gaWYgdGhlcmUncyBubyB0eXBlIHdlJ2xsIGp1c3QgdHJ5IHRoZSBjdXJyZW50IHRlY2hcbiAgICAgIGlmIChzb3VyY2UudHlwZSAmJiAhY3VycmVudFRlY2hbJ2NhblBsYXlTb3VyY2UnXShzb3VyY2UpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHNvdXJjZSBsaXN0IHdpdGggdGhlIGN1cnJlbnQgc291cmNlIGFuZCBzZW5kIHRocm91Z2hcbiAgICAgICAgLy8gdGhlIHRlY2ggbG9vcCB0byBjaGVjayBmb3IgYSBjb21wYXRpYmxlIHRlY2hub2xvZ3lcbiAgICAgICAgdGhpcy5zb3VyY2VMaXN0Xyhbc291cmNlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlXy5zcmMgPSBzb3VyY2Uuc3JjO1xuICAgICAgICB0aGlzLmN1cnJlbnRUeXBlXyA9IHNvdXJjZS50eXBlIHx8ICcnO1xuXG4gICAgICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcbiAgICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbigpe1xuXG4gICAgICAgICAgLy8gVGhlIHNldFNvdXJjZSB0ZWNoIG1ldGhvZCB3YXMgYWRkZWQgd2l0aCBzb3VyY2UgaGFuZGxlcnNcbiAgICAgICAgICAvLyBzbyBvbGRlciB0ZWNocyB3b24ndCBzdXBwb3J0IGl0XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0aGUgZGlyZWN0IHByb3RvdHlwZSBmb3IgdGhlIGNhc2Ugd2hlcmUgc3ViY2xhc3Nlc1xuICAgICAgICAgIC8vIG9mIHRoZSB0ZWNoIGRvIG5vdCBzdXBwb3J0IHNvdXJjZSBoYW5kbGVyc1xuICAgICAgICAgIGlmIChjdXJyZW50VGVjaC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NldFNvdXJjZScpKSB7XG4gICAgICAgICAgICB0aGlzLnRlY2hDYWxsKCdzZXRTb3VyY2UnLCBzb3VyY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRlY2hDYWxsKCdzcmMnLCBzb3VyY2Uuc3JjKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zX1sncHJlbG9hZCddID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfWydhdXRvcGxheSddKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0c1xuICAgKiBAcGFyYW0gIHtbdHlwZV19IHNvdXJjZXMgQXJyYXkgb2Ygc291cmNlIG9iamVjdHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNvdXJjZUxpc3RfKHNvdXJjZXMpIHtcbiAgICB2YXIgc291cmNlVGVjaCA9IHRoaXMuc2VsZWN0U291cmNlKHNvdXJjZXMpO1xuXG4gICAgaWYgKHNvdXJjZVRlY2gpIHtcbiAgICAgIGlmIChzb3VyY2VUZWNoLnRlY2ggPT09IHRoaXMudGVjaE5hbWUpIHtcbiAgICAgICAgLy8gaWYgdGhpcyB0ZWNobm9sb2d5IGlzIGFscmVhZHkgbG9hZGVkLCBzZXQgdGhlIHNvdXJjZVxuICAgICAgICB0aGlzLnNyYyhzb3VyY2VUZWNoLnNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2FkIHRoaXMgdGVjaG5vbG9neSB3aXRoIHRoZSBjaG9zZW4gc291cmNlXG4gICAgICAgIHRoaXMubG9hZFRlY2goc291cmNlVGVjaC50ZWNoLCBzb3VyY2VUZWNoLnNvdXJjZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIGEgdGltZW91dCB0byBnaXZlIGZvbGtzIGEgY2hhbmNlIHRvIGFkZCBlcnJvciBldmVudCBoYW5kbGVyc1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lcnJvcih7IGNvZGU6IDQsIG1lc3NhZ2U6IHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zKClbJ25vdFN1cHBvcnRlZE1lc3NhZ2UnXSkgfSk7XG4gICAgICB9LCAwKTtcblxuICAgICAgLy8gd2UgY291bGQgbm90IGZpbmQgYW4gYXBwcm9wcmlhdGUgdGVjaCwgYnV0IGxldCdzIHN0aWxsIG5vdGlmeSB0aGUgZGVsZWdhdGUgdGhhdCB0aGlzIGlzIGl0XG4gICAgICAvLyB0aGlzIG5lZWRzIGEgYmV0dGVyIGNvbW1lbnQgYWJvdXQgd2h5IHRoaXMgaXMgbmVlZGVkXG4gICAgICB0aGlzLnRyaWdnZXJSZWFkeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCZWdpbiBsb2FkaW5nIHRoZSBzcmMgZGF0YS5cbiAgICogQHJldHVybiB7UGxheWVyfSBSZXR1cm5zIHRoZSBwbGF5ZXJcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgdGhpcy50ZWNoQ2FsbCgnbG9hZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgb2YgdGhlIGN1cnJlbnQgc291cmNlIHZhbHVlIGUuZy4gaHR0cDovL215c2l0ZS5jb20vdmlkZW8ubXA0XG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBgY3VycmVudFR5cGVgIHRvIGFzc2lzdCBpbiByZWJ1aWxkaW5nIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGN1cnJlbnQgc291cmNlXG4gICAqL1xuICBjdXJyZW50U3JjKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXQoJ2N1cnJlbnRTcmMnKSB8fCB0aGlzLmNhY2hlXy5zcmMgfHwgJyc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHNvdXJjZSB0eXBlIGUuZy4gdmlkZW8vbXA0XG4gICAqIFRoaXMgY2FuIGFsbG93IHlvdSByZWJ1aWxkIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgc28gdGhhdCB5b3UgY291bGQgbG9hZCB0aGUgc2FtZVxuICAgKiBzb3VyY2UgYW5kIHRlY2ggbGF0ZXJcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgc291cmNlIE1JTUUgdHlwZVxuICAgKi9cbiAgY3VycmVudFR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50VHlwZV8gfHwgJyc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgcHJlbG9hZCBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHByZWxvYWQgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IFJldHVybnMgdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICovXG4gIHByZWxvYWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0UHJlbG9hZCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc19bJ3ByZWxvYWQnXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXQoJ3ByZWxvYWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGF1dG9wbGF5IGF0dHJpYnV0ZSB2YWx1ZSB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBSZXR1cm5zIHRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqL1xuICBhdXRvcGxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsKCdzZXRBdXRvcGxheScsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc19bJ2F1dG9wbGF5J10gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdhdXRvcGxheScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb29wIGF0dHJpYnV0ZSBvbiB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgbG9vcCBhdHRyaWJ1dGUgdmFsdWUgd2hlbiBnZXR0aW5nXG4gICAqIEByZXR1cm4ge1BsYXllcn0gUmV0dXJucyB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgbG9vcCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsKCdzZXRMb29wJywgdmFsdWUpO1xuICAgICAgdGhpcy5vcHRpb25zX1snbG9vcCddID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgnbG9vcCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBvciBzZXQgdGhlIHBvc3RlciBpbWFnZSBzb3VyY2UgdXJsXG4gICAqXG4gICAqICMjIyMjIEVYQU1QTEU6XG4gICAqXG4gICAqICAgICAvLyBnZXR0aW5nXG4gICAqICAgICB2YXIgY3VycmVudFBvc3RlciA9IG15UGxheWVyLnBvc3RlcigpO1xuICAgKlxuICAgKiAgICAgLy8gc2V0dGluZ1xuICAgKiAgICAgbXlQbGF5ZXIucG9zdGVyKCdodHRwOi8vZXhhbXBsZS5jb20vbXlJbWFnZS5qcGcnKTtcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nPX0gW3NyY10gUG9zdGVyIGltYWdlIHNvdXJjZSBVUkxcbiAgICogQHJldHVybiB7U3RyaW5nfSBwb3N0ZXIgVVJMIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IHNlbGYgd2hlbiBzZXR0aW5nXG4gICAqL1xuICBwb3N0ZXIoc3JjKSB7XG4gICAgaWYgKHNyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3N0ZXJfO1xuICAgIH1cblxuICAgIC8vIFRoZSBjb3JyZWN0IHdheSB0byByZW1vdmUgYSBwb3N0ZXIgaXMgdG8gc2V0IGFzIGFuIGVtcHR5IHN0cmluZ1xuICAgIC8vIG90aGVyIGZhbHNleSB2YWx1ZXMgd2lsbCB0aHJvdyBlcnJvcnNcbiAgICBpZiAoIXNyYykge1xuICAgICAgc3JjID0gJyc7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBpbnRlcm5hbCBwb3N0ZXIgdmFyaWFibGVcbiAgICB0aGlzLnBvc3Rlcl8gPSBzcmM7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHRlY2gncyBwb3N0ZXJcbiAgICB0aGlzLnRlY2hDYWxsKCdzZXRQb3N0ZXInLCBzcmMpO1xuXG4gICAgLy8gYWxlcnQgY29tcG9uZW50cyB0aGF0IHRoZSBwb3N0ZXIgaGFzIGJlZW4gc2V0XG4gICAgdGhpcy50cmlnZ2VyKCdwb3N0ZXJjaGFuZ2UnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgd2hldGhlciBvciBub3QgdGhlIGNvbnRyb2xzIGFyZSBzaG93aW5nLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjb250cm9scyBTZXQgY29udHJvbHMgdG8gc2hvd2luZyBvciBub3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgQ29udHJvbHMgYXJlIHNob3dpbmdcbiAgICovXG4gIGNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib29sID0gISFib29sOyAvLyBmb3JjZSBib29sZWFuXG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy5jb250cm9sc18gIT09IGJvb2wpIHtcbiAgICAgICAgdGhpcy5jb250cm9sc18gPSBib29sO1xuXG4gICAgICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICAgIHRoaXMudGVjaENhbGwoJ3NldENvbnRyb2xzJywgYm9vbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjb250cm9sc2VuYWJsZWQnKTtcblxuICAgICAgICAgIGlmICghdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjb250cm9sc2Rpc2FibGVkJyk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuY29udHJvbHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBuYXRpdmUgY29udHJvbHMgb24vb2ZmLiBOYXRpdmUgY29udHJvbHMgYXJlIHRoZSBjb250cm9scyBidWlsdCBpbnRvXG4gICAqIGRldmljZXMgKGUuZy4gZGVmYXVsdCBpUGhvbmUgY29udHJvbHMpLCBGbGFzaCwgb3Igb3RoZXIgdGVjaHNcbiAgICogKGUuZy4gVmltZW8gQ29udHJvbHMpXG4gICAqXG4gICAqICoqVGhpcyBzaG91bGQgb25seSBiZSBzZXQgYnkgdGhlIGN1cnJlbnQgdGVjaCwgYmVjYXVzZSBvbmx5IHRoZSB0ZWNoIGtub3dzXG4gICAqIGlmIGl0IGNhbiBzdXBwb3J0IG5hdGl2ZSBjb250cm9scyoqXG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGJvb2wgICAgVHJ1ZSBzaWduYWxzIHRoYXQgbmF0aXZlIGNvbnRyb2xzIGFyZSBvblxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgUmV0dXJucyB0aGUgcGxheWVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1c2luZ05hdGl2ZUNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib29sID0gISFib29sOyAvLyBmb3JjZSBib29sZWFuXG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyAhPT0gYm9vbCkge1xuICAgICAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfID0gYm9vbDtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNpbmctbmF0aXZlLWNvbnRyb2xzJyk7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBwbGF5ZXIgaXMgdXNpbmcgdGhlIG5hdGl2ZSBkZXZpY2UgY29udHJvbHNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBldmVudCB1c2luZ25hdGl2ZWNvbnRyb2xzXG4gICAgICAgICAgICogQG1lbWJlcm9mIFBsYXllclxuICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ25hdGl2ZWNvbnRyb2xzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBjdXN0b20gSFRNTCBjb250cm9sc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV2ZW50IHVzaW5nY3VzdG9tY29udHJvbHNcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgUGxheWVyXG4gICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VzaW5nY3VzdG9tY29udHJvbHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMudXNpbmdOYXRpdmVDb250cm9sc187XG4gIH1cblxuICAvKipcbiAgICogU2V0IG9yIGdldCB0aGUgY3VycmVudCBNZWRpYUVycm9yXG4gICAqIEBwYXJhbSAgeyp9IGVyciBBIE1lZGlhRXJyb3Igb3IgYSBTdHJpbmcvTnVtYmVyIHRvIGJlIHR1cm5lZCBpbnRvIGEgTWVkaWFFcnJvclxuICAgKiBAcmV0dXJuIHtNZWRpYUVycm9yfG51bGx9ICAgICB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgICAgICAgICAgd2hlbiBzZXR0aW5nXG4gICAqL1xuICBlcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVycm9yXyB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmluZyB0byBkZWZhdWx0XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5lcnJvcl8gPSBlcnI7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZXJyb3InKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVycm9yIGluc3RhbmNlXG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIE1lZGlhRXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG4gICAgfVxuXG4gICAgLy8gZmlyZSBhbiBlcnJvciBldmVudCBvbiB0aGUgcGxheWVyXG4gICAgdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuXG4gICAgLy8gYWRkIHRoZSB2anMtZXJyb3IgY2xhc3NuYW1lIHRvIHRoZSBwbGF5ZXJcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZXJyb3InKTtcblxuICAgIC8vIGxvZyB0aGUgbmFtZSBvZiB0aGUgZXJyb3IgdHlwZSBhbmQgYW55IG1lc3NhZ2VcbiAgICAvLyBpZTgganVzdCBsb2dzIFwiW29iamVjdCBvYmplY3RdXCIgaWYgeW91IGp1c3QgbG9nIHRoZSBlcnJvciBvYmplY3RcbiAgICBsb2cuZXJyb3IoYChDT0RFOiR7dGhpcy5lcnJvcl8uY29kZX0gJHtNZWRpYUVycm9yLmVycm9yVHlwZXNbdGhpcy5lcnJvcl8uY29kZV19KWAsIHRoaXMuZXJyb3JfLm1lc3NhZ2UsIHRoaXMuZXJyb3JfKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsYXllciBpcyBpbiB0aGUgXCJlbmRlZFwiIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIGVuZGVkIHN0YXRlLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBlbmRlZCgpIHsgcmV0dXJuIHRoaXMudGVjaEdldCgnZW5kZWQnKTsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwic2Vla2luZ1wiIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIHNlZWtpbmcgc3RhdGUsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIHNlZWtpbmcoKSB7IHJldHVybiB0aGlzLnRlY2hHZXQoJ3NlZWtpbmcnKTsgfVxuXG4gIHJlcG9ydFVzZXJBY3Rpdml0eShldmVudCkge1xuICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IHRydWU7XG4gIH1cblxuICB1c2VyQWN0aXZlKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib29sID0gISFib29sO1xuICAgICAgaWYgKGJvb2wgIT09IHRoaXMudXNlckFjdGl2ZV8pIHtcbiAgICAgICAgdGhpcy51c2VyQWN0aXZlXyA9IGJvb2w7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHVzZXIgd2FzIGluYWN0aXZlIGFuZCBpcyBub3cgYWN0aXZlIHdlIHdhbnQgdG8gcmVzZXQgdGhlXG4gICAgICAgICAgLy8gaW5hY3Rpdml0eSB0aW1lclxuICAgICAgICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzZXItaW5hY3RpdmUnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNlci1hY3RpdmUnKTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VzZXJhY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSdyZSBzd2l0Y2hpbmcgdGhlIHN0YXRlIHRvIGluYWN0aXZlIG1hbnVhbGx5LCBzbyBlcmFzZSBhbnkgb3RoZXJcbiAgICAgICAgICAvLyBhY3Rpdml0eVxuICAgICAgICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gQ2hyb21lL1NhZmFyaS9JRSBoYXZlIGJ1Z3Mgd2hlcmUgd2hlbiB5b3UgY2hhbmdlIHRoZSBjdXJzb3IgaXQgY2FuXG4gICAgICAgICAgLy8gdHJpZ2dlciBhIG1vdXNlbW92ZSBldmVudC4gVGhpcyBjYXVzZXMgYW4gaXNzdWUgd2hlbiB5b3UncmUgaGlkaW5nXG4gICAgICAgICAgLy8gdGhlIGN1cnNvciB3aGVuIHRoZSB1c2VyIGlzIGluYWN0aXZlLCBhbmQgYSBtb3VzZW1vdmUgc2lnbmFscyB1c2VyXG4gICAgICAgICAgLy8gYWN0aXZpdHkuIE1ha2luZyBpdCBpbXBvc3NpYmxlIHRvIGdvIGludG8gaW5hY3RpdmUgbW9kZS4gU3BlY2lmaWNhbGx5XG4gICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGluIGZ1bGxzY3JlZW4gd2hlbiB3ZSByZWFsbHkgbmVlZCB0byBoaWRlIHRoZSBjdXJzb3IuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBXaGVuIHRoaXMgZ2V0cyByZXNvbHZlZCBpbiBBTEwgYnJvd3NlcnMgaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAzMDQxXG4gICAgICAgICAgaWYodGhpcy50ZWNoKSB7XG4gICAgICAgICAgICB0aGlzLnRlY2gub25lKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItaW5hY3RpdmUnKTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VzZXJpbmFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudXNlckFjdGl2ZV87XG4gIH1cblxuICBsaXN0ZW5Gb3JVc2VyQWN0aXZpdHkoKSB7XG4gICAgbGV0IG1vdXNlSW5Qcm9ncmVzcywgbGFzdE1vdmVYLCBsYXN0TW92ZVk7XG5cbiAgICBsZXQgaGFuZGxlQWN0aXZpdHkgPSBGbi5iaW5kKHRoaXMsIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KTtcblxuICAgIGxldCBoYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAvLyAjMTA2OCAtIFByZXZlbnQgbW91c2Vtb3ZlIHNwYW1taW5nXG4gICAgICAvLyBDaHJvbWUgQnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzY2OTcwXG4gICAgICBpZihlLnNjcmVlblggIT09IGxhc3RNb3ZlWCB8fCBlLnNjcmVlblkgIT09IGxhc3RNb3ZlWSkge1xuICAgICAgICBsYXN0TW92ZVggPSBlLnNjcmVlblg7XG4gICAgICAgIGxhc3RNb3ZlWSA9IGUuc2NyZWVuWTtcbiAgICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIC8vIEZvciBhcyBsb25nIGFzIHRoZSB0aGV5IGFyZSB0b3VjaGluZyB0aGUgZGV2aWNlIG9yIGhhdmUgdGhlaXIgbW91c2UgZG93bixcbiAgICAgIC8vIHdlIGNvbnNpZGVyIHRoZW0gYWN0aXZlIGV2ZW4gaWYgdGhleSdyZSBub3QgbW92aW5nIHRoZWlyIGZpbmdlciBvciBtb3VzZS5cbiAgICAgIC8vIFNvIHdlIHdhbnQgdG8gY29udGludWUgdG8gdXBkYXRlIHRoYXQgdGhleSBhcmUgYWN0aXZlXG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwobW91c2VJblByb2dyZXNzKTtcbiAgICAgIC8vIFNldHRpbmcgdXNlckFjdGl2aXR5PXRydWUgbm93IGFuZCBzZXR0aW5nIHRoZSBpbnRlcnZhbCB0byB0aGUgc2FtZSB0aW1lXG4gICAgICAvLyBhcyB0aGUgYWN0aXZpdHlDaGVjayBpbnRlcnZhbCAoMjUwKSBzaG91bGQgZW5zdXJlIHdlIG5ldmVyIG1pc3MgdGhlXG4gICAgICAvLyBuZXh0IGFjdGl2aXR5Q2hlY2tcbiAgICAgIG1vdXNlSW5Qcm9ncmVzcyA9IHRoaXMuc2V0SW50ZXJ2YWwoaGFuZGxlQWN0aXZpdHksIDI1MCk7XG4gICAgfTtcblxuICAgIGxldCBoYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBTdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgbW91c2UvdG91Y2ggaXMgZG93blxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgfTtcblxuICAgIC8vIEFueSBtb3VzZSBtb3ZlbWVudCB3aWxsIGJlIGNvbnNpZGVyZWQgdXNlciBhY3Rpdml0eVxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAvLyBTaG91bGRuJ3QgbmVlZCB0byB1c2UgaW5Qcm9ncmVzcyBpbnRlcnZhbCBiZWNhdXNlIG9mIGtleSByZXBlYXRcbiAgICB0aGlzLm9uKCdrZXlkb3duJywgaGFuZGxlQWN0aXZpdHkpO1xuICAgIHRoaXMub24oJ2tleXVwJywgaGFuZGxlQWN0aXZpdHkpO1xuXG4gICAgLy8gUnVuIGFuIGludGVydmFsIGV2ZXJ5IDI1MCBtaWxsaXNlY29uZHMgaW5zdGVhZCBvZiBzdHVmZmluZyBldmVyeXRoaW5nIGludG9cbiAgICAvLyB0aGUgbW91c2Vtb3ZlL3RvdWNobW92ZSBmdW5jdGlvbiBpdHNlbGYsIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gICAgLy8gYHRoaXMucmVwb3J0VXNlckFjdGl2aXR5YCBzaW1wbHkgc2V0cyB0aGlzLnVzZXJBY3Rpdml0eV8gdG8gdHJ1ZSwgd2hpY2hcbiAgICAvLyB0aGVuIGdldHMgcGlja2VkIHVwIGJ5IHRoaXMgbG9vcFxuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9sZWFybmluZy1mcm9tLXR3aXR0ZXIvXG4gICAgbGV0IGFjdGl2aXR5Q2hlY2sgPSB0aGlzLnNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGluYWN0aXZpdHlUaW1lb3V0O1xuXG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgbW91c2UvdG91Y2ggYWN0aXZpdHkgaGFzIGhhcHBlbmVkXG4gICAgICBpZiAodGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBhY3Rpdml0eSB0cmFja2VyXG4gICAgICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHN0YXRlIHdhcyBpbmFjdGl2ZSwgc2V0IHRoZSBzdGF0ZSB0byBhY3RpdmVcbiAgICAgICAgdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuXG4gICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBpbmFjdGl2aXR5IHRpbWVvdXQgdG8gc3RhcnQgdGhlIHRpbWVyIG92ZXJcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoaW5hY3Rpdml0eVRpbWVvdXQpO1xuXG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5vcHRpb25zKClbJ2luYWN0aXZpdHlUaW1lb3V0J107XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgIC8vIEluIDx0aW1lb3V0PiBtaWxsaXNlY29uZHMsIGlmIG5vIG1vcmUgYWN0aXZpdHkgaGFzIG9jY3VycmVkIHRoZVxuICAgICAgICAgIC8vIHVzZXIgd2lsbCBiZSBjb25zaWRlcmVkIGluYWN0aXZlXG4gICAgICAgICAgaW5hY3Rpdml0eVRpbWVvdXQgPSB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIHRoZSBpbmFjdGl2aXR5VGltZW91dCBjYW4gdHJpZ2dlciBqdXN0XG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIG5leHQgdXNlciBhY3Rpdml0eSBpcyBwaWNrZWQgdXAgYnkgdGhlIGFjdGl2aXR5Q2hlY2sgbG9vcFxuICAgICAgICAgICAgLy8gY2F1c2luZyBhIGZsaWNrZXJcbiAgICAgICAgICAgIGlmICghdGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDI1MCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUuICBBIHBsYXliYWNrIHJhdGUgb2ZcbiAgICogMS4wIHJlcHJlc2VudHMgbm9ybWFsIHNwZWVkIGFuZCAwLjUgd291bGQgaW5kaWNhdGUgaGFsZi1zcGVlZFxuICAgKiBwbGF5YmFjaywgZm9yIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHJhdGUgICAgTmV3IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgUmV0dXJucyB0aGUgbmV3IHBsYXliYWNrIHJhdGUgd2hlbiBzZXR0aW5nXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUgd2hlbiBnZXR0aW5nXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGVcbiAgICovXG4gIHBsYXliYWNrUmF0ZShyYXRlKSB7XG4gICAgaWYgKHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0UGxheWJhY2tSYXRlJywgcmF0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZWNoICYmIHRoaXMudGVjaFsnZmVhdHVyZXNQbGF5YmFja1JhdGUnXSkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldCgncGxheWJhY2tSYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxLjA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgYXVkaW8gZmxhZ1xuICAgKlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBib29sICAgIFRydWUgc2lnbmFscyB0aGF0IHRoaXMgaXMgYW4gYXVkaW8gcGxheWVyLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIFJldHVybnMgdHJ1ZSBpZiBwbGF5ZXIgaXMgYXVkaW8sIGZhbHNlIGlmIG5vdCB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgIFJldHVybnMgdGhlIHBsYXllciBpZiBzZXR0aW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0F1ZGlvKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmlzQXVkaW9fID0gISFib29sO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhdGhpcy5pc0F1ZGlvXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIG5ldHdvcmsgYWN0aXZpdHkgZm9yIHRoZSBlbGVtZW50LCBmcm9tXG4gICAqIHRoZSBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAgICogLSBORVRXT1JLX0VNUFRZIChudW1lcmljIHZhbHVlIDApXG4gICAqICAgVGhlIGVsZW1lbnQgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXNlZC4gQWxsIGF0dHJpYnV0ZXMgYXJlIGluXG4gICAqICAgdGhlaXIgaW5pdGlhbCBzdGF0ZXMuXG4gICAqIC0gTkVUV09SS19JRExFIChudW1lcmljIHZhbHVlIDEpXG4gICAqICAgVGhlIGVsZW1lbnQncyByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtIGlzIGFjdGl2ZSBhbmQgaGFzXG4gICAqICAgc2VsZWN0ZWQgYSByZXNvdXJjZSwgYnV0IGl0IGlzIG5vdCBhY3R1YWxseSB1c2luZyB0aGUgbmV0d29yayBhdFxuICAgKiAgIHRoaXMgdGltZS5cbiAgICogLSBORVRXT1JLX0xPQURJTkcgKG51bWVyaWMgdmFsdWUgMilcbiAgICogICBUaGUgdXNlciBhZ2VudCBpcyBhY3RpdmVseSB0cnlpbmcgdG8gZG93bmxvYWQgZGF0YS5cbiAgICogLSBORVRXT1JLX05PX1NPVVJDRSAobnVtZXJpYyB2YWx1ZSAzKVxuICAgKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUsIGJ1dCBpdCBoYXNcbiAgICogICBub3QgeWV0IGZvdW5kIGEgcmVzb3VyY2UgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjdXJyZW50IG5ldHdvcmsgYWN0aXZpdHkgc3RhdGVcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjbmV0d29yay1zdGF0ZXNcbiAgICovXG4gIG5ldHdvcmtTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCduZXR3b3JrU3RhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBleHByZXNzZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAgICogd2l0aCByZXNwZWN0IHRvIHJlbmRlcmluZyB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiwgZnJvbSB0aGVcbiAgICogY29kZXMgaW4gdGhlIGxpc3QgYmVsb3cuXG4gICAqIC0gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApXG4gICAqICAgTm8gaW5mb3JtYXRpb24gcmVnYXJkaW5nIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBhdmFpbGFibGUuXG4gICAqIC0gSEFWRV9NRVRBREFUQSAobnVtZXJpYyB2YWx1ZSAxKVxuICAgKiAgIEVub3VnaCBvZiB0aGUgcmVzb3VyY2UgaGFzIGJlZW4gb2J0YWluZWQgdGhhdCB0aGUgZHVyYXRpb24gb2YgdGhlXG4gICAqICAgcmVzb3VyY2UgaXMgYXZhaWxhYmxlLlxuICAgKiAtIEhBVkVfQ1VSUkVOVF9EQVRBIChudW1lcmljIHZhbHVlIDIpXG4gICAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZS5cbiAgICogLSBIQVZFX0ZVVFVSRV9EQVRBIChudW1lcmljIHZhbHVlIDMpXG4gICAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZSwgYXNcbiAgICogICB3ZWxsIGFzIGVub3VnaCBkYXRhIGZvciB0aGUgdXNlciBhZ2VudCB0byBhZHZhbmNlIHRoZSBjdXJyZW50XG4gICAqICAgcGxheWJhY2sgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBvZiBwbGF5YmFjay5cbiAgICogLSBIQVZFX0VOT1VHSF9EQVRBIChudW1lcmljIHZhbHVlIDQpXG4gICAqICAgVGhlIHVzZXIgYWdlbnQgZXN0aW1hdGVzIHRoYXQgZW5vdWdoIGRhdGEgaXMgYXZhaWxhYmxlIGZvclxuICAgKiAgIHBsYXliYWNrIHRvIHByb2NlZWQgdW5pbnRlcnJ1cHRlZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgY3VycmVudCBwbGF5YmFjayByZW5kZXJpbmcgc3RhdGVcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXJlYWR5c3RhdGVcbiAgICovXG4gIHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgncmVhZHlTdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRleHQgdHJhY2tzIGFyZSB0cmFja3Mgb2YgdGltZWQgdGV4dCBldmVudHMuXG4gICAqIENhcHRpb25zIC0gdGV4dCBkaXNwbGF5ZWQgb3ZlciB0aGUgdmlkZW8gZm9yIHRoZSBoZWFyaW5nIGltcGFpcmVkXG4gICAqIFN1YnRpdGxlcyAtIHRleHQgZGlzcGxheWVkIG92ZXIgdGhlIHZpZGVvIGZvciB0aG9zZSB3aG8gZG9uJ3QgdW5kZXJzdGFuZCBsYW5ndWFnZSBpbiB0aGUgdmlkZW9cbiAgICogQ2hhcHRlcnMgLSB0ZXh0IGRpc3BsYXllZCBpbiBhIG1lbnUgYWxsb3dpbmcgdGhlIHVzZXIgdG8ganVtcCB0byBwYXJ0aWN1bGFyIHBvaW50cyAoY2hhcHRlcnMpIGluIHRoZSB2aWRlb1xuICAgKiBEZXNjcmlwdGlvbnMgKG5vdCBzdXBwb3J0ZWQgeWV0KSAtIGF1ZGlvIGRlc2NyaXB0aW9ucyB0aGF0IGFyZSByZWFkIGJhY2sgdG8gdGhlIHVzZXIgYnkgYSBzY3JlZW4gcmVhZGluZyBkZXZpY2VcbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBhc3NvY2lhdGVkIHRleHQgdHJhY2tzLiBjYXB0aW9ucywgc3VidGl0bGVzLCBjaGFwdGVycywgZGVzY3JpcHRpb25zXG4gICAqIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS10ZXh0dHJhY2tzXG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgQXJyYXkgb2YgdHJhY2sgb2JqZWN0c1xuICAgKi9cbiAgdGV4dFRyYWNrcygpIHtcbiAgICAvLyBjYW5ub3QgdXNlIHRlY2hHZXQgZGlyZWN0bHkgYmVjYXVzZSBpdCBjaGVja3MgdG8gc2VlIHdoZXRoZXIgdGhlIHRlY2ggaXMgcmVhZHkuXG4gICAgLy8gRmxhc2ggaXMgdW5saWtlbHkgdG8gYmUgcmVhZHkgaW4gdGltZSBidXQgdGV4dFRyYWNrcyBzaG91bGQgc3RpbGwgd29yay5cbiAgICByZXR1cm4gdGhpcy50ZWNoICYmIHRoaXMudGVjaFsndGV4dFRyYWNrcyddKCk7XG4gIH1cblxuICByZW1vdGVUZXh0VHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2ggJiYgdGhpcy50ZWNoWydyZW1vdGVUZXh0VHJhY2tzJ10oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0ZXh0IHRyYWNrXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoZSBXM0Mgc2V0dGluZ3Mgd2UgYWxsb3cgYWRkaW5nIGFkZGl0aW9uYWwgaW5mbyB0aHJvdWdoIG9wdGlvbnMuXG4gICAqIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1hZGR0ZXh0dHJhY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9ICBraW5kICAgICAgICBDYXB0aW9ucywgc3VidGl0bGVzLCBjaGFwdGVycywgZGVzY3JpcHRpb25zLCBvciBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZz19IGxhYmVsICAgICAgIE9wdGlvbmFsIGxhYmVsXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbGFuZ3VhZ2UgICAgT3B0aW9uYWwgbGFuZ3VhZ2VcbiAgICovXG4gIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoICYmIHRoaXMudGVjaFsnYWRkVGV4dFRyYWNrJ10oa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfVxuXG4gIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaCAmJiB0aGlzLnRlY2hbJ2FkZFJlbW90ZVRleHRUcmFjayddKG9wdGlvbnMpO1xuICB9XG5cbiAgcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKSB7XG4gICAgdGhpcy50ZWNoICYmIHRoaXMudGVjaFsncmVtb3ZlUmVtb3RlVGV4dFRyYWNrJ10odHJhY2spO1xuICB9XG5cbiAgdmlkZW9XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoICYmIHRoaXMudGVjaC52aWRlb1dpZHRoICYmIHRoaXMudGVjaC52aWRlb1dpZHRoKCkgfHwgMDtcbiAgfVxuXG4gIHZpZGVvSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnRlY2ggJiYgdGhpcy50ZWNoLnZpZGVvSGVpZ2h0ICYmIHRoaXMudGVjaC52aWRlb0hlaWdodCgpIHx8IDA7XG4gIH1cblxuICAvLyBNZXRob2RzIHRvIGFkZCBzdXBwb3J0IGZvclxuICAvLyBpbml0aWFsVGltZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ2luaXRpYWxUaW1lJyk7IH0sXG4gIC8vIHN0YXJ0T2Zmc2V0VGltZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ3N0YXJ0T2Zmc2V0VGltZScpOyB9LFxuICAvLyBwbGF5ZWQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCdwbGF5ZWQnKTsgfSxcbiAgLy8gc2Vla2FibGU6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCdzZWVrYWJsZScpOyB9LFxuICAvLyB2aWRlb1RyYWNrczogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ3ZpZGVvVHJhY2tzJyk7IH0sXG4gIC8vIGF1ZGlvVHJhY2tzOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgnYXVkaW9UcmFja3MnKTsgfSxcbiAgLy8gZGVmYXVsdFBsYXliYWNrUmF0ZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ2RlZmF1bHRQbGF5YmFja1JhdGUnKTsgfSxcbiAgLy8gbWVkaWFHcm91cDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ21lZGlhR3JvdXAnKTsgfSxcbiAgLy8gY29udHJvbGxlcjogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ2NvbnRyb2xsZXInKTsgfSxcbiAgLy8gZGVmYXVsdE11dGVkOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgnZGVmYXVsdE11dGVkJyk7IH1cblxuICAvLyBUT0RPXG4gIC8vIGN1cnJlbnRTcmNMaXN0OiB0aGUgYXJyYXkgb2Ygc291cmNlcyBpbmNsdWRpbmcgb3RoZXIgZm9ybWF0cyBhbmQgYml0cmF0ZXNcbiAgLy8gcGxheUxpc3Q6IGFycmF5IG9mIHNvdXJjZSBsaXN0cyBpbiBvcmRlciBvZiBwbGF5YmFja1xuXG4gIC8qKlxuICAgKiBUaGUgcGxheWVyJ3MgbGFuZ3VhZ2UgY29kZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxhbmd1YWdlQ29kZSAgVGhlIGxvY2FsZSBzdHJpbmdcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICBUaGUgbG9jYWxlIHN0cmluZyB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgICAgIHNlbGYsIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgbGFuZ3VhZ2UobGFuZ3VhZ2VDb2RlKSB7XG4gICAgaWYgKGxhbmd1YWdlQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZV87XG4gICAgfVxuXG4gICAgdGhpcy5sYW5ndWFnZV8gPSBsYW5ndWFnZUNvZGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwbGF5ZXIncyBsYW5ndWFnZSBkaWN0aW9uYXJ5XG4gICAqL1xuICBsYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VzXztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMoKSk7XG4gICAgbGV0IHRyYWNrcyA9IG9wdGlvbnMudHJhY2tzO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIC8vIGRlZXAgbWVyZ2UgdHJhY2tzIGFuZCBudWxsIG91dCBwbGF5ZXIgc28gbm8gY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgdHJhY2sgPSBtZXJnZU9wdGlvbnModHJhY2spO1xuICAgICAgdHJhY2sucGxheWVyID0gdW5kZWZpbmVkO1xuICAgICAgb3B0aW9ucy50cmFja3NbaV0gPSB0cmFjaztcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIHN0YXRpYyBnZXRUYWdTZXR0aW5ncyh0YWcpIHtcbiAgICBsZXQgYmFzZU9wdGlvbnMgPSB7XG4gICAgICAnc291cmNlcyc6IFtdLFxuICAgICAgJ3RyYWNrcyc6IFtdXG4gICAgfTtcblxuICAgIGNvbnN0IHRhZ09wdGlvbnMgPSBEb20uZ2V0RWxlbWVudEF0dHJpYnV0ZXModGFnKTtcbiAgICBjb25zdCBkYXRhU2V0dXAgPSB0YWdPcHRpb25zWydkYXRhLXNldHVwJ107XG5cbiAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgIGlmIChkYXRhU2V0dXAgIT09IG51bGwpe1xuICAgICAgLy8gUGFyc2Ugb3B0aW9ucyBKU09OXG4gICAgICAvLyBJZiBlbXB0eSBzdHJpbmcsIG1ha2UgaXQgYSBwYXJzYWJsZSBqc29uIG9iamVjdC5cbiAgICAgIGNvbnN0IFtlcnIsIGRhdGFdID0gc2FmZVBhcnNlVHVwbGUoZGF0YVNldHVwIHx8ICd7fScpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbih0YWdPcHRpb25zLCBkYXRhKTtcbiAgICB9XG5cbiAgICBhc3NpZ24oYmFzZU9wdGlvbnMsIHRhZ09wdGlvbnMpO1xuXG4gICAgLy8gR2V0IHRhZyBjaGlsZHJlbiBzZXR0aW5nc1xuICAgIGlmICh0YWcuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRhZy5jaGlsZE5vZGVzO1xuXG4gICAgICBmb3IgKGxldCBpPTAsIGo9Y2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyBDaGFuZ2UgY2FzZSBuZWVkZWQ6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ub2RlbmFtZS1jYXNlLXNlbnNpdGl2aXR5L1xuICAgICAgICBjb25zdCBjaGlsZE5hbWUgPSBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnc291cmNlJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zWydzb3VyY2VzJ10ucHVzaChEb20uZ2V0RWxlbWVudEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZE5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBiYXNlT3B0aW9uc1sndHJhY2tzJ10ucHVzaChEb20uZ2V0RWxlbWVudEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3B0aW9ucztcbiAgfVxuXG59XG5cbi8qKlxuICogR2xvYmFsIHBsYXllciBsaXN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5QbGF5ZXIucGxheWVycyA9IHt9O1xuXG4vKipcbiAqIFBsYXllciBpbnN0YW5jZSBvcHRpb25zLCBzdXJmYWNlZCB1c2luZyBvcHRpb25zXG4gKiBvcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zX1xuICogTWFrZSBjaGFuZ2VzIGluIG9wdGlvbnMsIG5vdCBoZXJlLlxuICogQWxsIG9wdGlvbnMgc2hvdWxkIHVzZSBzdHJpbmcga2V5cyBzbyB0aGV5IGF2b2lkXG4gKiByZW5hbWluZyBieSBjbG9zdXJlIGNvbXBpbGVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXyA9IE9wdGlvbnM7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBpbml0aWFsIGR1cmF0aW9uIGFuZCBkaW1lbnNpb24gaW5mb3JtYXRpb25cbiAqIEBldmVudCBsb2FkZWRtZXRhZGF0YVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZUxvYWRlZE1ldGFEYXRhO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZG93bmxvYWRlZCBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gKiBAZXZlbnQgbG9hZGVkZGF0YVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZUxvYWRlZERhdGE7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBmaW5pc2hlZCBkb3dubG9hZGluZyB0aGUgc291cmNlIGRhdGFcbiAqIEBldmVudCBsb2FkZWRhbGxkYXRhXG4gKi9cblBsYXllci5wcm90b3R5cGUuaGFuZGxlTG9hZGVkQWxsRGF0YTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGlzIGFjdGl2ZSwgZS5nLiBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgcGxheWVyXG4gKiBAZXZlbnQgdXNlcmFjdGl2ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVVzZXJBY3RpdmU7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdXNlciBpcyBpbmFjdGl2ZSwgZS5nLiBhIHNob3J0IGRlbGF5IGFmdGVyIHRoZSBsYXN0IG1vdXNlIG1vdmUgb3IgY29udHJvbCBpbnRlcmFjdGlvblxuICogQGV2ZW50IHVzZXJpbmFjdGl2ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVVzZXJJbmFjdGl2ZTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG4gKlxuICogRHVyaW5nIHBsYXliYWNrIHRoaXMgaXMgZmlyZWQgZXZlcnkgMTUtMjUwIG1pbGxpc2Vjb25kcywgZGVwZW5kaW5nIG9uIHRoZVxuICogcGxheWJhY2sgdGVjaG5vbG9neSBpbiB1c2UuXG4gKiBAZXZlbnQgdGltZXVwZGF0ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRpbWVVcGRhdGU7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdm9sdW1lIGNoYW5nZXNcbiAqIEBldmVudCB2b2x1bWVjaGFuZ2VcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5oYW5kbGVWb2x1bWVDaGFuZ2U7XG5cbi8qKlxuICogRmlyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAqIEBldmVudCBlcnJvclxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZUVycm9yO1xuXG5QbGF5ZXIucHJvdG90eXBlLmZsZXhOb3RTdXBwb3J0ZWRfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuXG4gIHJldHVybiAhKCdmbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHxcbiAgICAgICAgICAnd2Via2l0RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8XG4gICAgICAgICAgJ21vekZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fFxuICAgICAgICAgICdtc0ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSk7XG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXllcicsIFBsYXllcik7XG5leHBvcnQgZGVmYXVsdCBQbGF5ZXI7XG4iLCJpbXBvcnQgUGxheWVyIGZyb20gJy4vcGxheWVyJztcblxuLyoqXG4gKiB0aGUgbWV0aG9kIGZvciByZWdpc3RlcmluZyBhIHZpZGVvLmpzIHBsdWdpblxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gaW5pdCBUaGUgZnVuY3Rpb24gdGhhdCBpcyBydW4gd2hlbiB0aGUgcGxheWVyIGluaXRzXG4gKi9cbnZhciBwbHVnaW4gPSBmdW5jdGlvbihuYW1lLCBpbml0KXtcbiAgUGxheWVyLnByb3RvdHlwZVtuYW1lXSA9IGluaXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwbHVnaW47XG4iLCJpbXBvcnQgQnV0dG9uIGZyb20gJy4vYnV0dG9uLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgRm4gZnJvbSAnLi91dGlscy9mbi5qcyc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi91dGlscy9kb20uanMnO1xuaW1wb3J0ICogYXMgYnJvd3NlciBmcm9tICcuL3V0aWxzL2Jyb3dzZXIuanMnO1xuXG4vKiBQb3N0ZXIgSW1hZ2Vcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFRoZSBjb21wb25lbnQgdGhhdCBoYW5kbGVzIHNob3dpbmcgdGhlIHBvc3RlciBpbWFnZS5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUG9zdGVySW1hZ2UgZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgcGxheWVyLm9uKCdwb3N0ZXJjaGFuZ2UnLCBGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgdGhlIHBvc3RlciBpbWFnZVxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnBsYXllcigpLm9mZigncG9zdGVyY2hhbmdlJywgdGhpcy51cGRhdGUpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHBvc3RlciBpbWFnZSBlbGVtZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVFbCgpIHtcbiAgICBsZXQgZWwgPSBEb20uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wb3N0ZXInLFxuXG4gICAgICAvLyBEb24ndCB3YW50IHBvc3RlciB0byBiZSB0YWJiYWJsZS5cbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pO1xuXG4gICAgLy8gVG8gZW5zdXJlIHRoZSBwb3N0ZXIgaW1hZ2UgcmVzaXplcyB3aGlsZSBtYWludGFpbmluZyBpdHMgb3JpZ2luYWwgYXNwZWN0XG4gICAgLy8gcmF0aW8sIHVzZSBhIGRpdiB3aXRoIGBiYWNrZ3JvdW5kLXNpemVgIHdoZW4gYXZhaWxhYmxlLiBGb3IgYnJvd3NlcnMgdGhhdFxuICAgIC8vIGRvIG5vdCBzdXBwb3J0IGBiYWNrZ3JvdW5kLXNpemVgIChlLmcuIElFOCksIGZhbGwgYmFjayBvbiB1c2luZyBhIHJlZ3VsYXJcbiAgICAvLyBpbWcgZWxlbWVudC5cbiAgICBpZiAoIWJyb3dzZXIuQkFDS0dST1VORF9TSVpFX1NVUFBPUlRFRCkge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18gPSBEb20uY3JlYXRlRWwoJ2ltZycpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5mYWxsYmFja0ltZ18pO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB1cGRhdGVzIHRvIHRoZSBwbGF5ZXIncyBwb3N0ZXIgc291cmNlXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgbGV0IHVybCA9IHRoaXMucGxheWVyKCkucG9zdGVyKCk7XG5cbiAgICB0aGlzLnNldFNyYyh1cmwpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBwb3N0ZXIgc291cmNlIHdlIHNob3VsZCBkaXNwbGF5Om5vbmUgb24gdGhpcyBjb21wb25lbnRcbiAgICAvLyBzbyBpdCdzIG5vdCBzdGlsbCBjbGlja2FibGUgb3IgcmlnaHQtY2xpY2thYmxlXG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc3RlciBzb3VyY2UgZGVwZW5kaW5nIG9uIHRoZSBkaXNwbGF5IG1ldGhvZFxuICAgKi9cbiAgc2V0U3JjKHVybCkge1xuICAgIGlmICh0aGlzLmZhbGxiYWNrSW1nXykge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18uc3JjID0gdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYmFja2dyb3VuZEltYWdlID0gJyc7XG4gICAgICAvLyBBbnkgZmFsc2V5IHZhbHVlcyBzaG91bGQgc3RheSBhcyBhbiBlbXB0eSBzdHJpbmcsIG90aGVyd2lzZVxuICAgICAgLy8gdGhpcyB3aWxsIHRocm93IGFuIGV4dHJhIGVycm9yXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZSA9IGB1cmwoXCIke3VybH1cIilgO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsXy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBiYWNrZ3JvdW5kSW1hZ2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNsaWNrcyBvbiB0aGUgcG9zdGVyIGltYWdlXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICAvLyBXZSBkb24ndCB3YW50IGEgY2xpY2sgdG8gdHJpZ2dlciBwbGF5YmFjayB3aGVuIGNvbnRyb2xzIGFyZSBkaXNhYmxlZFxuICAgIC8vIGJ1dCBDU1Mgc2hvdWxkIGJlIGhpZGluZyB0aGUgcG9zdGVyIHRvIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZ1xuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUG9zdGVySW1hZ2UnLCBQb3N0ZXJJbWFnZSk7XG5leHBvcnQgZGVmYXVsdCBQb3N0ZXJJbWFnZTtcbiIsImltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuL3V0aWxzL2V2ZW50cy5qcyc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbmxldCBfd2luZG93TG9hZGVkID0gZmFsc2U7XG5sZXQgdmlkZW9qcztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZ1bmN0aW9ucyBmb3IgYXV0b21hdGljYWxseSBzZXR0aW5nIHVwIGEgcGxheWVyXG4gKiBiYXNlZCBvbiB0aGUgZGF0YS1zZXR1cCBhdHRyaWJ1dGUgb2YgdGhlIHZpZGVvIHRhZ1xuICovXG5cbi8vIEF1dG9tYXRpY2FsbHkgc2V0IHVwIGFueSB0YWdzIHRoYXQgaGF2ZSBhIGRhdGEtc2V0dXAgYXR0cmlidXRlXG52YXIgYXV0b1NldHVwID0gZnVuY3Rpb24oKXtcbiAgLy8gT25lIGRheSwgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgSUU4LCBnbyBiYWNrIHRvIHRoaXMsIGJ1dCBpbiB0aGUgbWVhbnRpbWUuLi4qaGFjayBoYWNrIGhhY2sqXG4gIC8vIHZhciB2aWRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJykpO1xuICAvLyB2YXIgYXVkaW9zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2F1ZGlvJykpO1xuICAvLyB2YXIgbWVkaWFFbHMgPSB2aWRzLmNvbmNhdChhdWRpb3MpO1xuXG4gIC8vIEJlY2F1c2UgSUU4IGRvZXNuJ3Qgc3VwcG9ydCBjYWxsaW5nIHNsaWNlIG9uIGEgbm9kZSBsaXN0LCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBlYWNoIGxpc3Qgb2YgZWxlbWVudHNcbiAgLy8gdG8gYnVpbGQgdXAgYSBuZXcsIGNvbWJpbmVkIGxpc3Qgb2YgZWxlbWVudHMuXG4gIHZhciB2aWRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJyk7XG4gIHZhciBhdWRpb3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKTtcbiAgdmFyIG1lZGlhRWxzID0gW107XG4gIGlmICh2aWRzICYmIHZpZHMubGVuZ3RoID4gMCkge1xuICAgIGZvcihsZXQgaT0wLCBlPXZpZHMubGVuZ3RoOyBpPGU7IGkrKykge1xuICAgICAgbWVkaWFFbHMucHVzaCh2aWRzW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKGF1ZGlvcyAmJiBhdWRpb3MubGVuZ3RoID4gMCkge1xuICAgIGZvcihsZXQgaT0wLCBlPWF1ZGlvcy5sZW5ndGg7IGk8ZTsgaSsrKSB7XG4gICAgICBtZWRpYUVscy5wdXNoKGF1ZGlvc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYW55IG1lZGlhIGVsZW1lbnRzIGV4aXN0XG4gIGlmIChtZWRpYUVscyAmJiBtZWRpYUVscy5sZW5ndGggPiAwKSB7XG5cbiAgICBmb3IgKGxldCBpPTAsIGU9bWVkaWFFbHMubGVuZ3RoOyBpPGU7IGkrKykge1xuICAgICAgbGV0IG1lZGlhRWwgPSBtZWRpYUVsc1tpXTtcblxuICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBleGlzdHMsIGhhcyBnZXRBdHRyaWJ1dGUgZnVuYy5cbiAgICAgIC8vIElFIHNlZW1zIHRvIGNvbnNpZGVyIHR5cGVvZiBlbC5nZXRBdHRyaWJ1dGUgPT0gJ29iamVjdCcgaW5zdGVhZCBvZiAnZnVuY3Rpb24nIGxpa2UgZXhwZWN0ZWQsIGF0IGxlYXN0IHdoZW4gbG9hZGluZyB0aGUgcGxheWVyIGltbWVkaWF0ZWx5LlxuICAgICAgaWYgKG1lZGlhRWwgJiYgbWVkaWFFbC5nZXRBdHRyaWJ1dGUpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBwbGF5ZXIgaGFzbid0IGFscmVhZHkgYmVlbiBzZXQgdXAuXG4gICAgICAgIGlmIChtZWRpYUVsWydwbGF5ZXInXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV0IG9wdGlvbnMgPSBtZWRpYUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zZXR1cCcpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZGF0YS1zZXR1cCBhdHRyIGV4aXN0cy5cbiAgICAgICAgICAvLyBXZSBvbmx5IGF1dG8tc2V0dXAgaWYgdGhleSd2ZSBhZGRlZCB0aGUgZGF0YS1zZXR1cCBhdHRyLlxuICAgICAgICAgIGlmIChvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHZpZGVvLmpzIGluc3RhbmNlLlxuICAgICAgICAgICAgbGV0IHBsYXllciA9IHZpZGVvanMobWVkaWFFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIElmIGdldEF0dHJpYnV0ZSBpc24ndCBkZWZpbmVkLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBET00uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgLy8gTm8gdmlkZW9zIHdlcmUgZm91bmQsIHNvIGtlZXAgbG9vcGluZyB1bmxlc3MgcGFnZSBpcyBmaW5pc2hlZCBsb2FkaW5nLlxuICB9IGVsc2UgaWYgKCFfd2luZG93TG9hZGVkKSB7XG4gICAgYXV0b1NldHVwVGltZW91dCgxKTtcbiAgfVxufTtcblxuLy8gUGF1c2UgdG8gbGV0IHRoZSBET00ga2VlcCBwcm9jZXNzaW5nXG52YXIgYXV0b1NldHVwVGltZW91dCA9IGZ1bmN0aW9uKHdhaXQsIHZqcyl7XG4gIHZpZGVvanMgPSB2anM7XG4gIHNldFRpbWVvdXQoYXV0b1NldHVwLCB3YWl0KTtcbn07XG5cbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gIF93aW5kb3dMb2FkZWQgPSB0cnVlO1xufSBlbHNlIHtcbiAgRXZlbnRzLm9uZSh3aW5kb3csICdsb2FkJywgZnVuY3Rpb24oKXtcbiAgICBfd2luZG93TG9hZGVkID0gdHJ1ZTtcbiAgfSk7XG59XG5cbnZhciBoYXNMb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF93aW5kb3dMb2FkZWQ7XG59O1xuXG5leHBvcnQgeyBhdXRvU2V0dXAsIGF1dG9TZXR1cFRpbWVvdXQsIGhhc0xvYWRlZCB9O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQuanMnO1xuaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QuYXNzaWduJztcblxuLyoqXG4gKiBTZWVrQmFyIEJlaGF2aW9yIGluY2x1ZGVzIHBsYXkgcHJvZ3Jlc3MgYmFyLCBhbmQgc2VlayBoYW5kbGVcbiAqIE5lZWRlZCBzbyBpdCBjYW4gZGV0ZXJtaW5lIHNlZWsgcG9zaXRpb24gYmFzZWQgb24gaGFuZGxlIHBvc2l0aW9uL3NpemVcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTbGlkZXJIYW5kbGUgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBjcmVhdGVFbCh0eXBlLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgLy8gQWRkIHRoZSBzbGlkZXIgZWxlbWVudCBjbGFzcyB0byBhbGwgc3ViIGNsYXNzZXNcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgKyAnIHZqcy1zbGlkZXItaGFuZGxlJztcbiAgICBwcm9wcyA9IGFzc2lnbih7XG4gICAgICBpbm5lckhUTUw6IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke3RoaXMuZGVmYXVsdFZhbHVlIHx8IDB9PC9zcGFuPmBcbiAgICB9LCBwcm9wcyk7XG5cbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHByb3BzKTtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU2xpZGVySGFuZGxlJywgU2xpZGVySGFuZGxlKTtcbmV4cG9ydCBkZWZhdWx0IFNsaWRlckhhbmRsZTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIERvbSBmcm9tICcuLi91dGlscy9kb20uanMnO1xuaW1wb3J0IHJvdW5kRmxvYXQgZnJvbSAnLi4vdXRpbHMvcm91bmQtZmxvYXQuanMnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5pbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC5hc3NpZ24nO1xuXG4vKiBTbGlkZXJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFRoZSBiYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIHNsaWRlcnMgbGlrZSB0aGUgdm9sdW1lIGJhciBhbmQgc2VlayBiYXJcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU2xpZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciBhbmQgaGFuZGxlIHRvIG1hdGNoIHdpdGggdGhlIGNoaWxkIFNsaWRlciBjbGFzcyBpcyBsb29raW5nIGZvclxuICAgIHRoaXMuYmFyID0gdGhpcy5nZXRDaGlsZCh0aGlzLm9wdGlvbnNfWydiYXJOYW1lJ10pO1xuICAgIHRoaXMuaGFuZGxlID0gdGhpcy5nZXRDaGlsZCh0aGlzLm9wdGlvbnNfWydoYW5kbGVOYW1lJ10pO1xuXG4gICAgLy8gU2V0IGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjbGFzcyBvbiB0aGUgc2xpZGVyIGRlcGVuZGluZyBvbiB0aGUgc2xpZGVyIHR5cGVcbiAgICB0aGlzLnZlcnRpY2FsKCEhdGhpcy5vcHRpb25zKClbJ3ZlcnRpY2FsJ10pO1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgICB0aGlzLm9uKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2spO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICdjb250cm9sc3Zpc2libGUnLCB0aGlzLnVwZGF0ZSk7XG4gICAgdGhpcy5vbihwbGF5ZXIsIHRoaXMucGxheWVyRXZlbnQsIHRoaXMudXBkYXRlKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKHR5cGUsIHByb3BzPXt9KSB7XG4gICAgLy8gQWRkIHRoZSBzbGlkZXIgZWxlbWVudCBjbGFzcyB0byBhbGwgc3ViIGNsYXNzZXNcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgKyAnIHZqcy1zbGlkZXInO1xuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgICdyb2xlJzogJ3NsaWRlcicsXG4gICAgICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgICAnYXJpYS12YWx1ZW1heCc6IDEwMCxcbiAgICAgIHRhYkluZGV4OiAwXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKHR5cGUsIHByb3BzKTtcbiAgfVxuXG4gIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgRG9tLmJsb2NrVGV4dFNlbGVjdGlvbigpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG5cbiAgICB0aGlzLm9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG5cbiAgICB0aGlzLmhhbmRsZU1vdXNlTW92ZShldmVudCk7XG4gIH1cblxuICAvLyBUbyBiZSBvdmVycmlkZGVuIGJ5IGEgc3ViY2xhc3NcbiAgaGFuZGxlTW91c2VNb3ZlKCkge31cblxuICBoYW5kbGVNb3VzZVVwKCkge1xuICAgIERvbS51bmJsb2NrVGV4dFNlbGVjdGlvbigpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG5cbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICAvLyBJbiBWb2x1bWVCYXIgaW5pdCB3ZSBoYXZlIGEgc2V0VGltZW91dCBmb3IgdXBkYXRlIHRoYXQgcG9wcyBhbmQgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gZXhlY3V0aW9uIHN0YWNrLiBUaGUgcGxheWVyIGlzIGRlc3Ryb3llZCBiZWZvcmUgdGhlbiB1cGRhdGUgd2lsbCBjYXVzZSBhbiBlcnJvclxuICAgIGlmICghdGhpcy5lbF8pIHJldHVybjtcblxuICAgIC8vIElmIHNjcnViYmluZywgd2UgY291bGQgdXNlIGEgY2FjaGVkIHZhbHVlIHRvIG1ha2UgdGhlIGhhbmRsZSBrZWVwIHVwIHdpdGggdGhlIHVzZXIncyBtb3VzZS5cbiAgICAvLyBPbiBIVE1MNSBicm93c2VycyBzY3J1YmJpbmcgaXMgcmVhbGx5IHNtb290aCwgYnV0IHNvbWUgZmxhc2ggcGxheWVycyBhcmUgc2xvdywgc28gd2UgbWlnaHQgd2FudCB0byB1dGlsaXplIHRoaXMgbGF0ZXIuXG4gICAgLy8gdmFyIHByb2dyZXNzID0gICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIGxldCBwcm9ncmVzcyA9IHRoaXMuZ2V0UGVyY2VudCgpO1xuICAgIGxldCBiYXIgPSB0aGlzLmJhcjtcblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gYmFyLi4uXG4gICAgaWYgKCFiYXIpIHJldHVybjtcblxuICAgIC8vIFByb3RlY3QgYWdhaW5zdCBubyBkdXJhdGlvbiBhbmQgb3RoZXIgZGl2aXNpb24gaXNzdWVzXG4gICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgcHJvZ3Jlc3MgIT09IHByb2dyZXNzIHx8XG4gICAgICAgIHByb2dyZXNzIDwgMCB8fFxuICAgICAgICBwcm9ncmVzcyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBwcm9ncmVzcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBoYW5kbGUsIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIGhhbmRsZSBpbiBvdXIgY2FsY3VsYXRpb24gZm9yIHByb2dyZXNzIGJhclxuICAgIC8vIHNvIHRoYXQgaXQgZG9lc24ndCBmYWxsIHNob3J0IG9mIG9yIGV4dGVuZCBwYXN0IHRoZSBoYW5kbGUuXG4gICAgbGV0IGJhclByb2dyZXNzID0gdGhpcy51cGRhdGVIYW5kbGVQb3NpdGlvbihwcm9ncmVzcyk7XG5cbiAgICAvLyBDb252ZXJ0IHRvIGEgcGVyY2VudGFnZSBmb3Igc2V0dGluZ1xuICAgIGxldCBwZXJjZW50YWdlID0gcm91bmRGbG9hdChiYXJQcm9ncmVzcyAqIDEwMCwgMikgKyAnJSc7XG5cbiAgICAvLyBTZXQgdGhlIG5ldyBiYXIgd2lkdGggb3IgaGVpZ2h0XG4gICAgaWYgKHRoaXMudmVydGljYWwoKSkge1xuICAgICAgYmFyLmVsKCkuc3R5bGUuaGVpZ2h0ID0gcGVyY2VudGFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyLmVsKCkuc3R5bGUud2lkdGggPSBwZXJjZW50YWdlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIFVwZGF0ZSB0aGUgaGFuZGxlIHBvc2l0aW9uLlxuICAqL1xuICB1cGRhdGVIYW5kbGVQb3NpdGlvbihwcm9ncmVzcykge1xuICAgIGxldCBoYW5kbGUgPSB0aGlzLmhhbmRsZTtcbiAgICBpZiAoIWhhbmRsZSkgcmV0dXJuO1xuXG4gICAgbGV0IHZlcnRpY2FsID0gdGhpcy52ZXJ0aWNhbCgpO1xuICAgIGxldCBib3ggPSB0aGlzLmVsXztcblxuICAgIGxldCBib3hTaXplLCBoYW5kbGVTaXplO1xuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgYm94U2l6ZSA9IGJveC5vZmZzZXRIZWlnaHQ7XG4gICAgICBoYW5kbGVTaXplID0gaGFuZGxlLmVsKCkub2Zmc2V0SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3hTaXplID0gYm94Lm9mZnNldFdpZHRoO1xuICAgICAgaGFuZGxlU2l6ZSA9IGhhbmRsZS5lbCgpLm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIC8vIFRoZSB3aWR0aCBvZiB0aGUgaGFuZGxlIGluIHBlcmNlbnQgb2YgdGhlIGNvbnRhaW5pbmcgYm94XG4gICAgLy8gSW4gSUUsIHdpZHRocyBtYXkgbm90IGJlIHJlYWR5IHlldCBjYXVzaW5nIE5hTlxuICAgIGxldCBoYW5kbGVQZXJjZW50ID0gKGhhbmRsZVNpemUpID8gaGFuZGxlU2l6ZSAvIGJveFNpemUgOiAwO1xuXG4gICAgLy8gR2V0IHRoZSBhZGp1c3RlZCBzaXplIG9mIHRoZSBib3gsIGNvbnNpZGVyaW5nIHRoYXQgdGhlIGhhbmRsZSdzIGNlbnRlciBuZXZlciB0b3VjaGVzIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUuXG4gICAgLy8gVGhlcmUgaXMgYSBtYXJnaW4gb2YgaGFsZiB0aGUgaGFuZGxlJ3Mgd2lkdGggb24gYm90aCBzaWRlcy5cbiAgICBsZXQgYm94QWRqdXN0ZWRQZXJjZW50ID0gMSAtIGhhbmRsZVBlcmNlbnQ7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHByb2dyZXNzIHRoYXQgd2UnbGwgdXNlIHRvIHNldCB3aWR0aHMgdG8gdGhlIG5ldyBhZGp1c3RlZCBib3ggd2lkdGhcbiAgICBsZXQgYWRqdXN0ZWRQcm9ncmVzcyA9IHByb2dyZXNzICogYm94QWRqdXN0ZWRQZXJjZW50O1xuXG4gICAgLy8gVGhlIGJhciBkb2VzIHJlYWNoIHRoZSBsZWZ0IHNpZGUsIHNvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhpcyBpbiB0aGUgYmFyJ3Mgd2lkdGhcbiAgICBsZXQgYmFyUHJvZ3Jlc3MgPSBhZGp1c3RlZFByb2dyZXNzICsgKGhhbmRsZVBlcmNlbnQgLyAyKTtcblxuICAgIGxldCBwZXJjZW50YWdlID0gcm91bmRGbG9hdChhZGp1c3RlZFByb2dyZXNzICogMTAwLCAyKSArICclJztcblxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgaGFuZGxlLmVsKCkuc3R5bGUuYm90dG9tID0gcGVyY2VudGFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlLmVsKCkuc3R5bGUubGVmdCA9IHBlcmNlbnRhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhclByb2dyZXNzO1xuICB9XG5cbiAgY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpe1xuICAgIGxldCBlbCA9IHRoaXMuZWxfO1xuICAgIGxldCBib3ggPSBEb20uZmluZFBvc2l0aW9uKGVsKTtcbiAgICBsZXQgYm94VyA9IGVsLm9mZnNldFdpZHRoO1xuICAgIGxldCBib3hIID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIGxldCBoYW5kbGUgPSB0aGlzLmhhbmRsZTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMoKVsndmVydGljYWwnXSkge1xuICAgICAgbGV0IGJveFkgPSBib3gudG9wO1xuXG4gICAgICBsZXQgcGFnZVk7XG4gICAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgcGFnZVkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgdmFyIGhhbmRsZUggPSBoYW5kbGUuZWwoKS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8vIEFkanVzdGVkIFggYW5kIFdpZHRoLCBzbyBoYW5kbGUgZG9lc24ndCBnbyBvdXRzaWRlIHRoZSBiYXJcbiAgICAgICAgYm94WSA9IGJveFkgKyAoaGFuZGxlSCAvIDIpO1xuICAgICAgICBib3hIID0gYm94SCAtIGhhbmRsZUg7XG4gICAgICB9XG5cbiAgICAgIC8vIFBlcmNlbnQgdGhhdCB0aGUgY2xpY2sgaXMgdGhyb3VnaCB0aGUgYWRqdXN0ZWQgYXJlYVxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsICgoYm94WSAtIHBhZ2VZKSArIGJveEgpIC8gYm94SCkpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBib3hYID0gYm94LmxlZnQ7XG5cbiAgICAgIGxldCBwYWdlWDtcbiAgICAgIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICBwYWdlWCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFnZVggPSBldmVudC5wYWdlWDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICB2YXIgaGFuZGxlVyA9IGhhbmRsZS5lbCgpLm9mZnNldFdpZHRoO1xuXG4gICAgICAgIC8vIEFkanVzdGVkIFggYW5kIFdpZHRoLCBzbyBoYW5kbGUgZG9lc24ndCBnbyBvdXRzaWRlIHRoZSBiYXJcbiAgICAgICAgYm94WCA9IGJveFggKyAoaGFuZGxlVyAvIDIpO1xuICAgICAgICBib3hXID0gYm94VyAtIGhhbmRsZVc7XG4gICAgICB9XG5cbiAgICAgIC8vIFBlcmNlbnQgdGhhdCB0aGUgY2xpY2sgaXMgdGhyb3VnaCB0aGUgYWRqdXN0ZWQgYXJlYVxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChwYWdlWCAtIGJveFgpIC8gYm94VykpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMub24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH1cblxuICBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMzcgfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7IC8vIExlZnQgYW5kIERvd24gQXJyb3dzXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwQmFjaygpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkgeyAvLyBVcCBhbmQgUmlnaHQgQXJyb3dzXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwRm9yd2FyZCgpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUJsdXIoKSB7XG4gICAgdGhpcy5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuZXIgZm9yIGNsaWNrIGV2ZW50cyBvbiBzbGlkZXIsIHVzZWQgdG8gcHJldmVudCBjbGlja3NcbiAgICogICBmcm9tIGJ1YmJsaW5nIHVwIHRvIHBhcmVudCBlbGVtZW50cyBsaWtlIGJ1dHRvbiBtZW51cy5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3RcbiAgICovXG4gIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIHZlcnRpY2FsKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbF8gfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy52ZXJ0aWNhbF8gPSAhIWJvb2w7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNhbF8pIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItdmVydGljYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci1ob3Jpem9udGFsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NsaWRlcicsIFNsaWRlcik7XG5leHBvcnQgZGVmYXVsdCBTbGlkZXI7XG4iLCJmdW5jdGlvbiBGbGFzaFJ0bXBEZWNvcmF0b3IoRmxhc2gpIHtcbiAgRmxhc2guc3RyZWFtaW5nRm9ybWF0cyA9IHtcbiAgICAncnRtcC9tcDQnOiAnTVA0JyxcbiAgICAncnRtcC9mbHYnOiAnRkxWJ1xuICB9O1xuXG4gIEZsYXNoLnN0cmVhbUZyb21QYXJ0cyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIHN0cmVhbSkge1xuICAgIHJldHVybiBjb25uZWN0aW9uICsgJyYnICsgc3RyZWFtO1xuICB9O1xuXG4gIEZsYXNoLnN0cmVhbVRvUGFydHMgPSBmdW5jdGlvbihzcmMpIHtcbiAgICBsZXQgcGFydHMgPSB7XG4gICAgICBjb25uZWN0aW9uOiAnJyxcbiAgICAgIHN0cmVhbTogJydcbiAgICB9O1xuXG4gICAgaWYgKCFzcmMpIHJldHVybiBwYXJ0cztcblxuICAgIC8vIExvb2sgZm9yIHRoZSBub3JtYWwgVVJMIHNlcGFyYXRvciB3ZSBleHBlY3QsICcmJy5cbiAgICAvLyBJZiBmb3VuZCwgd2Ugc3BsaXQgdGhlIFVSTCBpbnRvIHR3byBwaWVjZXMgYXJvdW5kIHRoZVxuICAgIC8vIGZpcnN0ICcmJy5cbiAgICBsZXQgY29ubkVuZCA9IHNyYy5pbmRleE9mKCcmJyk7XG4gICAgbGV0IHN0cmVhbUJlZ2luO1xuICAgIGlmIChjb25uRW5kICE9PSAtMSkge1xuICAgICAgc3RyZWFtQmVnaW4gPSBjb25uRW5kICsgMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vdCBhICcmJywgd2UgdXNlIHRoZSBsYXN0ICcvJyBhcyB0aGUgZGVsaW1pdGVyLlxuICAgICAgY29ubkVuZCA9IHN0cmVhbUJlZ2luID0gc3JjLmxhc3RJbmRleE9mKCcvJykgKyAxO1xuICAgICAgaWYgKGNvbm5FbmQgPT09IDApIHtcbiAgICAgICAgLy8gcmVhbGx5LCB0aGVyZSdzIG5vdCBhICcvJz9cbiAgICAgICAgY29ubkVuZCA9IHN0cmVhbUJlZ2luID0gc3JjLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFydHMuY29ubmVjdGlvbiA9IHNyYy5zdWJzdHJpbmcoMCwgY29ubkVuZCk7XG4gICAgcGFydHMuc3RyZWFtID0gc3JjLnN1YnN0cmluZyhzdHJlYW1CZWdpbiwgc3JjLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gcGFydHM7XG4gIH07XG5cbiAgRmxhc2guaXNTdHJlYW1pbmdUeXBlID0gZnVuY3Rpb24oc3JjVHlwZSkge1xuICAgIHJldHVybiBzcmNUeXBlIGluIEZsYXNoLnN0cmVhbWluZ0Zvcm1hdHM7XG4gIH07XG5cbiAgLy8gUlRNUCBoYXMgZm91ciB2YXJpYXRpb25zLCBhbnkgc3RyaW5nIHN0YXJ0aW5nXG4gIC8vIHdpdGggb25lIG9mIHRoZXNlIHByb3RvY29scyBzaG91bGQgYmUgdmFsaWRcbiAgRmxhc2guUlRNUF9SRSA9IC9ecnRtcFtzZXRdPzpcXC9cXC8vaTtcblxuICBGbGFzaC5pc1N0cmVhbWluZ1NyYyA9IGZ1bmN0aW9uKHNyYykge1xuICAgIHJldHVybiBGbGFzaC5SVE1QX1JFLnRlc3Qoc3JjKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBzb3VyY2UgaGFuZGxlciBmb3IgUlRNUCB1cmxzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBGbGFzaC5ydG1wU291cmNlSGFuZGxlciA9IHt9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBGbGFzaCBjYW4gaGFuZGxlIHRoZSBzb3VyY2UgbmF0aXZlbHlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cbiAgRmxhc2gucnRtcFNvdXJjZUhhbmRsZXIuY2FuSGFuZGxlU291cmNlID0gZnVuY3Rpb24oc291cmNlKXtcbiAgICBpZiAoRmxhc2guaXNTdHJlYW1pbmdUeXBlKHNvdXJjZS50eXBlKSB8fCBGbGFzaC5pc1N0cmVhbWluZ1NyYyhzb3VyY2Uuc3JjKSkge1xuICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXNzIHRoZSBzb3VyY2UgdG8gdGhlIGZsYXNoIG9iamVjdFxuICAgKiBBZGFwdGl2ZSBzb3VyY2UgaGFuZGxlcnMgd2lsbCBoYXZlIG1vcmUgY29tcGxpY2F0ZWQgd29ya2Zsb3dzIGJlZm9yZSBwYXNzaW5nXG4gICAqIHZpZGVvIGRhdGEgdG8gdGhlIHZpZGVvIGVsZW1lbnRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtICB7Rmxhc2h9IHRlY2ggICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEZsYXNoIHRlY2hcbiAgICovXG4gIEZsYXNoLnJ0bXBTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSwgdGVjaCl7XG4gICAgbGV0IHNyY1BhcnRzID0gRmxhc2guc3RyZWFtVG9QYXJ0cyhzb3VyY2Uuc3JjKTtcblxuICAgIHRlY2hbJ3NldFJ0bXBDb25uZWN0aW9uJ10oc3JjUGFydHMuY29ubmVjdGlvbik7XG4gICAgdGVjaFsnc2V0UnRtcFN0cmVhbSddKHNyY1BhcnRzLnN0cmVhbSk7XG4gIH07XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIG5hdGl2ZSBzb3VyY2UgaGFuZGxlclxuICBGbGFzaC5yZWdpc3RlclNvdXJjZUhhbmRsZXIoRmxhc2gucnRtcFNvdXJjZUhhbmRsZXIpO1xuXG4gIHJldHVybiBGbGFzaDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRmxhc2hSdG1wRGVjb3JhdG9yO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZpZGVvSlMtU1dGIC0gQ3VzdG9tIEZsYXNoIFBsYXllciB3aXRoIEhUTUw1LWlzaCBBUElcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5jb2Rlci92aWRlby1qcy1zd2ZcbiAqIE5vdCB1c2luZyBzZXR1cFRyaWdnZXJzLiBVc2luZyBnbG9iYWwgb25FdmVudCBmdW5jIHRvIGRpc3RyaWJ1dGUgZXZlbnRzXG4gKi9cblxuaW1wb3J0IFRlY2ggZnJvbSAnLi90ZWNoJztcbmltcG9ydCAqIGFzIERvbSBmcm9tICcuLi91dGlscy9kb20uanMnO1xuaW1wb3J0ICogYXMgVXJsIGZyb20gJy4uL3V0aWxzL3VybC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUaW1lUmFuZ2UgfSBmcm9tICcuLi91dGlscy90aW1lLXJhbmdlcy5qcyc7XG5pbXBvcnQgRmxhc2hSdG1wRGVjb3JhdG9yIGZyb20gJy4vZmxhc2gtcnRtcCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QuYXNzaWduJztcblxubGV0IG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4vKipcbiAqIEZsYXNoIE1lZGlhIENvbnRyb2xsZXIgLSBXcmFwcGVyIGZvciBmYWxsYmFjayBTV0YgQVBJXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gcmVhZHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBGbGFzaCBleHRlbmRzIFRlY2gge1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihvcHRpb25zLCByZWFkeSk7XG5cbiAgICBsZXQgeyBzb3VyY2UsIHBhcmVudEVsIH0gPSBvcHRpb25zO1xuXG4gICAgLy8gR2VuZXJhdGUgSUQgZm9yIHN3ZiBvYmplY3RcbiAgICBsZXQgb2JqSWQgPSBvcHRpb25zLnBsYXllcklkKydfZmxhc2hfYXBpJztcblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgZmxhc2h2YXJzIHdpdGggb25lcyBwYXNzZWQgaW4gdG8gaW5pdFxuICAgIGxldCBmbGFzaFZhcnMgPSBhc3NpZ24oe1xuXG4gICAgICAvLyBTV0YgQ2FsbGJhY2sgRnVuY3Rpb25zXG4gICAgICAncmVhZHlGdW5jdGlvbic6ICd2aWRlb2pzLkZsYXNoLm9uUmVhZHknLFxuICAgICAgJ2V2ZW50UHJveHlGdW5jdGlvbic6ICd2aWRlb2pzLkZsYXNoLm9uRXZlbnQnLFxuICAgICAgJ2Vycm9yRXZlbnRQcm94eUZ1bmN0aW9uJzogJ3ZpZGVvanMuRmxhc2gub25FcnJvcicsXG5cbiAgICAgIC8vIFBsYXllciBTZXR0aW5nc1xuICAgICAgJ2F1dG9wbGF5Jzogb3B0aW9ucy5hdXRvcGxheSxcbiAgICAgICdwcmVsb2FkJzogb3B0aW9ucy5wcmVsb2FkLFxuICAgICAgJ2xvb3AnOiBvcHRpb25zLmxvb3AsXG4gICAgICAnbXV0ZWQnOiBvcHRpb25zLm11dGVkXG5cbiAgICB9LCBvcHRpb25zLmZsYXNoVmFycyk7XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IHBhcmFtZXMgd2l0aCBvbmVzIHBhc3NlZCBpblxuICAgIGxldCBwYXJhbXMgPSBhc3NpZ24oe1xuICAgICAgJ3dtb2RlJzogJ29wYXF1ZScsIC8vIE9wYXF1ZSBpcyBuZWVkZWQgdG8gb3ZlcmxheSBjb250cm9scywgYnV0IGNhbiBhZmZlY3QgcGxheWJhY2sgcGVyZm9ybWFuY2VcbiAgICAgICdiZ2NvbG9yJzogJyMwMDAwMDAnIC8vIFVzaW5nIGJnY29sb3IgcHJldmVudHMgYSB3aGl0ZSBmbGFzaCB3aGVuIHRoZSBvYmplY3QgaXMgbG9hZGluZ1xuICAgIH0sIG9wdGlvbnMucGFyYW1zKTtcblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgYXR0cmlidXRlcyB3aXRoIG9uZXMgcGFzc2VkIGluXG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgICAgJ2lkJzogb2JqSWQsXG4gICAgICAnbmFtZSc6IG9iaklkLCAvLyBCb3RoIElEIGFuZCBOYW1lIG5lZWRlZCBvciBzd2YgdG8gaWRlbnRpZnkgaXRzZWxmXG4gICAgICAnY2xhc3MnOiAndmpzLXRlY2gnXG4gICAgfSwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcblxuICAgIC8vIElmIHNvdXJjZSB3YXMgc3VwcGxpZWQgcGFzcyBhcyBhIGZsYXNoIHZhci5cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBIYXZpbmcgaXNzdWVzIHdpdGggRmxhc2ggcmVsb2FkaW5nIG9uIGNlcnRhaW4gcGFnZSBhY3Rpb25zIChoaWRlL3Jlc2l6ZS9mdWxsc2NyZWVuKSBpbiBjZXJ0YWluIGJyb3dzZXJzXG4gICAgLy8gVGhpcyBhbGxvd3MgcmVzZXR0aW5nIHRoZSBwbGF5aGVhZCB3aGVuIHdlIGNhdGNoIHRoZSByZWxvYWRcbiAgICBpZiAob3B0aW9ucy5zdGFydFRpbWUpIHtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lKG9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHdpbmRvdy52aWRlb2pzID0gd2luZG93LnZpZGVvanMgfHwge307XG4gICAgd2luZG93LnZpZGVvanMuRmxhc2ggPSB3aW5kb3cudmlkZW9qcy5GbGFzaCB8fCB7fTtcbiAgICB3aW5kb3cudmlkZW9qcy5GbGFzaC5vblJlYWR5ID0gRmxhc2gub25SZWFkeTtcbiAgICB3aW5kb3cudmlkZW9qcy5GbGFzaC5vbkV2ZW50ID0gRmxhc2gub25FdmVudDtcbiAgICB3aW5kb3cudmlkZW9qcy5GbGFzaC5vbkVycm9yID0gRmxhc2gub25FcnJvcjtcblxuICAgIHRoaXMuZWxfID0gRmxhc2guZW1iZWQob3B0aW9ucy5zd2YsIGZsYXNoVmFycywgcGFyYW1zLCBhdHRyaWJ1dGVzKTtcbiAgICB0aGlzLmVsXy50ZWNoID0gdGhpcztcbiAgfVxuXG4gIHBsYXkoKSB7XG4gICAgdGhpcy5lbF8udmpzX3BsYXkoKTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuZWxfLnZqc19wYXVzZSgpO1xuICB9XG5cbiAgc3JjKHNyYykge1xuICAgIGlmIChzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNyYygpO1xuICAgIH1cblxuICAgIC8vIFNldHRpbmcgc3JjIHRocm91Z2ggYHNyY2Agbm90IGBzZXRTcmNgIHdpbGwgYmUgZGVwcmVjYXRlZFxuICAgIHJldHVybiB0aGlzLnNldFNyYyhzcmMpO1xuICB9XG5cbiAgc2V0U3JjKHNyYykge1xuICAgIC8vIE1ha2Ugc3VyZSBzb3VyY2UgVVJMIGlzIGFic29sdXRlLlxuICAgIHNyYyA9IFVybC5nZXRBYnNvbHV0ZVVSTChzcmMpO1xuICAgIHRoaXMuZWxfLnZqc19zcmMoc3JjKTtcblxuICAgIC8vIEN1cnJlbnRseSB0aGUgU1dGIGRvZXNuJ3QgYXV0b3BsYXkgaWYgeW91IGxvYWQgYSBzb3VyY2UgbGF0ZXIuXG4gICAgLy8gZS5nLiBMb2FkIHBsYXllciB3LyBubyBzb3VyY2UsIHdhaXQgMnMsIHNldCBzcmMuXG4gICAgaWYgKHRoaXMuYXV0b3BsYXkoKSkge1xuICAgICAgdmFyIHRlY2ggPSB0aGlzO1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHRlY2gucGxheSgpOyB9LCAwKTtcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgdGhpcy5sYXN0U2Vla1RhcmdldF8gPSB0aW1lO1xuICAgIHRoaXMuZWxfLnZqc19zZXRQcm9wZXJ0eSgnY3VycmVudFRpbWUnLCB0aW1lKTtcbiAgICBzdXBlci5zZXRDdXJyZW50VGltZSgpO1xuICB9XG5cbiAgY3VycmVudFRpbWUodGltZSkge1xuICAgIC8vIHdoZW4gc2Vla2luZyBtYWtlIHRoZSByZXBvcnRlZCB0aW1lIGtlZXAgdXAgd2l0aCB0aGUgcmVxdWVzdGVkIHRpbWVcbiAgICAvLyBieSByZWFkaW5nIHRoZSB0aW1lIHdlJ3JlIHNlZWtpbmcgdG9cbiAgICBpZiAodGhpcy5zZWVraW5nKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RTZWVrVGFyZ2V0XyB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdjdXJyZW50VGltZScpO1xuICB9XG5cbiAgY3VycmVudFNyYygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZV8uc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdjdXJyZW50U3JjJyk7XG4gICAgfVxuICB9XG5cbiAgbG9hZCgpIHtcbiAgICB0aGlzLmVsXy52anNfbG9hZCgpO1xuICB9XG5cbiAgcG9zdGVyKCkge1xuICAgIHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eSgncG9zdGVyJyk7XG4gIH1cblxuICAvLyBwb3N0ZXIgaW1hZ2VzIGFyZSBub3QgaGFuZGxlZCBieSB0aGUgRmxhc2ggdGVjaCBzbyBtYWtlIHRoaXMgYSBuby1vcFxuICBzZXRQb3N0ZXIoKSB7fVxuXG4gIGJ1ZmZlcmVkKCkge1xuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2UoMCwgdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdidWZmZXJlZCcpKTtcbiAgfVxuXG4gIHN1cHBvcnRzRnVsbFNjcmVlbigpIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIEZsYXNoIGRvZXMgbm90IGFsbG93IGZ1bGxzY3JlZW4gdGhyb3VnaCBqYXZhc2NyaXB0XG4gIH1cblxuICBlbnRlckZ1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cblxuXG4vLyBDcmVhdGUgc2V0dGVycyBhbmQgZ2V0dGVycyBmb3IgYXR0cmlidXRlc1xuY29uc3QgX2FwaSA9IEZsYXNoLnByb3RvdHlwZTtcbmNvbnN0IF9yZWFkV3JpdGUgPSAncnRtcENvbm5lY3Rpb24scnRtcFN0cmVhbSxwcmVsb2FkLGRlZmF1bHRQbGF5YmFja1JhdGUscGxheWJhY2tSYXRlLGF1dG9wbGF5LGxvb3AsbWVkaWFHcm91cCxjb250cm9sbGVyLGNvbnRyb2xzLHZvbHVtZSxtdXRlZCxkZWZhdWx0TXV0ZWQnLnNwbGl0KCcsJyk7XG5jb25zdCBfcmVhZE9ubHkgPSAnZXJyb3IsbmV0d29ya1N0YXRlLHJlYWR5U3RhdGUsc2Vla2luZyxpbml0aWFsVGltZSxkdXJhdGlvbixzdGFydE9mZnNldFRpbWUscGF1c2VkLHBsYXllZCxzZWVrYWJsZSxlbmRlZCx2aWRlb1RyYWNrcyxhdWRpb1RyYWNrcyx2aWRlb1dpZHRoLHZpZGVvSGVpZ2h0Jy5zcGxpdCgnLCcpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU2V0dGVyKGF0dHIpe1xuICB2YXIgYXR0clVwcGVyID0gYXR0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGF0dHIuc2xpY2UoMSk7XG4gIF9hcGlbJ3NldCcrYXR0clVwcGVyXSA9IGZ1bmN0aW9uKHZhbCl7IHJldHVybiB0aGlzLmVsXy52anNfc2V0UHJvcGVydHkoYXR0ciwgdmFsKTsgfTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVHZXR0ZXIoYXR0cikge1xuICBfYXBpW2F0dHJdID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eShhdHRyKTsgfTtcbn1cblxuLy8gQ3JlYXRlIGdldHRlciBhbmQgc2V0dGVycyBmb3IgYWxsIHJlYWQvd3JpdGUgYXR0cmlidXRlc1xuZm9yIChsZXQgaSA9IDA7IGkgPCBfcmVhZFdyaXRlLmxlbmd0aDsgaSsrKSB7XG4gIF9jcmVhdGVHZXR0ZXIoX3JlYWRXcml0ZVtpXSk7XG4gIF9jcmVhdGVTZXR0ZXIoX3JlYWRXcml0ZVtpXSk7XG59XG5cbi8vIENyZWF0ZSBnZXR0ZXJzIGZvciByZWFkLW9ubHkgYXR0cmlidXRlc1xuZm9yIChsZXQgaSA9IDA7IGkgPCBfcmVhZE9ubHkubGVuZ3RoOyBpKyspIHtcbiAgX2NyZWF0ZUdldHRlcihfcmVhZE9ubHlbaV0pO1xufVxuXG4vKiBGbGFzaCBTdXBwb3J0IFRlc3RpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuRmxhc2guaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gRmxhc2gudmVyc2lvbigpWzBdID49IDEwO1xuICAvLyByZXR1cm4gc3dmb2JqZWN0Lmhhc0ZsYXNoUGxheWVyVmVyc2lvbignMTAnKTtcbn07XG5cbi8vIEFkZCBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuIGZ1bmN0aW9ucyB0byB0aGlzIHRlY2hcblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzKEZsYXNoKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBuYXRpdmUgc291cmNlIGhhbmRsZXIuXG4gKiBUaGlzIHNpbXBseSBwYXNzZXMgdGhlIHNvdXJjZSB0byB0aGUgdmlkZW8gZWxlbWVudC4gTm90aGluZyBmYW5jeS5cbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0ZsYXNofSB0ZWNoICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEZsYXNoIHRlY2hcbiAqL1xuRmxhc2gubmF0aXZlU291cmNlSGFuZGxlciA9IHt9O1xuXG4vKipcbiAqIENoZWNrIEZsYXNoIGNhbiBoYW5kbGUgdGhlIHNvdXJjZSBuYXRpdmVseVxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuRmxhc2gubmF0aXZlU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2Upe1xuICB2YXIgdHlwZTtcblxuICBmdW5jdGlvbiBndWVzc01pbWVUeXBlKHNyYykge1xuICAgIHZhciBleHQgPSBVcmwuZ2V0RmlsZUV4dGVuc2lvbihzcmMpO1xuICAgIGlmIChleHQpIHtcbiAgICAgIHJldHVybiBgdmlkZW8vJHtleHR9YDtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFzb3VyY2UudHlwZSkge1xuICAgIHR5cGUgPSBndWVzc01pbWVUeXBlKHNvdXJjZS5zcmMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmlwIGNvZGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgdHlwZSBiZWNhdXNlIHdlIGRvbid0IGdldCB0aGF0IHNwZWNpZmljXG4gICAgdHlwZSA9IHNvdXJjZS50eXBlLnJlcGxhY2UoLzsuKi8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgaWYgKHR5cGUgaW4gRmxhc2guZm9ybWF0cykge1xuICAgIHJldHVybiAnbWF5YmUnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBQYXNzIHRoZSBzb3VyY2UgdG8gdGhlIGZsYXNoIG9iamVjdFxuICogQWRhcHRpdmUgc291cmNlIGhhbmRsZXJzIHdpbGwgaGF2ZSBtb3JlIGNvbXBsaWNhdGVkIHdvcmtmbG93cyBiZWZvcmUgcGFzc2luZ1xuICogdmlkZW8gZGF0YSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0ZsYXNofSB0ZWNoICAgVGhlIGluc3RhbmNlIG9mIHRoZSBGbGFzaCB0ZWNoXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIuaGFuZGxlU291cmNlID0gZnVuY3Rpb24oc291cmNlLCB0ZWNoKXtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBzb3VyY2UgaGFuZGxlciB3aGVuIGRpc3Bvc2luZyB0aGUgcGxheWVyIG9yIHN3aXRjaGluZyBzb3VyY2VzLi5cbiAqIChubyBjbGVhbnVwIGlzIG5lZWRlZCB3aGVuIHN1cHBvcnRpbmcgdGhlIGZvcm1hdCBuYXRpdmVseSlcbiAqL1xuRmxhc2gubmF0aXZlU291cmNlSGFuZGxlci5kaXNwb3NlID0gZnVuY3Rpb24oKXt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5GbGFzaC5yZWdpc3RlclNvdXJjZUhhbmRsZXIoRmxhc2gubmF0aXZlU291cmNlSGFuZGxlcik7XG5cbkZsYXNoLmZvcm1hdHMgPSB7XG4gICd2aWRlby9mbHYnOiAnRkxWJyxcbiAgJ3ZpZGVvL3gtZmx2JzogJ0ZMVicsXG4gICd2aWRlby9tcDQnOiAnTVA0JyxcbiAgJ3ZpZGVvL200dic6ICdNUDQnXG59O1xuXG5GbGFzaC5vblJlYWR5ID0gZnVuY3Rpb24oY3VyclN3Zil7XG4gIGxldCBlbCA9IERvbS5lbChjdXJyU3dmKTtcbiAgbGV0IHRlY2ggPSBlbCAmJiBlbC50ZWNoO1xuXG4gIC8vIGlmIHRoZXJlIGlzIG5vIGVsIHRoZW4gdGhlIHRlY2ggaGFzIGJlZW4gZGlzcG9zZWRcbiAgLy8gYW5kIHRoZSB0ZWNoIGVsZW1lbnQgd2FzIHJlbW92ZWQgZnJvbSB0aGUgcGxheWVyIGRpdlxuICBpZiAodGVjaCAmJiB0ZWNoLmVsKCkpIHtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBmbGFzaCBvYmplY3QgaXMgcmVhbGx5IHJlYWR5XG4gICAgRmxhc2guY2hlY2tSZWFkeSh0ZWNoKTtcbiAgfVxufTtcblxuLy8gVGhlIFNXRiBpc24ndCBhbHdheXMgcmVhZHkgd2hlbiBpdCBzYXlzIGl0IGlzLiBTb21ldGltZXMgdGhlIEFQSSBmdW5jdGlvbnMgc3RpbGwgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgb2JqZWN0LlxuLy8gSWYgaXQncyBub3QgcmVhZHksIHdlIHNldCBhIHRpbWVvdXQgdG8gY2hlY2sgYWdhaW4gc2hvcnRseS5cbkZsYXNoLmNoZWNrUmVhZHkgPSBmdW5jdGlvbih0ZWNoKXtcbiAgLy8gc3RvcCB3b3JyeWluZyBpZiB0aGUgdGVjaCBoYXMgYmVlbiBkaXNwb3NlZFxuICBpZiAoIXRlY2guZWwoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIEFQSSBwcm9wZXJ0eSBleGlzdHNcbiAgaWYgKHRlY2guZWwoKS52anNfZ2V0UHJvcGVydHkpIHtcbiAgICAvLyB0ZWxsIHRlY2ggaXQncyByZWFkeVxuICAgIHRlY2gudHJpZ2dlclJlYWR5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2FpdCBsb25nZXJcbiAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIEZsYXNoWydjaGVja1JlYWR5J10odGVjaCk7XG4gICAgfSwgNTApO1xuICB9XG59O1xuXG4vLyBUcmlnZ2VyIGV2ZW50cyBmcm9tIHRoZSBzd2Ygb24gdGhlIHBsYXllclxuRmxhc2gub25FdmVudCA9IGZ1bmN0aW9uKHN3ZklELCBldmVudE5hbWUpe1xuICBsZXQgdGVjaCA9IERvbS5lbChzd2ZJRCkudGVjaDtcbiAgdGVjaC50cmlnZ2VyKGV2ZW50TmFtZSk7XG59O1xuXG4vLyBMb2cgZXJyb3JzIGZyb20gdGhlIHN3ZlxuRmxhc2gub25FcnJvciA9IGZ1bmN0aW9uKHN3ZklELCBlcnIpe1xuICBjb25zdCB0ZWNoID0gRG9tLmVsKHN3ZklEKS50ZWNoO1xuICBjb25zdCBtc2cgPSAnRkxBU0g6ICcrZXJyO1xuXG4gIGlmIChlcnIgPT09ICdzcmNub3Rmb3VuZCcpIHtcbiAgICB0ZWNoLnRyaWdnZXIoJ2Vycm9yJywgeyBjb2RlOiA0LCBtZXNzYWdlOiBtc2cgfSk7XG5cbiAgLy8gZXJyb3JzIHdlIGhhdmVuJ3QgY2F0ZWdvcml6ZWQgaW50byB0aGUgbWVkaWEgZXJyb3JzXG4gIH0gZWxzZSB7XG4gICAgdGVjaC50cmlnZ2VyKCdlcnJvcicsIG1zZyk7XG4gIH1cbn07XG5cbi8vIEZsYXNoIFZlcnNpb24gQ2hlY2tcbkZsYXNoLnZlcnNpb24gPSBmdW5jdGlvbigpe1xuICBsZXQgdmVyc2lvbiA9ICcwLDAsMCc7XG5cbiAgLy8gSUVcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uID0gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCdTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaCcpLkdldFZhcmlhYmxlKCckdmVyc2lvbicpLnJlcGxhY2UoL1xcRCsvZywgJywnKS5tYXRjaCgvXiw/KC4rKSw/JC8pWzFdO1xuXG4gIC8vIG90aGVyIGJyb3dzZXJzXG4gIH0gY2F0Y2goZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAobmF2aWdhdG9yLm1pbWVUeXBlc1snYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXS5lbmFibGVkUGx1Z2luKXtcbiAgICAgICAgdmVyc2lvbiA9IChuYXZpZ2F0b3IucGx1Z2luc1snU2hvY2t3YXZlIEZsYXNoIDIuMCddIHx8IG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2gnXSkuZGVzY3JpcHRpb24ucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV07XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHt9XG4gIH1cbiAgcmV0dXJuIHZlcnNpb24uc3BsaXQoJywnKTtcbn07XG5cbi8vIEZsYXNoIGVtYmVkZGluZyBtZXRob2QuIE9ubHkgdXNlZCBpbiBub24taWZyYW1lIG1vZGVcbkZsYXNoLmVtYmVkID0gZnVuY3Rpb24oc3dmLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcyl7XG4gIGNvbnN0IGNvZGUgPSBGbGFzaC5nZXRFbWJlZENvZGUoc3dmLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcyk7XG5cbiAgLy8gR2V0IGVsZW1lbnQgYnkgZW1iZWRkaW5nIGNvZGUgYW5kIHJldHJpZXZpbmcgY3JlYXRlZCBlbGVtZW50XG4gIGNvbnN0IG9iaiA9IERvbS5jcmVhdGVFbCgnZGl2JywgeyBpbm5lckhUTUw6IGNvZGUgfSkuY2hpbGROb2Rlc1swXTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuRmxhc2guZ2V0RW1iZWRDb2RlID0gZnVuY3Rpb24oc3dmLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcyl7XG4gIGNvbnN0IG9ialRhZyA9ICc8b2JqZWN0IHR5cGU9XCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiICc7XG4gIGxldCBmbGFzaFZhcnNTdHJpbmcgPSAnJztcbiAgbGV0IHBhcmFtc1N0cmluZyA9ICcnO1xuICBsZXQgYXR0cnNTdHJpbmcgPSAnJztcblxuICAvLyBDb252ZXJ0IGZsYXNoIHZhcnMgdG8gc3RyaW5nXG4gIGlmIChmbGFzaFZhcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmbGFzaFZhcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcbiAgICAgIGZsYXNoVmFyc1N0cmluZyArPSBgJHtrZXl9PSR7Zmxhc2hWYXJzW2tleV19JmFtcDtgO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIHN3ZiwgZmxhc2hWYXJzLCBhbmQgb3RoZXIgZGVmYXVsdCBwYXJhbXNcbiAgcGFyYW1zID0gYXNzaWduKHtcbiAgICAnbW92aWUnOiBzd2YsXG4gICAgJ2ZsYXNodmFycyc6IGZsYXNoVmFyc1N0cmluZyxcbiAgICAnYWxsb3dTY3JpcHRBY2Nlc3MnOiAnYWx3YXlzJywgLy8gUmVxdWlyZWQgdG8gdGFsayB0byBzd2ZcbiAgICAnYWxsb3dOZXR3b3JraW5nJzogJ2FsbCcgLy8gQWxsIHNob3VsZCBiZSBkZWZhdWx0LCBidXQgaGF2aW5nIHNlY3VyaXR5IGlzc3Vlcy5cbiAgfSwgcGFyYW1zKTtcblxuICAvLyBDcmVhdGUgcGFyYW0gdGFncyBzdHJpbmdcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgcGFyYW1zU3RyaW5nICs9IGA8cGFyYW0gbmFtZT1cIiR7a2V5fVwiIHZhbHVlPVwiJHtwYXJhbXNba2V5XX1cIiAvPmA7XG4gIH0pO1xuXG4gIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgIC8vIEFkZCBzd2YgdG8gYXR0cmlidXRlcyAobmVlZCBib3RoIGZvciBJRSBhbmQgT3RoZXJzIHRvIHdvcmspXG4gICAgJ2RhdGEnOiBzd2YsXG5cbiAgICAvLyBEZWZhdWx0IHRvIDEwMCUgd2lkdGgvaGVpZ2h0XG4gICAgJ3dpZHRoJzogJzEwMCUnLFxuICAgICdoZWlnaHQnOiAnMTAwJSdcblxuICB9LCBhdHRyaWJ1dGVzKTtcblxuICAvLyBDcmVhdGUgQXR0cmlidXRlcyBzdHJpbmdcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgIGF0dHJzU3RyaW5nICs9IGAke2tleX09XCIke2F0dHJpYnV0ZXNba2V5XX1cIiBgO1xuICB9KTtcblxuICByZXR1cm4gYCR7b2JqVGFnfSR7YXR0cnNTdHJpbmd9PiR7cGFyYW1zU3RyaW5nfTwvb2JqZWN0PmA7XG59O1xuXG4vLyBSdW4gRmxhc2ggdGhyb3VnaCB0aGUgUlRNUCBkZWNvcmF0b3JcbkZsYXNoUnRtcERlY29yYXRvcihGbGFzaCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRmxhc2gnLCBGbGFzaCk7XG5leHBvcnQgZGVmYXVsdCBGbGFzaDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBIVE1MNSBNZWRpYSBDb250cm9sbGVyIC0gV3JhcHBlciBmb3IgSFRNTDUgTWVkaWEgQVBJXG4gKi9cblxuaW1wb3J0IFRlY2ggZnJvbSAnLi90ZWNoLmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCAqIGFzIERvbSBmcm9tICcuLi91dGlscy9kb20uanMnO1xuaW1wb3J0ICogYXMgVXJsIGZyb20gJy4uL3V0aWxzL3VybC5qcyc7XG5pbXBvcnQgKiBhcyBGbiBmcm9tICcuLi91dGlscy9mbi5qcyc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL3V0aWxzL2xvZy5qcyc7XG5pbXBvcnQgKiBhcyBicm93c2VyIGZyb20gJy4uL3V0aWxzL2Jyb3dzZXIuanMnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QuYXNzaWduJztcbmltcG9ydCBtZXJnZU9wdGlvbnMgZnJvbSAnLi4vdXRpbHMvbWVyZ2Utb3B0aW9ucy5qcyc7XG5cbi8qKlxuICogSFRNTDUgTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIEhUTUw1IE1lZGlhIEFQSVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgSHRtbDUgZXh0ZW5kcyBUZWNoIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZWFkeSl7XG4gICAgc3VwZXIob3B0aW9ucywgcmVhZHkpO1xuXG4gICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XG5cbiAgICAvLyBTZXQgdGhlIHNvdXJjZSBpZiBvbmUgaXMgcHJvdmlkZWRcbiAgICAvLyAxKSBDaGVjayBpZiB0aGUgc291cmNlIGlzIG5ldyAoaWYgbm90LCB3ZSB3YW50IHRvIGtlZXAgdGhlIG9yaWdpbmFsIHNvIHBsYXliYWNrIGlzbid0IGludGVycnVwdGVkKVxuICAgIC8vIDIpIENoZWNrIHRvIHNlZSBpZiB0aGUgbmV0d29yayBzdGF0ZSBvZiB0aGUgdGFnIHdhcyBmYWlsZWQgYXQgaW5pdCwgYW5kIGlmIHNvLCByZXNldCB0aGUgc291cmNlXG4gICAgLy8gYW55d2F5IHNvIHRoZSBlcnJvciBnZXRzIGZpcmVkLlxuICAgIGlmIChzb3VyY2UgJiYgKHRoaXMuZWxfLmN1cnJlbnRTcmMgIT09IHNvdXJjZS5zcmMgfHwgKG9wdGlvbnMudGFnICYmIG9wdGlvbnMudGFnLmluaXROZXR3b3JrU3RhdGVfID09PSAzKSkpIHtcbiAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxfLmhhc0NoaWxkTm9kZXMoKSkge1xuXG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLmVsXy5jaGlsZE5vZGVzO1xuICAgICAgbGV0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICAgICAgbGV0IHJlbW92ZU5vZGVzID0gW107XG5cbiAgICAgIHdoaWxlIChub2Rlc0xlbmd0aC0tKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbbm9kZXNMZW5ndGhdO1xuICAgICAgICBsZXQgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgIGlmICghdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IHZpZGVvIHRhZyB0cmFja3Mgc28gdGhlIGJ1aWx0LWluIHBsYXllciBkb2Vzbid0IHVzZSB0aGVtIGFsc28uXG4gICAgICAgICAgICAvLyBUaGlzIG1heSBub3QgYmUgZmFzdCBlbm91Z2ggdG8gc3RvcCBIVE1MNSBicm93c2VycyBmcm9tIHJlYWRpbmcgdGhlIHRhZ3NcbiAgICAgICAgICAgIC8vIHNvIHdlJ2xsIG5lZWQgdG8gdHVybiBvZmYgYW55IGRlZmF1bHQgdHJhY2tzIGlmIHdlJ3JlIG1hbnVhbGx5IGRvaW5nXG4gICAgICAgICAgICAvLyBjYXB0aW9ucyBhbmQgc3VidGl0bGVzLiB2aWRlb0VsZW1lbnQudGV4dFRyYWNrc1xuICAgICAgICAgICAgcmVtb3ZlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2tfKG5vZGUudHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpPTA7IGk8cmVtb3ZlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbF8ucmVtb3ZlQ2hpbGQocmVtb3ZlTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgdGhpcy5vbignbG9hZHN0YXJ0JywgRm4uYmluZCh0aGlzLCB0aGlzLmhpZGVDYXB0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHVzZWRcbiAgICAvLyBPdXIgZ29hbCBzaG91bGQgYmUgdG8gZ2V0IHRoZSBjdXN0b20gY29udHJvbHMgb24gbW9iaWxlIHNvbGlkIGV2ZXJ5d2hlcmVcbiAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoaXMgYWxsIHRvZ2V0aGVyLiBSaWdodCBub3cgdGhpcyB3aWxsIGJsb2NrIGN1c3RvbVxuICAgIC8vIGNvbnRyb2xzIG9uIHRvdWNoIGVuYWJsZWQgbGFwdG9wcyBsaWtlIHRoZSBDaHJvbWUgUGl4ZWxcbiAgICBpZiAoYnJvd3Nlci5UT1VDSF9FTkFCTEVEICYmIG9wdGlvbnMubmF0aXZlQ29udHJvbHNGb3JUb3VjaCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy50cmlnZ2VyKCd1c2VuYXRpdmVjb250cm9scycpO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlclJlYWR5KCk7XG4gIH1cblxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLmVsXyk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gdGhpcy5vcHRpb25zXy50YWc7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgbW92aW5nIHRoZSBlbGVtZW50IGludG8gdGhlIGJveC5cbiAgICAvLyBPbiB0aGUgaVBob25lIHZpZGVvIHdpbGwgYnJlYWsgaWYgeW91IG1vdmUgdGhlIGVsZW1lbnQsXG4gICAgLy8gU28gd2UgaGF2ZSB0byBjcmVhdGUgYSBicmFuZCBuZXcgZWxlbWVudC5cbiAgICBpZiAoIWVsIHx8IHRoaXNbJ21vdmluZ01lZGlhRWxlbWVudEluRE9NJ10gPT09IGZhbHNlKSB7XG5cbiAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCB0YWcgaXMgc3RpbGwgdGhlcmUsIGNsb25lIGFuZCByZW1vdmUgaXQuXG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KGVsKTtcbiAgICAgICAgZWwgPSBjbG9uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSB1c2VkXG4gICAgICAgIGxldCB0YWdBdHRyaWJ1dGVzID0gdGhpcy5vcHRpb25zXy50YWcgJiYgRG9tLmdldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMub3B0aW9uc18udGFnKTtcbiAgICAgICAgbGV0IGF0dHJpYnV0ZXMgPSBtZXJnZU9wdGlvbnMoe30sIHRhZ0F0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoIWJyb3dzZXIuVE9VQ0hfRU5BQkxFRCB8fCB0aGlzLm9wdGlvbnNfLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2ggIT09IHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5jb250cm9scztcbiAgICAgICAgfVxuXG4gICAgICAgIERvbS5zZXRFbGVtZW50QXR0cmlidXRlcyhlbCxcbiAgICAgICAgICBhc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9uc18ucGxheWVySWQgKyAnX2h0bWw1X2FwaScsXG4gICAgICAgICAgICBjbGFzczogJ3Zqcy10ZWNoJ1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnRyYWNrcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3B0aW9uc18udHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLm9wdGlvbnNfLnRyYWNrc1tpXTtcbiAgICAgICAgICBsZXQgdHJhY2tFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgdHJhY2tFbC5raW5kID0gdHJhY2sua2luZDtcbiAgICAgICAgICB0cmFja0VsLmxhYmVsID0gdHJhY2subGFiZWw7XG4gICAgICAgICAgdHJhY2tFbC5zcmNsYW5nID0gdHJhY2suc3JjbGFuZztcbiAgICAgICAgICB0cmFja0VsLnNyYyA9IHRyYWNrLnNyYztcbiAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIHRyYWNrKSB7XG4gICAgICAgICAgICB0cmFja0VsLnNldEF0dHJpYnV0ZSgnZGVmYXVsdCcsICdkZWZhdWx0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHRyYWNrRWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNwZWNpZmljIHRhZyBzZXR0aW5ncywgaW4gY2FzZSB0aGV5IHdlcmUgb3ZlcnJpZGRlblxuICAgIGxldCBzZXR0aW5nc0F0dHJzID0gWydhdXRvcGxheScsJ3ByZWxvYWQnLCdsb29wJywnbXV0ZWQnXTtcbiAgICBmb3IgKGxldCBpID0gc2V0dGluZ3NBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgYXR0ciA9IHNldHRpbmdzQXR0cnNbaV07XG4gICAgICBsZXQgb3ZlcndyaXRlQXR0cnMgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zX1thdHRyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3ZlcndyaXRlQXR0cnNbYXR0cl0gPSB0aGlzLm9wdGlvbnNfW2F0dHJdO1xuICAgICAgfVxuICAgICAgRG9tLnNldEVsZW1lbnRBdHRyaWJ1dGVzKGVsLCBvdmVyd3JpdGVBdHRycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICAgIC8vIGplbm5paXNhd2Vzb21lID0gdHJ1ZTtcbiAgfVxuXG5cbiAgaGlkZUNhcHRpb25zKCkge1xuICAgIGxldCB0cmFja3MgPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yQWxsKCd0cmFjaycpO1xuICAgIGxldCBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICBjb25zdCBraW5kcyA9IHtcbiAgICAgICdjYXB0aW9ucyc6IDEsXG4gICAgICAnc3VidGl0bGVzJzogMVxuICAgIH07XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV0udHJhY2s7XG4gICAgICBpZiAoKHRyYWNrICYmIHRyYWNrWydraW5kJ10gaW4ga2luZHMpICYmXG4gICAgICAgICAgKCF0cmFja3NbaV1bJ2RlZmF1bHQnXSkpIHtcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGxheSgpIHsgdGhpcy5lbF8ucGxheSgpOyB9XG4gIHBhdXNlKCkgeyB0aGlzLmVsXy5wYXVzZSgpOyB9XG4gIHBhdXNlZCgpIHsgcmV0dXJuIHRoaXMuZWxfLnBhdXNlZDsgfVxuXG4gIGN1cnJlbnRUaW1lKCkgeyByZXR1cm4gdGhpcy5lbF8uY3VycmVudFRpbWU7IH1cbiAgc2V0Q3VycmVudFRpbWUoc2Vjb25kcykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVsXy5jdXJyZW50VGltZSA9IHNlY29uZHM7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBsb2coZSwgJ1ZpZGVvIGlzIG5vdCByZWFkeS4gKFZpZGVvLmpzKScpO1xuICAgICAgLy8gdGhpcy53YXJuaW5nKFZpZGVvSlMud2FybmluZ3MudmlkZW9Ob3RSZWFkeSk7XG4gICAgfVxuICB9XG5cbiAgZHVyYXRpb24oKSB7IHJldHVybiB0aGlzLmVsXy5kdXJhdGlvbiB8fCAwOyB9XG5cbiAgYnVmZmVyZWQoKSB7IHJldHVybiB0aGlzLmVsXy5idWZmZXJlZDsgfVxuXG4gIHZvbHVtZSgpIHsgcmV0dXJuIHRoaXMuZWxfLnZvbHVtZTsgfVxuICBzZXRWb2x1bWUocGVyY2VudEFzRGVjaW1hbCkgeyB0aGlzLmVsXy52b2x1bWUgPSBwZXJjZW50QXNEZWNpbWFsOyB9XG5cbiAgbXV0ZWQoKSB7IHJldHVybiB0aGlzLmVsXy5tdXRlZDsgfVxuICBzZXRNdXRlZChtdXRlZCkgeyB0aGlzLmVsXy5tdXRlZCA9IG11dGVkOyB9XG5cbiAgd2lkdGgoKSB7IHJldHVybiB0aGlzLmVsXy5vZmZzZXRXaWR0aDsgfVxuICBoZWlnaHQoKSB7ICByZXR1cm4gdGhpcy5lbF8ub2Zmc2V0SGVpZ2h0OyB9XG5cbiAgc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbF8ud2Via2l0RW50ZXJGdWxsU2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsZXQgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAvLyBTZWVtcyB0byBiZSBicm9rZW4gaW4gQ2hyb21pdW0vQ2hyb21lICYmIFNhZmFyaSBpbiBMZW9wYXJkXG4gICAgICBpZiAoL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KSB8fCAhL0Nocm9tZXxNYWMgT1MgWCAxMC41Ly50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGVudGVyRnVsbFNjcmVlbigpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLmVsXztcblxuICAgIGlmICgnd2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4nIGluIHZpZGVvKSB7XG4gICAgICB0aGlzLm9uZSgnd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub25lKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHZpZGVvLnBhdXNlZCAmJiB2aWRlby5uZXR3b3JrU3RhdGUgPD0gdmlkZW8uSEFWRV9NRVRBREFUQSkge1xuICAgICAgLy8gYXR0ZW1wdCB0byBwcmltZSB0aGUgdmlkZW8gZWxlbWVudCBmb3IgcHJvZ3JhbW1hdGljIGFjY2Vzc1xuICAgICAgLy8gdGhpcyBpc24ndCBuZWNlc3Nhcnkgb24gdGhlIGRlc2t0b3AgYnV0IHNob3VsZG4ndCBodXJ0XG4gICAgICB0aGlzLmVsXy5wbGF5KCk7XG5cbiAgICAgIC8vIHBsYXlpbmcgYW5kIHBhdXNpbmcgc3luY2hyb25vdXNseSBkdXJpbmcgdGhlIHRyYW5zaXRpb24gdG8gZnVsbHNjcmVlblxuICAgICAgLy8gY2FuIGdldCBpT1MgfjYuMSBkZXZpY2VzIGludG8gYSBwbGF5L3BhdXNlIGxvb3BcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICB9XG4gIH1cblxuICBleGl0RnVsbFNjcmVlbigpIHtcbiAgICB0aGlzLmVsXy53ZWJraXRFeGl0RnVsbFNjcmVlbigpO1xuICB9XG5cbiAgc3JjKHNyYykge1xuICAgIGlmIChzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxfLnNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dGluZyBzcmMgdGhyb3VnaCBgc3JjYCBpbnN0ZWFkIG9mIGBzZXRTcmNgIHdpbGwgYmUgZGVwcmVjYXRlZFxuICAgICAgdGhpcy5zZXRTcmMoc3JjKTtcbiAgICB9XG4gIH1cblxuICBzZXRTcmMoc3JjKSB7IHRoaXMuZWxfLnNyYyA9IHNyYzsgfVxuXG4gIGxvYWQoKXsgdGhpcy5lbF8ubG9hZCgpOyB9XG5cbiAgY3VycmVudFNyYygpIHsgcmV0dXJuIHRoaXMuZWxfLmN1cnJlbnRTcmM7IH1cblxuICBwb3N0ZXIoKSB7IHJldHVybiB0aGlzLmVsXy5wb3N0ZXI7IH1cbiAgc2V0UG9zdGVyKHZhbCkgeyB0aGlzLmVsXy5wb3N0ZXIgPSB2YWw7IH1cblxuICBwcmVsb2FkKCkgeyByZXR1cm4gdGhpcy5lbF8ucHJlbG9hZDsgfVxuICBzZXRQcmVsb2FkKHZhbCkgeyB0aGlzLmVsXy5wcmVsb2FkID0gdmFsOyB9XG5cbiAgYXV0b3BsYXkoKSB7IHJldHVybiB0aGlzLmVsXy5hdXRvcGxheTsgfVxuICBzZXRBdXRvcGxheSh2YWwpIHsgdGhpcy5lbF8uYXV0b3BsYXkgPSB2YWw7IH1cblxuICBjb250cm9scygpIHsgcmV0dXJuIHRoaXMuZWxfLmNvbnRyb2xzOyB9XG4gIHNldENvbnRyb2xzKHZhbCkgeyB0aGlzLmVsXy5jb250cm9scyA9ICEhdmFsOyB9XG5cbiAgbG9vcCgpIHsgcmV0dXJuIHRoaXMuZWxfLmxvb3A7IH1cbiAgc2V0TG9vcCh2YWwpIHsgdGhpcy5lbF8ubG9vcCA9IHZhbDsgfVxuXG4gIGVycm9yKCkgeyByZXR1cm4gdGhpcy5lbF8uZXJyb3I7IH1cbiAgc2Vla2luZygpIHsgcmV0dXJuIHRoaXMuZWxfLnNlZWtpbmc7IH1cbiAgZW5kZWQoKSB7IHJldHVybiB0aGlzLmVsXy5lbmRlZDsgfVxuICBkZWZhdWx0TXV0ZWQoKSB7IHJldHVybiB0aGlzLmVsXy5kZWZhdWx0TXV0ZWQ7IH1cblxuICBwbGF5YmFja1JhdGUoKSB7IHJldHVybiB0aGlzLmVsXy5wbGF5YmFja1JhdGU7IH1cbiAgc2V0UGxheWJhY2tSYXRlKHZhbCkgeyB0aGlzLmVsXy5wbGF5YmFja1JhdGUgPSB2YWw7IH1cblxuICBuZXR3b3JrU3RhdGUoKSB7IHJldHVybiB0aGlzLmVsXy5uZXR3b3JrU3RhdGU7IH1cbiAgcmVhZHlTdGF0ZSgpIHsgcmV0dXJuIHRoaXMuZWxfLnJlYWR5U3RhdGU7IH1cblxuICB2aWRlb1dpZHRoKCkgeyByZXR1cm4gdGhpcy5lbF8udmlkZW9XaWR0aDsgfVxuICB2aWRlb0hlaWdodCgpIHsgcmV0dXJuIHRoaXMuZWxfLnZpZGVvSGVpZ2h0OyB9XG5cbiAgdGV4dFRyYWNrcygpIHtcbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICByZXR1cm4gc3VwZXIudGV4dFRyYWNrcygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsXy50ZXh0VHJhY2tzO1xuICB9XG4gIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICByZXR1cm4gc3VwZXIuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWxfLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9XG5cbiAgYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnM9e30pIHtcbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICByZXR1cm4gc3VwZXIuYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG5cbiAgICBpZiAob3B0aW9uc1sna2luZCddKSB7XG4gICAgICB0cmFja1sna2luZCddID0gb3B0aW9uc1sna2luZCddO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snbGFiZWwnXSkge1xuICAgICAgdHJhY2tbJ2xhYmVsJ10gPSBvcHRpb25zWydsYWJlbCddO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snbGFuZ3VhZ2UnXSB8fCBvcHRpb25zWydzcmNsYW5nJ10pIHtcbiAgICAgIHRyYWNrWydzcmNsYW5nJ10gPSBvcHRpb25zWydsYW5ndWFnZSddIHx8IG9wdGlvbnNbJ3NyY2xhbmcnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2RlZmF1bHQnXSkge1xuICAgICAgdHJhY2tbJ2RlZmF1bHQnXSA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2lkJ10pIHtcbiAgICAgIHRyYWNrWydpZCddID0gb3B0aW9uc1snaWQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ3NyYyddKSB7XG4gICAgICB0cmFja1snc3JjJ10gPSBvcHRpb25zWydzcmMnXTtcbiAgICB9XG5cbiAgICB0aGlzLmVsKCkuYXBwZW5kQ2hpbGQodHJhY2spO1xuXG4gICAgaWYgKHRyYWNrLnRyYWNrWydraW5kJ10gPT09ICdtZXRhZGF0YScpIHtcbiAgICAgIHRyYWNrWyd0cmFjayddWydtb2RlJ10gPSAnaGlkZGVuJztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2tbJ3RyYWNrJ11bJ21vZGUnXSA9ICdkaXNhYmxlZCc7XG4gICAgfVxuXG4gICAgdHJhY2tbJ29ubG9hZCddID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHQgPSB0cmFja1sndHJhY2snXTtcbiAgICAgIGlmICh0cmFjay5yZWFkeVN0YXRlID49IDIpIHtcbiAgICAgICAgaWYgKHR0WydraW5kJ10gPT09ICdtZXRhZGF0YScgJiYgdHRbJ21vZGUnXSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICB0dFsnbW9kZSddID0gJ2hpZGRlbic7XG4gICAgICAgIH0gZWxzZSBpZiAodHRbJ2tpbmQnXSAhPT0gJ21ldGFkYXRhJyAmJiB0dFsnbW9kZSddICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgdHRbJ21vZGUnXSA9ICdkaXNhYmxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tbJ29ubG9hZCddID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2tfKHRyYWNrLnRyYWNrKTtcblxuICAgIHJldHVybiB0cmFjaztcbiAgfVxuXG4gIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIGlmICghdGhpc1snZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10pIHtcbiAgICAgIHJldHVybiBzdXBlci5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgIH1cblxuICAgIHZhciB0cmFja3MsIGk7XG5cbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5yZW1vdmVUcmFja18odHJhY2spO1xuXG4gICAgdHJhY2tzID0gdGhpcy5lbCgpWydxdWVyeVNlbGVjdG9yQWxsJ10oJ3RyYWNrJyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tzW2ldID09PSB0cmFjayB8fCB0cmFja3NbaV1bJ3RyYWNrJ10gPT09IHRyYWNrKSB7XG4gICAgICAgIHRyYWNrc1tpXVsncGFyZW50Tm9kZSddWydyZW1vdmVDaGlsZCddKHRyYWNrc1tpXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cblxuLyogSFRNTDUgU3VwcG9ydCBUZXN0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqXG4gKiBFbGVtZW50IGZvciB0ZXN0aW5nIGJyb3dzZXIgSFRNTDUgdmlkZW8gY2FwYWJpbGl0aWVzXG4gKiBAdHlwZSB7RWxlbWVudH1cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xuSHRtbDUuVEVTVF9WSUQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xubGV0IHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcbnRyYWNrLmtpbmQgPSAnY2FwdGlvbnMnO1xudHJhY2suc3JjbGFuZyA9ICdlbic7XG50cmFjay5sYWJlbCA9ICdFbmdsaXNoJztcbkh0bWw1LlRFU1RfVklELmFwcGVuZENoaWxkKHRyYWNrKTtcblxuLyoqXG4gKiBDaGVjayBpZiBIVE1MNSB2aWRlbyBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpe1xuICAvLyBJRTkgd2l0aCBubyBNZWRpYSBQbGF5ZXIgaXMgYSBMSUFSISAoIzk4NClcbiAgdHJ5IHtcbiAgICBIdG1sNS5URVNUX1ZJRFsndm9sdW1lJ10gPSAwLjU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISFIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZTtcbn07XG5cbi8vIEFkZCBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuIGZ1bmN0aW9ucyB0byB0aGlzIHRlY2hcblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzKEh0bWw1KTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBuYXRpdmUgc291cmNlIGhhbmRsZXIuXG4gKiBUaGlzIHNpbXBseSBwYXNzZXMgdGhlIHNvdXJjZSB0byB0aGUgdmlkZW8gZWxlbWVudC4gTm90aGluZyBmYW5jeS5cbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0h0bWw1fSB0ZWNoICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEhUTUw1IHRlY2hcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlciA9IHt9O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2aWRlbyBlbGVtZW50IGNhbiBoYW5kbGUgdGhlIHNvdXJjZSBuYXRpdmVseVxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2Upe1xuICB2YXIgbWF0Y2gsIGV4dDtcblxuICBmdW5jdGlvbiBjYW5QbGF5VHlwZSh0eXBlKXtcbiAgICAvLyBJRTkgb24gV2luZG93cyA3IHdpdGhvdXQgTWVkaWFQbGF5ZXIgdGhyb3dzIGFuIGVycm9yIGhlcmVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvNTE5XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhIHR5cGUgd2FzIHByb3ZpZGVkIHdlIHNob3VsZCByZWx5IG9uIHRoYXRcbiAgaWYgKHNvdXJjZS50eXBlKSB7XG4gICAgcmV0dXJuIGNhblBsYXlUeXBlKHNvdXJjZS50eXBlKTtcbiAgfSBlbHNlIGlmIChzb3VyY2Uuc3JjKSB7XG4gICAgLy8gSWYgbm8gdHlwZSwgZmFsbCBiYWNrIHRvIGNoZWNraW5nICd2aWRlby9bRVhURU5TSU9OXSdcbiAgICBleHQgPSBVcmwuZ2V0RmlsZUV4dGVuc2lvbihzb3VyY2Uuc3JjKTtcblxuICAgIHJldHVybiBjYW5QbGF5VHlwZShgdmlkZW8vJHtleHR9YCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICogQWRhcHRpdmUgc291cmNlIGhhbmRsZXJzIHdpbGwgaGF2ZSBtb3JlIGNvbXBsaWNhdGVkIHdvcmtmbG93cyBiZWZvcmUgcGFzc2luZ1xuICogdmlkZW8gZGF0YSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0h0bWw1fSB0ZWNoICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIdG1sNSB0ZWNoXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuaGFuZGxlU291cmNlID0gZnVuY3Rpb24oc291cmNlLCB0ZWNoKXtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBzb3VyY2UgaGFuZGxlciB3aGVuIGRpc3Bvc2luZyB0aGUgcGxheWVyIG9yIHN3aXRjaGluZyBzb3VyY2VzLi5cbiAqIChubyBjbGVhbnVwIGlzIG5lZWRlZCB3aGVuIHN1cHBvcnRpbmcgdGhlIGZvcm1hdCBuYXRpdmVseSlcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5kaXNwb3NlID0gZnVuY3Rpb24oKXt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5IdG1sNS5yZWdpc3RlclNvdXJjZUhhbmRsZXIoSHRtbDUubmF0aXZlU291cmNlSGFuZGxlcik7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZvbHVtZSBjYW4gYmUgY2hhbmdlZCBpbiB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICogVm9sdW1lIGNhbm5vdCBiZSBjaGFuZ2VkIGluIGEgbG90IG9mIG1vYmlsZSBkZXZpY2VzLlxuICogU3BlY2lmaWNhbGx5LCBpdCBjYW4ndCBiZSBjaGFuZ2VkIGZyb20gMSBvbiBpT1MuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5IdG1sNS5jYW5Db250cm9sVm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgdmFyIHZvbHVtZSA9ICBIdG1sNS5URVNUX1ZJRC52b2x1bWU7XG4gIEh0bWw1LlRFU1RfVklELnZvbHVtZSA9ICh2b2x1bWUgLyAyKSArIDAuMTtcbiAgcmV0dXJuIHZvbHVtZSAhPT0gSHRtbDUuVEVTVF9WSUQudm9sdW1lO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBwbGF5YmFja1JhdGUgaXMgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwbGF5YmFja1JhdGUgPSBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XG4gIEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZSA9IChwbGF5YmFja1JhdGUgLyAyKSArIDAuMTtcbiAgcmV0dXJuIHBsYXliYWNrUmF0ZSAhPT0gSHRtbDUuVEVTVF9WSUQucGxheWJhY2tSYXRlO1xufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIHRleHQgdHJhY2tzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdXBwb3J0c1RleHRUcmFja3M7XG5cbiAgLy8gRmlndXJlIG91dCBuYXRpdmUgdGV4dCB0cmFjayBzdXBwb3J0XG4gIC8vIElmIG1vZGUgaXMgYSBudW1iZXIsIHdlIGNhbm5vdCBjaGFuZ2UgaXQgYmVjYXVzZSBpdCdsbCBkaXNhcHBlYXIgZnJvbSB2aWV3LlxuICAvLyBCcm93c2VycyB3aXRoIG51bWVyaWMgbW9kZXMgaW5jbHVkZSBJRTEwIGFuZCBvbGRlciAoPD0yMDEzKSBzYW1zdW5nIGFuZHJvaWQgbW9kZWxzLlxuICAvLyBGaXJlZm94IGlzbid0IHBsYXlpbmcgbmljZSBlaXRoZXIgd2l0aCBtb2RpZnlpbmcgdGhlIG1vZGVcbiAgLy8gVE9ETzogSW52ZXN0aWdhdGUgZmlyZWZveDogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzE4NjJcbiAgc3VwcG9ydHNUZXh0VHJhY2tzID0gISFIdG1sNS5URVNUX1ZJRC50ZXh0VHJhY2tzO1xuICBpZiAoc3VwcG9ydHNUZXh0VHJhY2tzICYmIEh0bWw1LlRFU1RfVklELnRleHRUcmFja3MubGVuZ3RoID4gMCkge1xuICAgIHN1cHBvcnRzVGV4dFRyYWNrcyA9IHR5cGVvZiBIdG1sNS5URVNUX1ZJRC50ZXh0VHJhY2tzWzBdWydtb2RlJ10gIT09ICdudW1iZXInO1xuICB9XG4gIGlmIChzdXBwb3J0c1RleHRUcmFja3MgJiYgYnJvd3Nlci5JU19GSVJFRk9YKSB7XG4gICAgc3VwcG9ydHNUZXh0VHJhY2tzID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3VwcG9ydHNUZXh0VHJhY2tzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRlY2gncyB2b2x1bWUgY29udHJvbCBzdXBwb3J0IHN0YXR1c1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPSBIdG1sNS5jYW5Db250cm9sVm9sdW1lKCk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZWNoJ3MgcGxheWJhY2tSYXRlIHN1cHBvcnQgc3RhdHVzXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUucHJvdG90eXBlWydmZWF0dXJlc1BsYXliYWNrUmF0ZSddID0gSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSgpO1xuXG4vKipcbiAqIFNldCB0aGUgdGVjaCdzIHN0YXR1cyBvbiBtb3ZpbmcgdGhlIHZpZGVvIGVsZW1lbnQuXG4gKiBJbiBpT1MsIGlmIHlvdSBtb3ZlIGEgdmlkZW8gZWxlbWVudCBpbiB0aGUgRE9NLCBpdCBicmVha3MgdmlkZW8gcGxheWJhY2suXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUucHJvdG90eXBlWydtb3ZpbmdNZWRpYUVsZW1lbnRJbkRPTSddID0gIWJyb3dzZXIuSVNfSU9TO1xuXG4vKipcbiAqIFNldCB0aGUgdGhlIHRlY2gncyBmdWxsc2NyZWVuIHJlc2l6ZSBzdXBwb3J0IHN0YXR1cy5cbiAqIEhUTUwgdmlkZW8gaXMgYWJsZSB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB3aGVuIGdvaW5nIHRvIGZ1bGxzY3JlZW4uXG4gKiAoTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuKVxuICovXG5IdG1sNS5wcm90b3R5cGVbJ2ZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSddID0gdHJ1ZTtcblxuLyoqXG4gKiBTZXQgdGhlIHRlY2gncyBwcm9ncmVzcyBldmVudCBzdXBwb3J0IHN0YXR1c1xuICogKHRoaXMgZGlzYWJsZXMgdGhlIG1hbnVhbCBwcm9ncmVzcyBldmVudHMgb2YgdGhlIFRlY2gpXG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNQcm9ncmVzc0V2ZW50cyddID0gdHJ1ZTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0ZWNoJ3Mgc3RhdHVzIG9uIG5hdGl2ZSB0ZXh0IHRyYWNrIHN1cHBvcnRcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IdG1sNS5wcm90b3R5cGVbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzKCk7XG5cbi8vIEhUTUw1IEZlYXR1cmUgZGV0ZWN0aW9uIGFuZCBEZXZpY2UgRml4ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5sZXQgY2FuUGxheVR5cGU7XG5jb25zdCBtcGVndXJsUkUgPSAvXmFwcGxpY2F0aW9uXFwvKD86eC18dm5kXFwuYXBwbGVcXC4pbXBlZ3VybC9pO1xuY29uc3QgbXA0UkUgPSAvXnZpZGVvXFwvbXA0L2k7XG5cbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gQW5kcm9pZCA0LjAgYW5kIGFib3ZlIGNhbiBwbGF5IEhMUyB0byBzb21lIGV4dGVudCBidXQgaXQgcmVwb3J0cyBiZWluZyB1bmFibGUgdG8gZG8gc29cbiAgaWYgKGJyb3dzZXIuQU5EUk9JRF9WRVJTSU9OID49IDQuMCkge1xuICAgIGlmICghY2FuUGxheVR5cGUpIHtcbiAgICAgIGNhblBsYXlUeXBlID0gSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xuICAgIH1cblxuICAgIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wZWd1cmxSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIEFuZHJvaWQgMi4yIGFuZCBsZXNzIGNhblBsYXlUeXBlIG1ldGhvZCB3aGljaCBpcyBicm9rZW5cbiAgaWYgKGJyb3dzZXIuSVNfT0xEX0FORFJPSUQpIHtcbiAgICBpZiAoIWNhblBsYXlUeXBlKSB7XG4gICAgICBjYW5QbGF5VHlwZSA9IEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcbiAgICB9XG5cbiAgICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgICAgIGlmICh0eXBlICYmIG1wNFJFLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuUGxheVR5cGUuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICB9O1xuICB9XG59O1xuXG5IdG1sNS51bnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHIgPSBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGU7XG4gIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGNhblBsYXlUeXBlO1xuICBjYW5QbGF5VHlwZSA9IG51bGw7XG4gIHJldHVybiByO1xufTtcblxuLy8gYnkgZGVmYXVsdCwgcGF0Y2ggdGhlIHZpZGVvIGVsZW1lbnRcbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUoKTtcblxuSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uKGVsKXtcbiAgaWYgKCFlbCkgeyByZXR1cm47IH1cblxuICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBjaGlsZCB0cmFjayBvciBzb3VyY2Ugbm9kZXMgdG8gcHJldmVudCB0aGVpciBsb2FkaW5nXG4gIHdoaWxlKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBzcmMgcmVmZXJlbmNlLiBub3Qgc2V0dGluZyBgc3JjPScnYCBiZWNhdXNlIHRoYXQgY2F1c2VzIGEgd2FybmluZ1xuICAvLyBpbiBmaXJlZm94XG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cbiAgLy8gZm9yY2UgdGhlIG1lZGlhIGVsZW1lbnQgdG8gdXBkYXRlIGl0cyBsb2FkaW5nIHN0YXRlIGJ5IGNhbGxpbmcgbG9hZCgpXG4gIC8vIGhvd2V2ZXIgSUUgb24gV2luZG93cyA3TiBoYXMgYSBidWcgdGhhdCB0aHJvd3MgYW4gZXJyb3Igc28gbmVlZCBhIHRyeS9jYXRjaCAoIzc5MylcbiAgaWYgKHR5cGVvZiBlbC5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gd3JhcHBpbmcgaW4gYW4gaWlmZSBzbyBpdCdzIG5vdCBkZW9wdGltaXplZCAoIzEwNjAjZGlzY3Vzc2lvbl9yMTAzMjQ0NzMpXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwubG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdIdG1sNScsIEh0bWw1KTtcbmV4cG9ydCBkZWZhdWx0IEh0bWw1O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCB0b1RpdGxlQ2FzZSBmcm9tICcuLi91dGlscy90by10aXRsZS1jYXNlLmpzJztcblxuLyoqXG4gKiBUaGUgTWVkaWEgTG9hZGVyIGlzIHRoZSBjb21wb25lbnQgdGhhdCBkZWNpZGVzIHdoaWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgdG8gbG9hZFxuICogd2hlbiB0aGUgcGxheWVyIGlzIGluaXRpYWxpemVkLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBNZWRpYUxvYWRlciBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCByZWFkeSl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSk7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc291cmNlcyB3aGVuIHRoZSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQsXG4gICAgLy8gbG9hZCB0aGUgZmlyc3Qgc3VwcG9ydGVkIHBsYXliYWNrIHRlY2hub2xvZ3kuXG4gICAgaWYgKCFwbGF5ZXIub3B0aW9uc19bJ3NvdXJjZXMnXSB8fCBwbGF5ZXIub3B0aW9uc19bJ3NvdXJjZXMnXS5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAobGV0IGk9MCwgaj1wbGF5ZXIub3B0aW9uc19bJ3RlY2hPcmRlciddOyBpPGoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRlY2hOYW1lID0gdG9UaXRsZUNhc2UoaltpXSk7XG4gICAgICAgIGxldCB0ZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0ZWNoICYmIHRlY2guaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgIHBsYXllci5sb2FkVGVjaCh0ZWNoTmFtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gLy8gTG9vcCB0aHJvdWdoIHBsYXliYWNrIHRlY2hub2xvZ2llcyAoSFRNTDUsIEZsYXNoKSBhbmQgY2hlY2sgZm9yIHN1cHBvcnQuXG4gICAgICAvLyAvLyBUaGVuIGxvYWQgdGhlIGJlc3Qgc291cmNlLlxuICAgICAgLy8gLy8gQSBmZXcgYXNzdW1wdGlvbnMgaGVyZTpcbiAgICAgIC8vIC8vICAgQWxsIHBsYXliYWNrIHRlY2hub2xvZ2llcyByZXNwZWN0IHByZWxvYWQgZmFsc2UuXG4gICAgICBwbGF5ZXIuc3JjKHBsYXllci5vcHRpb25zX1snc291cmNlcyddKTtcbiAgICB9XG4gIH1cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZWRpYUxvYWRlcicsIE1lZGlhTG9hZGVyKTtcbmV4cG9ydCBkZWZhdWx0IE1lZGlhTG9hZGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1lZGlhIFRlY2hub2xvZ3kgQ29udHJvbGxlciAtIEJhc2UgY2xhc3MgZm9yIG1lZGlhIHBsYXliYWNrXG4gKiB0ZWNobm9sb2d5IGNvbnRyb2xsZXJzIGxpa2UgRmxhc2ggYW5kIEhUTUw1XG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IFRleHRUcmFjayBmcm9tICcuLi90cmFja3MvdGV4dC10cmFjayc7XG5pbXBvcnQgVGV4dFRyYWNrTGlzdCBmcm9tICcuLi90cmFja3MvdGV4dC10cmFjay1saXN0JztcbmltcG9ydCAqIGFzIEZuIGZyb20gJy4uL3V0aWxzL2ZuLmpzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vdXRpbHMvbG9nLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRpbWVSYW5nZSB9IGZyb20gJy4uL3V0aWxzL3RpbWUtcmFuZ2VzLmpzJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtZWRpYSAoSFRNTDUgVmlkZW8sIEZsYXNoKSBjb250cm9sbGVyc1xuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXIgIENlbnRyYWwgcGxheWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUZWNoIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPXt9LCByZWFkeT1mdW5jdGlvbigpe30pe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHRlY2ggdG8gcmVwb3J0IHVzZXIgYWN0aXZpdHkgYXV0b21hdGljYWxseS5cbiAgICAvLyBUaGlzIGlzIGRvbmUgbWFudWFsbHkgaW4gYWRkQ29udHJvbHNMaXN0ZW5lcnNcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcbiAgICBzdXBlcihudWxsLCBvcHRpb25zLCByZWFkeSk7XG5cbiAgICB0aGlzLnRleHRUcmFja3NfID0gb3B0aW9ucy50ZXh0VHJhY2tzO1xuXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgcHJvZ3Jlc3MgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxuICAgIGlmICghdGhpcy5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzKSB7XG4gICAgICB0aGlzLm1hbnVhbFByb2dyZXNzT24oKTtcbiAgICB9XG5cbiAgICAvLyBNYW51YWxseSB0cmFjayB0aW1ldXBkYXRlcyBpbiBjYXNlcyB3aGVyZSB0aGUgYnJvd3Nlci9mbGFzaCBwbGF5ZXIgZG9lc24ndCByZXBvcnQgaXQuXG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cykge1xuICAgICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlc09uKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0Q29udHJvbHNMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChvcHRpb25zLm5hdGl2ZUNhcHRpb25zID09PSBmYWxzZSB8fCBvcHRpb25zLm5hdGl2ZVRleHRUcmFja3MgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHRoaXMuZW11bGF0ZVRleHRUcmFja3MoKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRUZXh0VHJhY2tMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgY2xpY2sgYW5kIHRvdWNoIGxpc3RlbmVycyBmb3IgdGhlIHBsYXliYWNrIGVsZW1lbnRcbiAgICogT24gZGVza3RvcHMsIGEgY2xpY2sgb24gdGhlIHZpZGVvIGl0c2VsZiB3aWxsIHRvZ2dsZSBwbGF5YmFjayxcbiAgICogb24gYSBtb2JpbGUgZGV2aWNlIGEgY2xpY2sgb24gdGhlIHZpZGVvIHRvZ2dsZXMgY29udHJvbHMuXG4gICAqICh0b2dnbGluZyBjb250cm9scyBpcyBkb25lIGJ5IHRvZ2dsaW5nIHRoZSB1c2VyIHN0YXRlIGJldHdlZW4gYWN0aXZlIGFuZFxuICAgKiBpbmFjdGl2ZSlcbiAgICpcbiAgICogQSB0YXAgY2FuIHNpZ25hbCB0aGF0IGEgdXNlciBoYXMgYmVjb21lIGFjdGl2ZSwgb3IgaGFzIGJlY29tZSBpbmFjdGl2ZVxuICAgKiBlLmcuIGEgcXVpY2sgdGFwIG9uIGFuIGlQaG9uZSBtb3ZpZSBzaG91bGQgcmV2ZWFsIHRoZSBjb250cm9scy4gQW5vdGhlclxuICAgKiBxdWljayB0YXAgc2hvdWxkIGhpZGUgdGhlbSBhZ2FpbiAoc2lnbmFsaW5nIHRoZSB1c2VyIGlzIGluIGFuIGluYWN0aXZlXG4gICAqIHZpZXdpbmcgc3RhdGUpXG4gICAqXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoaXMsIHdlIHN0aWxsIHdhbnQgdGhlIHVzZXIgdG8gYmUgY29uc2lkZXJlZCBpbmFjdGl2ZSBhZnRlclxuICAgKiBhIGZldyBzZWNvbmRzIG9mIGluYWN0aXZpdHkuXG4gICAqXG4gICAqIE5vdGU6IHRoZSBvbmx5IHBhcnQgb2YgaU9TIGludGVyYWN0aW9uIHdlIGNhbid0IG1pbWljIHdpdGggdGhpcyBzZXR1cFxuICAgKiBpcyBhIHRvdWNoIGFuZCBob2xkIG9uIHRoZSB2aWRlbyBlbGVtZW50IGNvdW50aW5nIGFzIGFjdGl2aXR5IGluIG9yZGVyIHRvXG4gICAqIGtlZXAgdGhlIGNvbnRyb2xzIHNob3dpbmcsIGJ1dCB0aGF0IHNob3VsZG4ndCBiZSBhbiBpc3N1ZS4gQSB0b3VjaCBhbmQgaG9sZCBvblxuICAgKiBhbnkgY29udHJvbHMgd2lsbCBzdGlsbCBrZWVwIHRoZSB1c2VyIGFjdGl2ZVxuICAgKi9cbiAgaW5pdENvbnRyb2xzTGlzdGVuZXJzKCkge1xuICAgIC8vIGlmIHdlJ3JlIGxvYWRpbmcgdGhlIHBsYXliYWNrIG9iamVjdCBhZnRlciBpdCBoYXMgc3RhcnRlZCBsb2FkaW5nIG9yIHBsYXlpbmcgdGhlXG4gICAgLy8gdmlkZW8gKG9mdGVuIHdpdGggYXV0b3BsYXkgb24pIHRoZW4gdGhlIGxvYWRzdGFydCBldmVudCBoYXMgYWxyZWFkeSBmaXJlZCBhbmQgd2VcbiAgICAvLyBuZWVkIHRvIGZpcmUgaXQgbWFudWFsbHkgYmVjYXVzZSBtYW55IHRoaW5ncyByZWx5IG9uIGl0LlxuICAgIC8vIExvbmcgdGVybSB3ZSBtaWdodCBjb25zaWRlciBob3cgd2Ugd291bGQgZG8gdGhpcyBmb3Igb3RoZXIgZXZlbnRzIGxpa2UgJ2NhbnBsYXknXG4gICAgLy8gdGhhdCBtYXkgYWxzbyBoYXZlIGZpcmVkLlxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24oKXtcbiAgICAgIGlmICh0aGlzLm5ldHdvcmtTdGF0ZSAmJiB0aGlzLm5ldHdvcmtTdGF0ZSgpID4gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyogRmFsbGJhY2tzIGZvciB1bnN1cHBvcnRlZCBldmVudCB0eXBlc1xuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAvLyBNYW51YWxseSB0cmlnZ2VyIHByb2dyZXNzIGV2ZW50cyBiYXNlZCBvbiBjaGFuZ2VzIHRvIHRoZSBidWZmZXJlZCBhbW91bnRcbiAgLy8gTWFueSBmbGFzaCBwbGF5ZXJzIGFuZCBvbGRlciBIVE1MNSBicm93c2VycyBkb24ndCBzZW5kIHByb2dyZXNzIG9yIHByb2dyZXNzLWxpa2UgZXZlbnRzXG4gIG1hbnVhbFByb2dyZXNzT24oKSB7XG4gICAgdGhpcy5vbignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuXG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IHRydWU7XG5cbiAgICAvLyBUcmlnZ2VyIHByb2dyZXNzIHdhdGNoaW5nIHdoZW4gYSBzb3VyY2UgYmVnaW5zIGxvYWRpbmdcbiAgICB0aGlzLnRyYWNrUHJvZ3Jlc3MoKTtcbiAgfVxuXG4gIG1hbnVhbFByb2dyZXNzT2ZmKCkge1xuICAgIHRoaXMubWFudWFsUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG5cbiAgICB0aGlzLm9mZignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuICB9XG5cbiAgdHJhY2tQcm9ncmVzcygpIHtcbiAgICB0aGlzLnByb2dyZXNzSW50ZXJ2YWwgPSB0aGlzLnNldEludGVydmFsKEZuLmJpbmQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgIC8vIERvbid0IHRyaWdnZXIgdW5sZXNzIGJ1ZmZlcmVkIGFtb3VudCBpcyBncmVhdGVyIHRoYW4gbGFzdCB0aW1lXG5cbiAgICAgIGxldCBidWZmZXJlZFBlcmNlbnQgPSB0aGlzLmJ1ZmZlcmVkUGVyY2VudCgpO1xuXG4gICAgICBpZiAodGhpcy5idWZmZXJlZFBlcmNlbnRfICE9PSBidWZmZXJlZFBlcmNlbnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gPSBidWZmZXJlZFBlcmNlbnQ7XG5cbiAgICAgIGlmIChidWZmZXJlZFBlcmNlbnQgPT09IDEpIHtcbiAgICAgICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuICAgICAgfVxuICAgIH0pLCA1MDApO1xuICB9XG5cbiAgb25EdXJhdGlvbkNoYW5nZSgpIHtcbiAgICB0aGlzLmR1cmF0aW9uXyA9IHRoaXMuZHVyYXRpb24oKTtcbiAgfVxuXG4gIGJ1ZmZlcmVkUGVyY2VudCgpIHtcbiAgICBsZXQgYnVmZmVyZWREdXJhdGlvbiA9IDAsXG4gICAgICAgIHN0YXJ0LCBlbmQ7XG5cbiAgICBpZiAoIXRoaXMuZHVyYXRpb25fKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBsZXQgYnVmZmVyZWQgPSB0aGlzLmJ1ZmZlcmVkKCk7XG5cbiAgICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgIGJ1ZmZlcmVkID0gY3JlYXRlVGltZVJhbmdlKDAsMCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaT0wOyBpPGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKXtcbiAgICAgIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICBlbmQgICA9IGJ1ZmZlcmVkLmVuZChpKTtcblxuICAgICAgLy8gYnVmZmVyZWQgZW5kIGNhbiBiZSBiaWdnZXIgdGhhbiBkdXJhdGlvbiBieSBhIHZlcnkgc21hbGwgZnJhY3Rpb25cbiAgICAgIGlmIChlbmQgPiB0aGlzLmR1cmF0aW9uXykge1xuICAgICAgICBlbmQgPSB0aGlzLmR1cmF0aW9uXztcbiAgICAgIH1cblxuICAgICAgYnVmZmVyZWREdXJhdGlvbiArPSBlbmQgLSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWREdXJhdGlvbiAvIHRoaXMuZHVyYXRpb25fO1xuICB9XG5cbiAgc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCk7XG4gIH1cblxuICAvKiEgVGltZSBUcmFja2luZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBtYW51YWxUaW1lVXBkYXRlc09uKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgdGhpcy5vbigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vbigncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcbiAgICAvLyB0aW1ldXBkYXRlIGlzIGFsc28gY2FsbGVkIGJ5IC5jdXJyZW50VGltZSB3aGVuZXZlciBjdXJyZW50IHRpbWUgaXMgc2V0XG5cbiAgICAvLyBXYXRjaCBmb3IgbmF0aXZlIHRpbWV1cGRhdGUgZXZlbnQgb25seVxuICAgIHZhciBvblRpbWVVcGRhdGUgPSBmdW5jdGlvbihlKXtcbiAgICAgIGlmIChlLm1hbnVhbGx5VHJpZ2dlcmVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMub2ZmKCd0aW1ldXBkYXRlJywgb25UaW1lVXBkYXRlKTtcblxuICAgICAgLy8gVXBkYXRlIGtub3duIHByb2dyZXNzIHN1cHBvcnQgZm9yIHRoaXMgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgICAgdGhpcy5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMgPSB0cnVlO1xuICAgICAgLy8gVHVybiBvZmYgbWFudWFsIHByb2dyZXNzIHRyYWNraW5nXG4gICAgICB0aGlzLm1hbnVhbFRpbWVVcGRhdGVzT2ZmKCk7XG4gICAgfTtcblxuICAgIHRoaXMub24oJ3RpbWV1cGRhdGUnLCBvblRpbWVVcGRhdGUpO1xuICB9XG5cbiAgbWFudWFsVGltZVVwZGF0ZXNPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB0aGlzLm9mZigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vZmYoJ3BhdXNlJywgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSk7XG4gIH1cblxuICB0cmFja0N1cnJlbnRUaW1lKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwpIHsgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpOyB9XG4gICAgdGhpcy5jdXJyZW50VGltZUludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICAgIH0sIDI1MCk7IC8vIDQyID0gMjQgZnBzIC8vIDI1MCBpcyB3aGF0IFdlYmtpdCB1c2VzIC8vIEZGIHVzZXMgMTVcbiAgfVxuXG4gIC8vIFR1cm4gb2ZmIHBsYXkgcHJvZ3Jlc3MgdHJhY2tpbmcgKHdoZW4gcGF1c2VkIG9yIGRyYWdnaW5nKVxuICBzdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpIHtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5jdXJyZW50VGltZUludGVydmFsKTtcblxuICAgIC8vICMxMDAyIC0gaWYgdGhlIHZpZGVvIGVuZHMgcmlnaHQgYmVmb3JlIHRoZSBuZXh0IHRpbWV1cGRhdGUgd291bGQgaGFwcGVuLFxuICAgIC8vIHRoZSBwcm9ncmVzcyBiYXIgd29uJ3QgbWFrZSBpdCBhbGwgdGhlIHdheSB0byB0aGUgZW5kXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAvLyBUdXJuIG9mZiBhbnkgbWFudWFsIHByb2dyZXNzIG9yIHRpbWV1cGRhdGUgdHJhY2tpbmdcbiAgICBpZiAodGhpcy5tYW51YWxQcm9ncmVzcykgeyB0aGlzLm1hbnVhbFByb2dyZXNzT2ZmKCk7IH1cblxuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7IHRoaXMubWFudWFsVGltZVVwZGF0ZXNPZmYoKTsgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc2V0Q3VycmVudFRpbWUoKSB7XG4gICAgLy8gaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgbWFudWFsIHRpbWV1cGRhdGVzXG4gICAgaWYgKHRoaXMubWFudWFsVGltZVVwZGF0ZXMpIHsgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pOyB9XG4gIH1cblxuICBpbml0VGV4dFRyYWNrTGlzdGVuZXJzKCkge1xuICAgIGxldCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyA9IEZuLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3RleHR0cmFja2NoYW5nZScpO1xuICAgIH0pO1xuXG4gICAgbGV0IHRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCF0cmFja3MpIHJldHVybjtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja0xpc3RDaGFuZ2VzKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyk7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgRm4uYmluZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRleHRUcmFja0xpc3RDaGFuZ2VzKTtcbiAgICB9KSk7XG4gIH1cblxuICBlbXVsYXRlVGV4dFRyYWNrcygpIHtcbiAgICBpZiAoIXdpbmRvd1snV2ViVlRUJ10gJiYgdGhpcy5lbCgpLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgbGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0LnNyYyA9IHRoaXMub3B0aW9uc19bJ3Z0dC5qcyddIHx8ICcuLi9ub2RlX21vZHVsZXMvdnR0LmpzL2Rpc3QvdnR0LmpzJztcbiAgICAgIHRoaXMuZWwoKS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICB3aW5kb3dbJ1dlYlZUVCddID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgdHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdGV4dFRyYWNrc0NoYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxldCB1cGRhdGVEaXNwbGF5ID0gRm4uYmluZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0ZXh0dHJhY2tjaGFuZ2UnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3RleHR0cmFja2NoYW5nZScpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRyYWNrID0gdGhpc1tpXTtcbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICAgIGlmICh0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIEZuLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlIGRlZmF1bHQgbWV0aG9kcyBmb3IgdGV4dCB0cmFja3MuXG4gICAqXG4gICAqIEh0bWw1IHRlY2ggb3ZlcnJpZGVzIHRoZXNlLlxuICAgKi9cblxuICB0ZXh0VHJhY2tzKCkge1xuICAgIHRoaXMudGV4dFRyYWNrc18gPSB0aGlzLnRleHRUcmFja3NfIHx8IG5ldyBUZXh0VHJhY2tMaXN0KCk7XG4gICAgcmV0dXJuIHRoaXMudGV4dFRyYWNrc187XG4gIH1cblxuICByZW1vdGVUZXh0VHJhY2tzKCkge1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrc18gPSB0aGlzLnJlbW90ZVRleHRUcmFja3NfIHx8IG5ldyBUZXh0VHJhY2tMaXN0KCk7XG4gICAgcmV0dXJuIHRoaXMucmVtb3RlVGV4dFRyYWNrc187XG4gIH1cblxuICBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCFraW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHRUcmFjayBraW5kIGlzIHJlcXVpcmVkIGJ1dCB3YXMgbm90IHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVRyYWNrSGVscGVyKHRoaXMsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gIH1cblxuICBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xuICAgIGxldCB0cmFjayA9IGNyZWF0ZVRyYWNrSGVscGVyKHRoaXMsIG9wdGlvbnMua2luZCwgb3B0aW9ucy5sYWJlbCwgb3B0aW9ucy5sYW5ndWFnZSwgb3B0aW9ucyk7XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2tfKHRyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2s6IHRyYWNrXG4gICAgfTtcbiAgfVxuXG4gIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIHRoaXMudGV4dFRyYWNrcygpLnJlbW92ZVRyYWNrXyh0cmFjayk7XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkucmVtb3ZlVHJhY2tfKHRyYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGVmYXVsdCBzZXRQb3N0ZXIgbWV0aG9kIGZvciB0ZWNoc1xuICAgKlxuICAgKiBQb3N0ZXIgc3VwcG9ydCBmb3IgdGVjaHMgc2hvdWxkIGJlIG9wdGlvbmFsLCBzbyB3ZSBkb24ndCB3YW50IHRlY2hzIHRvXG4gICAqIGJyZWFrIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHdheSB0byBzZXQgYSBwb3N0ZXIuXG4gICAqL1xuICBzZXRQb3N0ZXIoKSB7fVxuXG59XG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIHRleHQgdHJhY2tzXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5UZWNoLnByb3RvdHlwZS50ZXh0VHJhY2tzXztcblxudmFyIGNyZWF0ZVRyYWNrSGVscGVyID0gZnVuY3Rpb24oc2VsZiwga2luZCwgbGFiZWwsIGxhbmd1YWdlLCBvcHRpb25zPXt9KSB7XG4gIGxldCB0cmFja3MgPSBzZWxmLnRleHRUcmFja3MoKTtcblxuICBvcHRpb25zLmtpbmQgPSBraW5kO1xuXG4gIGlmIChsYWJlbCkge1xuICAgIG9wdGlvbnMubGFiZWwgPSBsYWJlbDtcbiAgfVxuICBpZiAobGFuZ3VhZ2UpIHtcbiAgICBvcHRpb25zLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gIH1cbiAgb3B0aW9ucy50ZWNoID0gc2VsZjtcblxuICBsZXQgdHJhY2sgPSBuZXcgVGV4dFRyYWNrKG9wdGlvbnMpO1xuICB0cmFja3MuYWRkVHJhY2tfKHRyYWNrKTtcblxuICByZXR1cm4gdHJhY2s7XG59O1xuXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wgPSB0cnVlO1xuXG4vLyBSZXNpemluZyBwbHVnaW5zIHVzaW5nIHJlcXVlc3QgZnVsbHNjcmVlbiByZWxvYWRzIHRoZSBwbHVnaW5cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IGZhbHNlO1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNQbGF5YmFja1JhdGUgPSBmYWxzZTtcblxuLy8gT3B0aW9uYWwgZXZlbnRzIHRoYXQgd2UgY2FuIG1hbnVhbGx5IG1pbWljIHdpdGggdGltZXJzXG4vLyBjdXJyZW50bHkgbm90IHRyaWdnZXJlZCBieSB2aWRlby1qcy1zd2ZcblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUHJvZ3Jlc3NFdmVudHMgPSBmYWxzZTtcblRlY2gucHJvdG90eXBlLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyA9IGZhbHNlO1xuXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSBmYWxzZTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uYWwgbWl4aW4gZm9yIHRlY2hzIHRoYXQgd2FudCB0byB1c2UgdGhlIFNvdXJjZSBIYW5kbGVyIHBhdHRlcm4uXG4gKlxuICogIyMjIyMgRVhBTVBMRTpcbiAqXG4gKiAgIFRlY2gud2l0aFNvdXJjZUhhbmRsZXJzLmNhbGwoTXlUZWNoKTtcbiAqXG4gKi9cblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzID0gZnVuY3Rpb24oX1RlY2gpe1xuICAvKipcbiAgICogUmVnaXN0ZXIgYSBzb3VyY2UgaGFuZGxlclxuICAgKiBTb3VyY2UgaGFuZGxlcnMgYXJlIHNjcmlwdHMgZm9yIGhhbmRsaW5nIHNwZWNpZmljIGZvcm1hdHMuXG4gICAqIFRoZSBzb3VyY2UgaGFuZGxlciBwYXR0ZXJuIGlzIHVzZWQgZm9yIGFkYXB0aXZlIGZvcm1hdHMgKEhMUywgREFTSCkgdGhhdFxuICAgKiBtYW51YWxseSBsb2FkIHZpZGVvIGRhdGEgYW5kIGZlZWQgaXQgaW50byBhIFNvdXJjZSBCdWZmZXIgKE1lZGlhIFNvdXJjZSBFeHRlbnNpb25zKVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaGFuZGxlciAgVGhlIHNvdXJjZSBoYW5kbGVyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBmaXJzdCAgICBSZWdpc3RlciBpdCBiZWZvcmUgYW55IGV4aXN0aW5nIGhhbmRsZXJzXG4gICAqL1xuICAgX1RlY2gucmVnaXN0ZXJTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlciwgaW5kZXgpe1xuICAgIGxldCBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgaW5kZXggPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAwLCBoYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBmaXJzdCBzb3VyY2UgaGFuZGxlciB0aGF0IHN1cHBvcnRzIHRoZSBzb3VyY2VcbiAgICogVE9ETzogQW5zd2VyIHF1ZXN0aW9uOiBzaG91bGQgJ3Byb2JhYmx5JyBiZSBwcmlvcml0aXplZCBvdmVyICdtYXliZSdcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHJldHVybnMge09iamVjdH0gICAgICAgVGhlIGZpcnN0IHNvdXJjZSBoYW5kbGVyIHRoYXQgc3VwcG9ydHMgdGhlIHNvdXJjZVxuICAgKiBAcmV0dXJucyB7bnVsbH0gICAgICAgICBOdWxsIGlmIG5vIHNvdXJjZSBoYW5kbGVyIGlzIGZvdW5kXG4gICAqL1xuICAgX1RlY2guc2VsZWN0U291cmNlSGFuZGxlciA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gICAgbGV0IGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgfHwgW107XG4gICAgbGV0IGNhbjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbiA9IGhhbmRsZXJzW2ldLmNhbkhhbmRsZVNvdXJjZShzb3VyY2UpO1xuXG4gICAgICBpZiAoY2FuKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlXG4gICogQHBhcmFtICB7T2JqZWN0fSBzcmNPYmogIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICovXG4gIF9UZWNoLmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbihzcmNPYmope1xuICAgIGxldCBzaCA9IF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIoc3JjT2JqKTtcblxuICAgIGlmIChzaCkge1xuICAgICAgcmV0dXJuIHNoLmNhbkhhbmRsZVNvdXJjZShzcmNPYmopO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHNldHRpbmcgdGhlIHNvdXJjZSB1c2luZyBhIHNvdXJjZSBvYmplY3RcbiAgICogYW5kIHNvdXJjZSBoYW5kbGVycy5cbiAgICogU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3MgYSBzb3VyY2UgaGFuZGxlciB3YXMgZm91bmQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgIEEgc291cmNlIG9iamVjdCB3aXRoIHNyYyBhbmQgdHlwZSBrZXlzXG4gICAqIEByZXR1cm4ge1RlY2h9IHNlbGZcbiAgICovXG4gICBfVGVjaC5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24oc291cmNlKXtcbiAgICBsZXQgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNvdXJjZSk7XG5cbiAgICBpZiAoIXNoKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gYSBuYXRpdmUgc291cmNlIGhhbmRlciB3aGVuIHVuc3VwcG9ydGVkIHNvdXJjZXMgYXJlXG4gICAgICAvLyBkZWxpYmVyYXRlbHkgc2V0XG4gICAgICBpZiAoX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcikge1xuICAgICAgICBzaCA9IF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZXJyb3IoJ05vIHNvdXJjZSBoYW5kZXIgZm91bmQgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIGFueSBleGlzdGluZyBzb3VyY2UgaGFuZGxlclxuICAgIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIoKTtcbiAgICB0aGlzLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xuXG4gICAgdGhpcy5jdXJyZW50U291cmNlXyA9IHNvdXJjZTtcbiAgICB0aGlzLnNvdXJjZUhhbmRsZXJfID0gc2guaGFuZGxlU291cmNlKHNvdXJjZSwgdGhpcyk7XG4gICAgdGhpcy5vbignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFueSBleGlzdGluZyBzb3VyY2UgaGFuZGxlclxuICAgKi9cbiAgIF9UZWNoLnByb3RvdHlwZS5kaXNwb3NlU291cmNlSGFuZGxlciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMuc291cmNlSGFuZGxlcl8gJiYgdGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKSB7XG4gICAgICB0aGlzLnNvdXJjZUhhbmRsZXJfLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG5cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGVjaCcsIFRlY2gpO1xuLy8gT2xkIG5hbWUgZm9yIFRlY2hcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVkaWFUZWNoQ29udHJvbGxlcicsIFRlY2gpO1xuZXhwb3J0IGRlZmF1bHQgVGVjaDtcbiIsImltcG9ydCAqIGFzIGJyb3dzZXIgZnJvbSAnLi4vdXRpbHMvYnJvd3Nlci5qcyc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLypcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tjdWVsaXN0XG4gKlxuICogaW50ZXJmYWNlIFRleHRUcmFja0N1ZUxpc3Qge1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBsZW5ndGg7XG4gKiAgIGdldHRlciBUZXh0VHJhY2tDdWUgKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICogICBUZXh0VHJhY2tDdWU/IGdldEN1ZUJ5SWQoRE9NU3RyaW5nIGlkKTtcbiAqIH07XG4gKi9cblxubGV0IFRleHRUcmFja0N1ZUxpc3QgPSBmdW5jdGlvbihjdWVzKSB7XG4gIGxldCBsaXN0ID0gdGhpcztcblxuICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlKSB7XG4gICAgICBsaXN0W3Byb3BdID0gVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGVbcHJvcF07XG4gICAgfVxuICB9XG5cbiAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18uY2FsbChsaXN0LCBjdWVzKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdCwgJ2xlbmd0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoXztcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChicm93c2VyLklTX0lFOCkge1xuICAgIHJldHVybiBsaXN0O1xuICB9XG59O1xuXG5UZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5zZXRDdWVzXyA9IGZ1bmN0aW9uKGN1ZXMpIHtcbiAgbGV0IG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gIGxldCBpID0gMDtcbiAgbGV0IGwgPSBjdWVzLmxlbmd0aDtcblxuICB0aGlzLmN1ZXNfID0gY3VlcztcbiAgdGhpcy5sZW5ndGhfID0gY3Vlcy5sZW5ndGg7XG5cbiAgbGV0IGRlZmluZVByb3AgPSBmdW5jdGlvbihpKSB7XG4gICAgaWYgKCEoJycraSBpbiB0aGlzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICcnICsgaSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmN1ZXNfW2ldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKG9sZExlbmd0aCA8IGwpIHtcbiAgICBpID0gb2xkTGVuZ3RoO1xuXG4gICAgZm9yKDsgaSA8IGw7IGkrKykge1xuICAgICAgZGVmaW5lUHJvcC5jYWxsKHRoaXMsIGkpO1xuICAgIH1cbiAgfVxufTtcblxuVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuZ2V0Q3VlQnlJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGN1ZSA9IHRoaXNbaV07XG4gICAgaWYgKGN1ZS5pZCA9PT0gaWQpIHtcbiAgICAgIHJlc3VsdCA9IGN1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2tDdWVMaXN0O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi4vbWVudS9tZW51LmpzJztcbmltcG9ydCBNZW51SXRlbSBmcm9tICcuLi9tZW51L21lbnUtaXRlbS5qcyc7XG5pbXBvcnQgTWVudUJ1dHRvbiBmcm9tICcuLi9tZW51L21lbnUtYnV0dG9uLmpzJztcbmltcG9ydCAqIGFzIEZuIGZyb20gJy4uL3V0aWxzL2ZuLmpzJztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxuY29uc3QgZGFya0dyYXkgPSAnIzIyMic7XG5jb25zdCBsaWdodEdyYXkgPSAnI2NjYyc7XG5jb25zdCBmb250TWFwID0ge1xuICBtb25vc3BhY2U6ICAgICAgICAgICAgICdtb25vc3BhY2UnLFxuICBzYW5zU2VyaWY6ICAgICAgICAgICAgICdzYW5zLXNlcmlmJyxcbiAgc2VyaWY6ICAgICAgICAgICAgICAgICAnc2VyaWYnLFxuICBtb25vc3BhY2VTYW5zU2VyaWY6ICAgICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlJyxcbiAgbW9ub3NwYWNlU2VyaWY6ICAgICAgICAnXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2UnLFxuICBwcm9wb3J0aW9uYWxTYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcbiAgcHJvcG9ydGlvbmFsU2VyaWY6ICAgICAnc2VyaWYnLFxuICBjYXN1YWw6ICAgICAgICAgICAgICAgICdcIkNvbWljIFNhbnMgTVNcIiwgSW1wYWN0LCBmYW50YXN5JyxcbiAgc2NyaXB0OiAgICAgICAgICAgICAgICAnXCJNb25vdHlwZSBDb3JzaXZhXCIsIGN1cnNpdmUnLFxuICBzbWFsbGNhcHM6ICAgICAgICAgICAgICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlLCBzYW5zLXNlcmlmJ1xufTtcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIHRleHQgdHJhY2sgY3Vlc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUZXh0VHJhY2tEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIHBsYXllci5vbignbG9hZHN0YXJ0JywgRm4uYmluZCh0aGlzLCB0aGlzLnRvZ2dsZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ3RleHR0cmFja2NoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy50b2dnbGVEaXNwbGF5KSk7XG5cbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgY2FsbGVkIGR1cmluZyBwbGF5ZXIgaW5pdCwgYnV0IHdhcyBjYXVzaW5nIGFuIGVycm9yXG4gICAgLy8gaWYgYSB0cmFjayBzaG91bGQgc2hvdyBieSBkZWZhdWx0IGFuZCB0aGUgZGlzcGxheSBoYWRuJ3QgbG9hZGVkIHlldC5cbiAgICAvLyBTaG91bGQgcHJvYmFibHkgYmUgbW92ZWQgdG8gYW4gZXh0ZXJuYWwgdHJhY2sgbG9hZGVyIHdoZW4gd2Ugc3VwcG9ydFxuICAgIC8vIHRyYWNrcyB0aGF0IGRvbid0IG5lZWQgYSBkaXNwbGF5LlxuICAgIHBsYXllci5yZWFkeShGbi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHBsYXllci50ZWNoICYmIHBsYXllci50ZWNoWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwbGF5ZXIub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuXG4gICAgICBsZXQgdHJhY2tzID0gcGxheWVyLm9wdGlvbnNfWyd0cmFja3MnXSB8fCBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLmFkZFJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgdG9nZ2xlRGlzcGxheSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnRlY2ggJiYgdGhpcy5wbGF5ZXJfLnRlY2hbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGV4dC10cmFjay1kaXNwbGF5J1xuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJEaXNwbGF5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93WydXZWJWVFQnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2luZG93WydXZWJWVFQnXVsncHJvY2Vzc0N1ZXMnXSh3aW5kb3csIFtdLCB0aGlzLmVsXyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRGlzcGxheSgpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIHRoaXMuY2xlYXJEaXNwbGF5KCk7XG5cbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGk9MDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHRyYWNrWydtb2RlJ10gPT09ICdzaG93aW5nJykge1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclRyYWNrKHRyYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVGb3JUcmFjayh0cmFjaykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93WydXZWJWVFQnXSAhPT0gJ2Z1bmN0aW9uJyB8fCAhdHJhY2tbJ2FjdGl2ZUN1ZXMnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBvdmVycmlkZXMgPSB0aGlzLnBsYXllcl9bJ3RleHRUcmFja1NldHRpbmdzJ10uZ2V0VmFsdWVzKCk7XG5cbiAgICBsZXQgY3VlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tbJ2FjdGl2ZUN1ZXMnXS5sZW5ndGg7IGkrKykge1xuICAgICAgY3Vlcy5wdXNoKHRyYWNrWydhY3RpdmVDdWVzJ11baV0pO1xuICAgIH1cblxuICAgIHdpbmRvd1snV2ViVlRUJ11bJ3Byb2Nlc3NDdWVzJ10od2luZG93LCB0cmFja1snYWN0aXZlQ3VlcyddLCB0aGlzLmVsXyk7XG5cbiAgICBsZXQgaSA9IGN1ZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGxldCBjdWVEaXYgPSBjdWVzW2ldLmRpc3BsYXlTdGF0ZTtcbiAgICAgIGlmIChvdmVycmlkZXMuY29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuY29sb3IgPSBvdmVycmlkZXMuY29sb3I7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLnRleHRPcGFjaXR5KSB7XG4gICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdi5maXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAnY29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuY29sb3IgfHwgJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMudGV4dE9wYWNpdHkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSB7XG4gICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdi5maXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0Q29sb3Iob3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvciB8fCAnIzAwMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5iYWNrZ3JvdW5kT3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy53aW5kb3dDb2xvcikge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpIHtcbiAgICAgICAgICB0cnlVcGRhdGVTdHlsZShjdWVEaXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0Q29sb3Iob3ZlcnJpZGVzLndpbmRvd0NvbG9yLCBvdmVycmlkZXMud2luZG93T3BhY2l0eSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ZURpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvdmVycmlkZXMud2luZG93Q29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZHJvcHNoYWRvdycpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gYDJweCAycHggM3B4ICR7ZGFya0dyYXl9LCAycHggMnB4IDRweCAke2RhcmtHcmF5fSwgMnB4IDJweCA1cHggJHtkYXJrR3JheX1gO1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICdyYWlzZWQnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9IGAxcHggMXB4ICR7ZGFya0dyYXl9LCAycHggMnB4ICR7ZGFya0dyYXl9LCAzcHggM3B4ICR7ZGFya0dyYXl9YDtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZGVwcmVzc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSBgMXB4IDFweCAke2xpZ2h0R3JheX0sIDAgMXB4ICR7bGlnaHRHcmF5fSwgLTFweCAtMXB4ICR7ZGFya0dyYXl9LCAwIC0xcHggJHtkYXJrR3JheX1gO1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSBgMCAwIDRweCAke2RhcmtHcmF5fSwgMCAwIDRweCAke2RhcmtHcmF5fSwgMCAwIDRweCAke2RhcmtHcmF5fSwgMCAwIDRweCAke2RhcmtHcmF5fWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udFBlcmNlbnQgJiYgb3ZlcnJpZGVzLmZvbnRQZXJjZW50ICE9PSAxKSB7XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gd2luZG93LnBhcnNlRmxvYXQoY3VlRGl2LnN0eWxlLmZvbnRTaXplKTtcbiAgICAgICAgY3VlRGl2LnN0eWxlLmZvbnRTaXplID0gKGZvbnRTaXplICogb3ZlcnJpZGVzLmZvbnRQZXJjZW50KSArICdweCc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS50b3AgPSAnYXV0byc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5ib3R0b20gPSAnMnB4JztcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udEZhbWlseSAmJiBvdmVycmlkZXMuZm9udEZhbWlseSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMuZm9udEZhbWlseSA9PT0gJ3NtYWxsLWNhcHMnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udFZhcmlhbnQgPSAnc21hbGwtY2Fwcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udEZhbWlseSA9IGZvbnRNYXBbb3ZlcnJpZGVzLmZvbnRGYW1pbHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuLy8gQWRkIGN1ZSBIVE1MIHRvIGRpc3BsYXlcbmZ1bmN0aW9uIGNvbnN0cnVjdENvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gIHJldHVybiAncmdiYSgnICtcbiAgICAvLyBjb2xvciBsb29rcyBsaWtlIFwiI2YwZVwiXG4gICAgcGFyc2VJbnQoY29sb3JbMV0gKyBjb2xvclsxXSwgMTYpICsgJywnICtcbiAgICBwYXJzZUludChjb2xvclsyXSArIGNvbG9yWzJdLCAxNikgKyAnLCcgK1xuICAgIHBhcnNlSW50KGNvbG9yWzNdICsgY29sb3JbM10sIDE2KSArICcsJyArXG4gICAgb3BhY2l0eSArICcpJztcbn1cblxuZnVuY3Rpb24gdHJ5VXBkYXRlU3R5bGUoZWwsIHN0eWxlLCBydWxlKSB7XG4gIC8vIHNvbWUgc3R5bGUgY2hhbmdlcyB3aWxsIHRocm93IGFuIGVycm9yLCBwYXJ0aWN1bGFybHkgaW4gSUU4LiBUaG9zZSBzaG91bGQgYmUgbm9vcHMuXG4gIHRyeSB7XG4gICAgZWwuc3R5bGVbc3R5bGVdID0gcnVsZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tEaXNwbGF5JywgVGV4dFRyYWNrRGlzcGxheSk7XG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2tEaXNwbGF5O1xuIiwiLypcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2ttb2RlXG4gKlxuICogZW51bSBUZXh0VHJhY2tNb2RlIHsgXCJkaXNhYmxlZFwiLCAgXCJoaWRkZW5cIiwgIFwic2hvd2luZ1wiIH07XG4gKi9cbnZhciBUZXh0VHJhY2tNb2RlID0ge1xuICAnZGlzYWJsZWQnOiAnZGlzYWJsZWQnLFxuICAnaGlkZGVuJzogJ2hpZGRlbicsXG4gICdzaG93aW5nJzogJ3Nob3dpbmcnXG59O1xuXG4vKlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2tpbmRcbiAqXG4gKiBlbnVtIFRleHRUcmFja0tpbmQgeyBcInN1YnRpdGxlc1wiLCAgXCJjYXB0aW9uc1wiLCAgXCJkZXNjcmlwdGlvbnNcIiwgIFwiY2hhcHRlcnNcIiwgIFwibWV0YWRhdGFcIiB9O1xuICovXG52YXIgVGV4dFRyYWNrS2luZCA9IHtcbiAgJ3N1YnRpdGxlcyc6ICdzdWJ0aXRsZXMnLFxuICAnY2FwdGlvbnMnOiAnY2FwdGlvbnMnLFxuICAnZGVzY3JpcHRpb25zJzogJ2Rlc2NyaXB0aW9ucycsXG4gICdjaGFwdGVycyc6ICdjaGFwdGVycycsXG4gICdtZXRhZGF0YSc6ICdtZXRhZGF0YSdcbn07XG5cbmV4cG9ydCB7IFRleHRUcmFja01vZGUsIFRleHRUcmFja0tpbmQgfTtcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgKiBhcyBGbiBmcm9tICcuLi91dGlscy9mbi5qcyc7XG5pbXBvcnQgKiBhcyBicm93c2VyIGZyb20gJy4uL3V0aWxzL2Jyb3dzZXIuanMnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbGlzdFxuICpcbiAqIGludGVyZmFjZSBUZXh0VHJhY2tMaXN0IDogRXZlbnRUYXJnZXQge1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBsZW5ndGg7XG4gKiAgIGdldHRlciBUZXh0VHJhY2sgKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICogICBUZXh0VHJhY2s/IGdldFRyYWNrQnlJZChET01TdHJpbmcgaWQpO1xuICpcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbmNoYW5nZTtcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbmFkZHRyYWNrO1xuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9ucmVtb3ZldHJhY2s7XG4gKiB9O1xuICovXG5sZXQgVGV4dFRyYWNrTGlzdCA9IGZ1bmN0aW9uKHRyYWNrcykge1xuICBsZXQgbGlzdCA9IHRoaXM7XG5cbiAgaWYgKGJyb3dzZXIuSVNfSUU4KSB7XG4gICAgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgbGlzdFtwcm9wXSA9IFRleHRUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHRyYWNrcyA9IHRyYWNrcyB8fCBbXTtcbiAgbGlzdC50cmFja3NfID0gW107XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc18ubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0LmFkZFRyYWNrXyh0cmFja3NbaV0pO1xuICB9XG5cbiAgaWYgKGJyb3dzZXIuSVNfSUU4KSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbn07XG5cblRleHRUcmFja0xpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblRleHRUcmFja0xpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dFRyYWNrTGlzdDtcblxuLypcbiAqIGNoYW5nZSAtIE9uZSBvciBtb3JlIHRyYWNrcyBpbiB0aGUgdHJhY2sgbGlzdCBoYXZlIGJlZW4gZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAqIGFkZHRyYWNrIC0gQSB0cmFjayBoYXMgYmVlbiBhZGRlZCB0byB0aGUgdHJhY2sgbGlzdC5cbiAqIHJlbW92ZXRyYWNrIC0gQSB0cmFjayBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHRyYWNrIGxpc3QuXG4qL1xuVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gICdjaGFuZ2UnOiAnY2hhbmdlJyxcbiAgJ2FkZHRyYWNrJzogJ2FkZHRyYWNrJyxcbiAgJ3JlbW92ZXRyYWNrJzogJ3JlbW92ZXRyYWNrJ1xufTtcblxuLy8gZW11bGF0ZSBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIHN1cHBvcnQgdG8gYWxsb3cgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uXG5mb3IgKGxldCBldmVudCBpbiBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXykge1xuICBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZVsnb24nICsgZXZlbnRdID0gbnVsbDtcbn1cblxuVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2tfID0gZnVuY3Rpb24odHJhY2spIHtcbiAgbGV0IGluZGV4ID0gdGhpcy50cmFja3NfLmxlbmd0aDtcbiAgaWYgKCEoJycraW5kZXggaW4gdGhpcykpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc19baW5kZXhdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIEZuLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgfSkpO1xuICB0aGlzLnRyYWNrc18ucHVzaCh0cmFjayk7XG5cbiAgdGhpcy50cmlnZ2VyKHtcbiAgICB0eXBlOiAnYWRkdHJhY2snLFxuICAgIHRyYWNrOiB0cmFja1xuICB9KTtcbn07XG5cblRleHRUcmFja0xpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrXyA9IGZ1bmN0aW9uKHJ0cmFjaykge1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgbGV0IHRyYWNrO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0cmFjayA9IHRoaXNbaV07XG4gICAgaWYgKHRyYWNrID09PSBydHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2tzXy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLnRyaWdnZXIoe1xuICAgIHR5cGU6ICdyZW1vdmV0cmFjaycsXG4gICAgdHJhY2s6IHRyYWNrXG4gIH0pO1xufTtcblxuVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUuZ2V0VHJhY2tCeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCB0cmFjayA9IHRoaXNbaV07XG4gICAgaWYgKHRyYWNrLmlkID09PSBpZCkge1xuICAgICAgcmVzdWx0ID0gdHJhY2s7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dFRyYWNrTGlzdDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuLi91dGlscy9ldmVudHMuanMnO1xuaW1wb3J0ICogYXMgRm4gZnJvbSAnLi4vdXRpbHMvZm4uanMnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi91dGlscy9sb2cuanMnO1xuaW1wb3J0IHNhZmVQYXJzZVR1cGxlIGZyb20gJ3NhZmUtanNvbi1wYXJzZS90dXBsZSc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG5jbGFzcyBUZXh0VHJhY2tTZXR0aW5ncyBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLmhpZGUoKTtcblxuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1kb25lLWJ1dHRvbicpLCAnY2xpY2snLCBGbi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0pKTtcblxuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1kZWZhdWx0LWJ1dHRvbicpLCAnY2xpY2snLCBGbi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWJnLWNvbG9yID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLndpbmRvdy1jb2xvciA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1iZy1vcGFjaXR5ID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy13aW5kb3ctb3BhY2l0eSA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtZWRnZS1zdHlsZSBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZvbnQtZmFtaWx5IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtZm9udC1wZXJjZW50IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAyO1xuICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSkpO1xuXG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZnLWNvbG9yID4gc2VsZWN0JyksICdjaGFuZ2UnLCBGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1iZy1jb2xvciA+IHNlbGVjdCcpLCAnY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy53aW5kb3ctY29sb3IgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLXRleHQtb3BhY2l0eSA+IHNlbGVjdCcpLCAnY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtYmctb3BhY2l0eSA+IHNlbGVjdCcpLCAnY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtd2luZG93LW9wYWNpdHkgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZvbnQtcGVyY2VudCBzZWxlY3QnKSwgJ2NoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWVkZ2Utc3R5bGUgc2VsZWN0JyksICdjaGFuZ2UnLCBGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1mb250LWZhbWlseSBzZWxlY3QnKSwgJ2NoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG5cbiAgICBpZiAocGxheWVyLm9wdGlvbnMoKVsncGVyc2lzdFRleHRUcmFja1NldHRpbmdzJ10pIHtcbiAgICAgIHRoaXMucmVzdG9yZVNldHRpbmdzKCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY2FwdGlvbi1zZXR0aW5ncyB2anMtbW9kYWwtb3ZlcmxheScsXG4gICAgICBpbm5lckhUTUw6IGNhcHRpb25PcHRpb25zTWVudVRlbXBsYXRlKClcbiAgICB9KTtcbiAgfVxuXG4gIGdldFZhbHVlcygpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWwoKTtcblxuICAgIGNvbnN0IHRleHRFZGdlID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWVkZ2Utc3R5bGUgc2VsZWN0JykpO1xuICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZm9udC1mYW1pbHkgc2VsZWN0JykpO1xuICAgIGNvbnN0IGZnQ29sb3IgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgY29uc3QgdGV4dE9wYWNpdHkgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JykpO1xuICAgIGNvbnN0IGJnQ29sb3IgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtYmctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgY29uc3QgYmdPcGFjaXR5ID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnKSk7XG4gICAgY29uc3Qgd2luZG93Q29sb3IgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy53aW5kb3ctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgY29uc3Qgd2luZG93T3BhY2l0eSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwucXVlcnlTZWxlY3RvcignLnZqcy13aW5kb3ctb3BhY2l0eSA+IHNlbGVjdCcpKTtcbiAgICBjb25zdCBmb250UGVyY2VudCA9IHdpbmRvd1sncGFyc2VGbG9hdCddKGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwucXVlcnlTZWxlY3RvcignLnZqcy1mb250LXBlcmNlbnQgPiBzZWxlY3QnKSkpO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICdiYWNrZ3JvdW5kT3BhY2l0eSc6IGJnT3BhY2l0eSxcbiAgICAgICd0ZXh0T3BhY2l0eSc6IHRleHRPcGFjaXR5LFxuICAgICAgJ3dpbmRvd09wYWNpdHknOiB3aW5kb3dPcGFjaXR5LFxuICAgICAgJ2VkZ2VTdHlsZSc6IHRleHRFZGdlLFxuICAgICAgJ2ZvbnRGYW1pbHknOiBmb250RmFtaWx5LFxuICAgICAgJ2NvbG9yJzogZmdDb2xvcixcbiAgICAgICdiYWNrZ3JvdW5kQ29sb3InOiBiZ0NvbG9yLFxuICAgICAgJ3dpbmRvd0NvbG9yJzogd2luZG93Q29sb3IsXG4gICAgICAnZm9udFBlcmNlbnQnOiBmb250UGVyY2VudFxuICAgIH07XG4gICAgZm9yIChsZXQgbmFtZSBpbiByZXN1bHQpIHtcbiAgICAgIGlmIChyZXN1bHRbbmFtZV0gPT09ICcnIHx8IHJlc3VsdFtuYW1lXSA9PT0gJ25vbmUnIHx8IChuYW1lID09PSAnZm9udFBlcmNlbnQnICYmIHJlc3VsdFtuYW1lXSA9PT0gMS4wMCkpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdFtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHNldFZhbHVlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWwoKTtcblxuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZWRnZS1zdHlsZSBzZWxlY3QnKSwgdmFsdWVzLmVkZ2VTdHlsZSk7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLnZqcy1mb250LWZhbWlseSBzZWxlY3QnKSwgdmFsdWVzLmZvbnRGYW1pbHkpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKSwgdmFsdWVzLmNvbG9yKTtcbiAgICBzZXRTZWxlY3RlZE9wdGlvbihlbC5xdWVyeVNlbGVjdG9yKCcudmpzLXRleHQtb3BhY2l0eSA+IHNlbGVjdCcpLCB2YWx1ZXMudGV4dE9wYWNpdHkpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtYmctY29sb3IgPiBzZWxlY3QnKSwgdmFsdWVzLmJhY2tncm91bmRDb2xvcik7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLnZqcy1iZy1vcGFjaXR5ID4gc2VsZWN0JyksIHZhbHVlcy5iYWNrZ3JvdW5kT3BhY2l0eSk7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLndpbmRvdy1jb2xvciA+IHNlbGVjdCcpLCB2YWx1ZXMud2luZG93Q29sb3IpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtd2luZG93LW9wYWNpdHkgPiBzZWxlY3QnKSwgdmFsdWVzLndpbmRvd09wYWNpdHkpO1xuXG4gICAgbGV0IGZvbnRQZXJjZW50ID0gdmFsdWVzLmZvbnRQZXJjZW50O1xuXG4gICAgaWYgKGZvbnRQZXJjZW50KSB7XG4gICAgICBmb250UGVyY2VudCA9IGZvbnRQZXJjZW50LnRvRml4ZWQoMik7XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLnZqcy1mb250LXBlcmNlbnQgPiBzZWxlY3QnKSwgZm9udFBlcmNlbnQpO1xuICB9XG5cbiAgcmVzdG9yZVNldHRpbmdzKCkge1xuICAgIGxldCBbZXJyLCB2YWx1ZXNdID0gc2FmZVBhcnNlVHVwbGUod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCd2anMtdGV4dC10cmFjay1zZXR0aW5ncycpKTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKHZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgc2F2ZVNldHRpbmdzKCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLm9wdGlvbnMoKVsncGVyc2lzdFRleHRUcmFja1NldHRpbmdzJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlcykubGVuZ3RoID4gMCkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJywgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgbGV0IHR0RGlzcGxheSA9IHRoaXMucGxheWVyXy5nZXRDaGlsZCgndGV4dFRyYWNrRGlzcGxheScpO1xuICAgIGlmICh0dERpc3BsYXkpIHtcbiAgICAgIHR0RGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tTZXR0aW5ncycsIFRleHRUcmFja1NldHRpbmdzKTtcblxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0YXJnZXQpIHtcbiAgbGV0IHNlbGVjdGVkT3B0aW9uO1xuICAvLyBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgc2VsZWN0ZWRPcHRpb25zLCBzbywgZmFsbGJhY2sgdG8gb3B0aW9uc1xuICBpZiAodGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykge1xuICAgIHNlbGVjdGVkT3B0aW9uID0gdGFyZ2V0LnNlbGVjdGVkT3B0aW9uc1swXTtcbiAgfSBlbHNlIGlmICh0YXJnZXQub3B0aW9ucykge1xuICAgIHNlbGVjdGVkT3B0aW9uID0gdGFyZ2V0Lm9wdGlvbnNbdGFyZ2V0Lm9wdGlvbnMuc2VsZWN0ZWRJbmRleF07XG4gIH1cblxuICByZXR1cm4gc2VsZWN0ZWRPcHRpb24udmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0Lm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvcHRpb24gPSB0YXJnZXQub3B0aW9uc1tpXTtcbiAgICBpZiAob3B0aW9uLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnNlbGVjdGVkSW5kZXggPSBpO1xufVxuXG5mdW5jdGlvbiBjYXB0aW9uT3B0aW9uc01lbnVUZW1wbGF0ZSgpIHtcbiAgbGV0IHRlbXBsYXRlID0gYDxkaXYgY2xhc3M9XCJ2anMtdHJhY2tzZXR0aW5nc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInZqcy10cmFja3NldHRpbmdzLWNvbG9yc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZnLWNvbG9yIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInZqcy1sYWJlbFwiPkZvcmVncm91bmQ8L2xhYmVsPlxuICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPi0tLTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0ZGRlwiPldoaXRlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDAwXCI+QmxhY2s8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGMDBcIj5SZWQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwRjBcIj5HcmVlbjwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzAwRlwiPkJsdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGRjBcIj5ZZWxsb3c8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGMEZcIj5NYWdlbnRhPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEZGXCI+Q3lhbjwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZqcy10ZXh0LW9wYWNpdHkgdmpzLW9wYWNpdHlcIj5cbiAgICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj5PcGFxdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMC41XCI+U2VtaS1PcGFxdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PiA8IS0tIHZqcy1mZy1jb2xvciAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZqcy1iZy1jb2xvciB2anMtdHJhY2tzZXR0aW5nXCI+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5CYWNrZ3JvdW5kPC9sYWJlbD5cbiAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4tLS08L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGRkZcIj5XaGl0ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzAwMFwiPkJsYWNrPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjAwXCI+UmVkPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEYwXCI+R3JlZW48L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwMEZcIj5CbHVlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkYwXCI+WWVsbG93PC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjBGXCI+TWFnZW50YTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzBGRlwiPkN5YW48L29wdGlvbj5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtYmctb3BhY2l0eSB2anMtb3BhY2l0eVwiPlxuICAgICAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMVwiPk9wYXF1ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNVwiPlNlbWktVHJhbnNwYXJlbnQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCI+VHJhbnNwYXJlbnQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+IDwhLS0gdmpzLWJnLWNvbG9yIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwid2luZG93LWNvbG9yIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInZqcy1sYWJlbFwiPldpbmRvdzwvbGFiZWw+XG4gICAgICAgICAgICA8c2VsZWN0PlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkZGXCI+V2hpdGU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwMDBcIj5CbGFjazwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0YwMFwiPlJlZDwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzBGMFwiPkdyZWVuPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDBGXCI+Qmx1ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0ZGMFwiPlllbGxvdzwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0YwRlwiPk1hZ2VudGE8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwRkZcIj5DeWFuPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmpzLXdpbmRvdy1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4tLS08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+T3BhcXVlPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMC41XCI+U2VtaS1UcmFuc3BhcmVudDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjBcIj5UcmFuc3BhcmVudDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj4gPCEtLSB2anMtd2luZG93LWNvbG9yIC0tPlxuICAgICAgPC9kaXY+IDwhLS0gdmpzLXRyYWNrc2V0dGluZ3MgLS0+XG4gICAgICA8ZGl2IGNsYXNzPVwidmpzLXRyYWNrc2V0dGluZ3MtZm9udFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZvbnQtcGVyY2VudCB2anMtdHJhY2tzZXR0aW5nXCI+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwidmpzLWxhYmVsXCI+Rm9udCBTaXplPC9sYWJlbD5cbiAgICAgICAgICA8c2VsZWN0PlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNTBcIj41MCU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwLjc1XCI+NzUlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMS4wMFwiIHNlbGVjdGVkPjEwMCU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxLjI1XCI+MTI1JTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEuNTBcIj4xNTAlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMS43NVwiPjE3NSU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyLjAwXCI+MjAwJTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjMuMDBcIj4zMDAlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNC4wMFwiPjQwMCU8L29wdGlvbj5cbiAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+IDwhLS0gdmpzLWZvbnQtcGVyY2VudCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZqcy1lZGdlLXN0eWxlIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5UZXh0IEVkZ2UgU3R5bGU8L2xhYmVsPlxuICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibm9uZVwiPk5vbmU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyYWlzZWRcIj5SYWlzZWQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJkZXByZXNzZWRcIj5EZXByZXNzZWQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJ1bmlmb3JtXCI+VW5pZm9ybTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImRyb3BzaGFkb3dcIj5Ecm9wc2hhZG93PC9vcHRpb24+XG4gICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PiA8IS0tIHZqcy1lZGdlLXN0eWxlIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZvbnQtZmFtaWx5IHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5Gb250IEZhbWlseTwvbGFiZWw+XG4gICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj5EZWZhdWx0PC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibW9ub3NwYWNlU2VyaWZcIj5Nb25vc3BhY2UgU2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJwcm9wb3J0aW9uYWxTZXJpZlwiPlByb3BvcnRpb25hbCBTZXJpZjwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1vbm9zcGFjZVNhbnNTZXJpZlwiPk1vbm9zcGFjZSBTYW5zLVNlcmlmPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicHJvcG9ydGlvbmFsU2Fuc1NlcmlmXCI+UHJvcG9ydGlvbmFsIFNhbnMtU2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjYXN1YWxcIj5DYXN1YWw8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzY3JpcHRcIj5TY3JpcHQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzbWFsbC1jYXBzXCI+U21hbGwgQ2Fwczwvb3B0aW9uPlxuICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L2Rpdj4gPCEtLSB2anMtZm9udC1mYW1pbHkgLS0+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidmpzLXRyYWNrc2V0dGluZ3MtY29udHJvbHNcIj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJ2anMtZGVmYXVsdC1idXR0b25cIj5EZWZhdWx0czwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cInZqcy1kb25lLWJ1dHRvblwiPkRvbmU8L2J1dHRvbj5cbiAgICA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2tTZXR0aW5ncztcbiIsImltcG9ydCBUZXh0VHJhY2tDdWVMaXN0IGZyb20gJy4vdGV4dC10cmFjay1jdWUtbGlzdCc7XG5pbXBvcnQgKiBhcyBGbiBmcm9tICcuLi91dGlscy9mbi5qcyc7XG5pbXBvcnQgKiBhcyBHdWlkIGZyb20gJy4uL3V0aWxzL2d1aWQuanMnO1xuaW1wb3J0ICogYXMgYnJvd3NlciBmcm9tICcuLi91dGlscy9icm93c2VyLmpzJztcbmltcG9ydCAqIGFzIFRleHRUcmFja0VudW0gZnJvbSAnLi90ZXh0LXRyYWNrLWVudW1zJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vdXRpbHMvbG9nLmpzJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgWEhSIGZyb20gJy4uL3hoci5qcyc7XG5cbi8qXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrXG4gKlxuICogaW50ZXJmYWNlIFRleHRUcmFjayA6IEV2ZW50VGFyZ2V0IHtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIFRleHRUcmFja0tpbmQga2luZDtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBsYWJlbDtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBsYW5ndWFnZTtcbiAqXG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgaWQ7XG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZTtcbiAqXG4gKiAgIGF0dHJpYnV0ZSBUZXh0VHJhY2tNb2RlIG1vZGU7XG4gKlxuICogICByZWFkb25seSBhdHRyaWJ1dGUgVGV4dFRyYWNrQ3VlTGlzdD8gY3VlcztcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIFRleHRUcmFja0N1ZUxpc3Q/IGFjdGl2ZUN1ZXM7XG4gKlxuICogICB2b2lkIGFkZEN1ZShUZXh0VHJhY2tDdWUgY3VlKTtcbiAqICAgdm9pZCByZW1vdmVDdWUoVGV4dFRyYWNrQ3VlIGN1ZSk7XG4gKlxuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9uY3VlY2hhbmdlO1xuICogfTtcbiAqL1xubGV0IFRleHRUcmFjayA9IGZ1bmN0aW9uKG9wdGlvbnM9e30pIHtcbiAgaWYgKCFvcHRpb25zLnRlY2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGVjaCB3YXMgbm90IHByb3ZpZGVkLicpO1xuICB9XG5cbiAgbGV0IHR0ID0gdGhpcztcbiAgaWYgKGJyb3dzZXIuSVNfSUU4KSB7XG4gICAgdHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgIGZvciAobGV0IHByb3AgaW4gVGV4dFRyYWNrLnByb3RvdHlwZSkge1xuICAgICAgdHRbcHJvcF0gPSBUZXh0VHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHR0LnRlY2hfID0gb3B0aW9ucy50ZWNoO1xuXG4gIGxldCBtb2RlID0gVGV4dFRyYWNrRW51bS5UZXh0VHJhY2tNb2RlW29wdGlvbnNbJ21vZGUnXV0gfHwgJ2Rpc2FibGVkJztcbiAgbGV0IGtpbmQgPSBUZXh0VHJhY2tFbnVtLlRleHRUcmFja0tpbmRbb3B0aW9uc1sna2luZCddXSB8fCAnc3VidGl0bGVzJztcbiAgbGV0IGxhYmVsID0gb3B0aW9uc1snbGFiZWwnXSB8fCAnJztcbiAgbGV0IGxhbmd1YWdlID0gb3B0aW9uc1snbGFuZ3VhZ2UnXSB8fCBvcHRpb25zWydzcmNsYW5nJ10gfHwgJyc7XG4gIGxldCBpZCA9IG9wdGlvbnNbJ2lkJ10gfHwgJ3Zqc190ZXh0X3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKTtcblxuICBpZiAoa2luZCA9PT0gJ21ldGFkYXRhJyB8fCBraW5kID09PSAnY2hhcHRlcnMnKSB7XG4gICAgbW9kZSA9ICdoaWRkZW4nO1xuICB9XG5cbiAgdHQuY3Vlc18gPSBbXTtcbiAgdHQuYWN0aXZlQ3Vlc18gPSBbXTtcblxuICBsZXQgY3VlcyA9IG5ldyBUZXh0VHJhY2tDdWVMaXN0KHR0LmN1ZXNfKTtcbiAgbGV0IGFjdGl2ZUN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5hY3RpdmVDdWVzXyk7XG5cbiAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgbGV0IHRpbWV1cGRhdGVIYW5kbGVyID0gRm4uYmluZCh0dCwgZnVuY3Rpb24oKSB7XG4gICAgdGhpc1snYWN0aXZlQ3VlcyddO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzWyd0cmlnZ2VyJ10oJ2N1ZWNoYW5nZScpO1xuICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChtb2RlICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgdHQudGVjaF8ub24oJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlSGFuZGxlcik7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdraW5kJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ga2luZDtcbiAgICB9LFxuICAgIHNldDogRnVuY3Rpb24ucHJvdG90eXBlXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2xhYmVsJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbGFiZWw7XG4gICAgfSxcbiAgICBzZXQ6IEZ1bmN0aW9uLnByb3RvdHlwZVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdsYW5ndWFnZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxhbmd1YWdlO1xuICAgIH0sXG4gICAgc2V0OiBGdW5jdGlvbi5wcm90b3R5cGVcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnaWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICAgIHNldDogRnVuY3Rpb24ucHJvdG90eXBlXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ21vZGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihuZXdNb2RlKSB7XG4gICAgICBpZiAoIVRleHRUcmFja0VudW0uVGV4dFRyYWNrTW9kZVtuZXdNb2RlXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtb2RlID0gbmV3TW9kZTtcbiAgICAgIGlmIChtb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdGhpcy50ZWNoXy5vbigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcignbW9kZWNoYW5nZScpO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnY3VlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmxvYWRlZF8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdWVzO1xuICAgIH0sXG4gICAgc2V0OiBGdW5jdGlvbi5wcm90b3R5cGVcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnYWN0aXZlQ3VlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmxvYWRlZF8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzWydjdWVzJ10ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVDdWVzOyAvLyBub3RoaW5nIHRvIGRvXG4gICAgICB9XG5cbiAgICAgIGxldCBjdCA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgIGxldCBhY3RpdmUgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzWydjdWVzJ10ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGxldCBjdWUgPSB0aGlzWydjdWVzJ11baV07XG4gICAgICAgIGlmIChjdWVbJ3N0YXJ0VGltZSddIDw9IGN0ICYmIGN1ZVsnZW5kVGltZSddID49IGN0KSB7XG4gICAgICAgICAgYWN0aXZlLnB1c2goY3VlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdWVbJ3N0YXJ0VGltZSddID09PSBjdWVbJ2VuZFRpbWUnXSAmJiBjdWVbJ3N0YXJ0VGltZSddIDw9IGN0ICYmIGN1ZVsnc3RhcnRUaW1lJ10gKyAwLjUgPj0gY3QpIHtcbiAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggIT09IHRoaXMuYWN0aXZlQ3Vlc18ubGVuZ3RoKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKHRoaXMuYWN0aXZlQ3Vlc18sIGFjdGl2ZVtpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hY3RpdmVDdWVzXyA9IGFjdGl2ZTtcbiAgICAgIGFjdGl2ZUN1ZXMuc2V0Q3Vlc18odGhpcy5hY3RpdmVDdWVzXyk7XG5cbiAgICAgIHJldHVybiBhY3RpdmVDdWVzO1xuICAgIH0sXG4gICAgc2V0OiBGdW5jdGlvbi5wcm90b3R5cGVcbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMuc3JjKSB7XG4gICAgbG9hZFRyYWNrKG9wdGlvbnMuc3JjLCB0dCk7XG4gIH0gZWxzZSB7XG4gICAgdHQubG9hZGVkXyA9IHRydWU7XG4gIH1cblxuICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICByZXR1cm4gdHQ7XG4gIH1cbn07XG5cblRleHRUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuVGV4dFRyYWNrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRUcmFjaztcblxuLypcbiAqIGN1ZWNoYW5nZSAtIE9uZSBvciBtb3JlIGN1ZXMgaW4gdGhlIHRyYWNrIGhhdmUgYmVjb21lIGFjdGl2ZSBvciBzdG9wcGVkIGJlaW5nIGFjdGl2ZS5cbiAqL1xuVGV4dFRyYWNrLnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHtcbiAgJ2N1ZWNoYW5nZSc6ICdjdWVjaGFuZ2UnXG59O1xuXG5UZXh0VHJhY2sucHJvdG90eXBlLmFkZEN1ZSA9IGZ1bmN0aW9uKGN1ZSkge1xuICBsZXQgdHJhY2tzID0gdGhpcy50ZWNoXy50ZXh0VHJhY2tzKCk7XG5cbiAgaWYgKHRyYWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tzW2ldICE9PSB0aGlzKSB7XG4gICAgICAgIHRyYWNrc1tpXS5yZW1vdmVDdWUoY3VlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmN1ZXNfLnB1c2goY3VlKTtcbiAgdGhpc1snY3VlcyddLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xufTtcblxuVGV4dFRyYWNrLnByb3RvdHlwZS5yZW1vdmVDdWUgPSBmdW5jdGlvbihyZW1vdmVDdWUpIHtcbiAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY3Vlc18ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGN1ZSA9IHRoaXMuY3Vlc19baV07XG4gICAgaWYgKGN1ZSA9PT0gcmVtb3ZlQ3VlKSB7XG4gICAgICB0aGlzLmN1ZXNfLnNwbGljZShpLCAxKTtcbiAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1vdmVkKSB7XG4gICAgdGhpcy5jdWVzLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xuICB9XG59O1xuXG4vKlxuICogRG93bmxvYWRpbmcgc3R1ZmYgaGFwcGVucyBiZWxvdyB0aGlzIHBvaW50XG4gKi9cbnZhciBwYXJzZUN1ZXMgPSBmdW5jdGlvbihzcmNDb250ZW50LCB0cmFjaykge1xuICBpZiAodHlwZW9mIHdpbmRvd1snV2ViVlRUJ10gIT09ICdmdW5jdGlvbicpIHtcbiAgICAvL3RyeSBhZ2FpbiBhIGJpdCBsYXRlclxuICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHBhcnNlQ3VlcyhzcmNDb250ZW50LCB0cmFjayk7XG4gICAgfSwgMjUpO1xuICB9XG5cbiAgbGV0IHBhcnNlciA9IG5ldyB3aW5kb3dbJ1dlYlZUVCddWydQYXJzZXInXSh3aW5kb3csIHdpbmRvd1sndnR0anMnXSwgd2luZG93WydXZWJWVFQnXVsnU3RyaW5nRGVjb2RlciddKCkpO1xuXG4gIHBhcnNlclsnb25jdWUnXSA9IGZ1bmN0aW9uKGN1ZSkge1xuICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICB9O1xuICBwYXJzZXJbJ29ucGFyc2luZ2Vycm9yJ10gPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGxvZy5lcnJvcihlcnJvcik7XG4gIH07XG5cbiAgcGFyc2VyWydwYXJzZSddKHNyY0NvbnRlbnQpO1xuICBwYXJzZXJbJ2ZsdXNoJ10oKTtcbn07XG5cbnZhciBsb2FkVHJhY2sgPSBmdW5jdGlvbihzcmMsIHRyYWNrKSB7XG4gIFhIUihzcmMsIEZuLmJpbmQodGhpcywgZnVuY3Rpb24oZXJyLCByZXNwb25zZSwgcmVzcG9uc2VCb2R5KXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gbG9nLmVycm9yKGVycik7XG4gICAgfVxuXG5cbiAgICB0cmFjay5sb2FkZWRfID0gdHJ1ZTtcbiAgICBwYXJzZUN1ZXMocmVzcG9uc2VCb2R5LCB0cmFjayk7XG4gIH0pKTtcbn07XG5cbnZhciBpbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gIGlmICh0aGlzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gIH1cblxuICBsZXQgTyA9IE9iamVjdCh0aGlzKTtcblxuICBsZXQgbGVuID0gTy5sZW5ndGggPj4+IDA7XG5cbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGxldCBuID0gK2Zyb21JbmRleCB8fCAwO1xuXG4gIGlmIChNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkpIHtcbiAgICBuID0gMDtcbiAgfVxuXG4gIGlmIChuID49IGxlbikge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGxldCBrID0gTWF0aC5tYXgobiA+PSAwID8gbiA6IGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcblxuICB3aGlsZSAoayA8IGxlbikge1xuICAgIGlmIChrIGluIE8gJiYgT1trXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIGsrKztcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2s7XG4iLCJpbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbmNvbnN0IFVTRVJfQUdFTlQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuLyoqXG4gKiBEZXZpY2UgaXMgYW4gaVBob25lXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IElTX0lQSE9ORSA9ICgvaVBob25lL2kpLnRlc3QoVVNFUl9BR0VOVCk7XG5leHBvcnQgY29uc3QgSVNfSVBBRCA9ICgvaVBhZC9pKS50ZXN0KFVTRVJfQUdFTlQpO1xuZXhwb3J0IGNvbnN0IElTX0lQT0QgPSAoL2lQb2QvaSkudGVzdChVU0VSX0FHRU5UKTtcbmV4cG9ydCBjb25zdCBJU19JT1MgPSBJU19JUEhPTkUgfHwgSVNfSVBBRCB8fCBJU19JUE9EO1xuXG5leHBvcnQgY29uc3QgSU9TX1ZFUlNJT04gPSAoZnVuY3Rpb24oKXtcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvT1MgKFxcZCspXy9pKTtcbiAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7IHJldHVybiBtYXRjaFsxXTsgfVxufSkoKTtcblxuZXhwb3J0IGNvbnN0IElTX0FORFJPSUQgPSAoL0FuZHJvaWQvaSkudGVzdChVU0VSX0FHRU5UKTtcbmV4cG9ydCBjb25zdCBBTkRST0lEX1ZFUlNJT04gPSAoZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgbWF0Y2hlcyBBbmRyb2lkIE1ham9yLk1pbm9yLlBhdGNoIHZlcnNpb25zXG4gIC8vIEFORFJPSURfVkVSU0lPTiBpcyBNYWpvci5NaW5vciBhcyBhIE51bWJlciwgaWYgTWlub3IgaXNuJ3QgYXZhaWxhYmxlLCB0aGVuIG9ubHkgTWFqb3IgaXMgcmV0dXJuZWRcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQW5kcm9pZCAoXFxkKykoPzpcXC4oXFxkKykpPyg/OlxcLihcXGQrKSkqL2kpLFxuICAgIG1ham9yLFxuICAgIG1pbm9yO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG1ham9yID0gbWF0Y2hbMV0gJiYgcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIG1pbm9yID0gbWF0Y2hbMl0gJiYgcGFyc2VGbG9hdChtYXRjaFsyXSk7XG5cbiAgaWYgKG1ham9yICYmIG1pbm9yKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0gKyAnLicgKyBtYXRjaFsyXSk7XG4gIH0gZWxzZSBpZiAobWFqb3IpIHtcbiAgICByZXR1cm4gbWFqb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0pKCk7XG4vLyBPbGQgQW5kcm9pZCBpcyBkZWZpbmVkIGFzIFZlcnNpb24gb2xkZXIgdGhhbiAyLjMsIGFuZCByZXF1aXJpbmcgYSB3ZWJraXQgdmVyc2lvbiBvZiB0aGUgYW5kcm9pZCBicm93c2VyXG5leHBvcnQgY29uc3QgSVNfT0xEX0FORFJPSUQgPSBJU19BTkRST0lEICYmICgvd2Via2l0L2kpLnRlc3QoVVNFUl9BR0VOVCkgJiYgQU5EUk9JRF9WRVJTSU9OIDwgMi4zO1xuXG5leHBvcnQgY29uc3QgSVNfRklSRUZPWCA9ICgvRmlyZWZveC9pKS50ZXN0KFVTRVJfQUdFTlQpO1xuZXhwb3J0IGNvbnN0IElTX0NIUk9NRSA9ICgvQ2hyb21lL2kpLnRlc3QoVVNFUl9BR0VOVCk7XG5leHBvcnQgY29uc3QgSVNfSUU4ID0gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KFVTRVJfQUdFTlQpO1xuXG5leHBvcnQgY29uc3QgVE9VQ0hfRU5BQkxFRCA9ICEhKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpO1xuZXhwb3J0IGNvbnN0IEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQgPSAnYmFja2dyb3VuZFNpemUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJykuc3R5bGU7XG4iLCJpbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgKiBhcyBHdWlkIGZyb20gJy4vZ3VpZC5qcyc7XG5pbXBvcnQgcm91bmRGbG9hdCBmcm9tICcuL3JvdW5kLWZsb2F0LmpzJztcblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKClcbiAqIEFsc28gYWxsb3dzIGZvciBDU1MgKGpRdWVyeSkgSUQgc3ludGF4LiBCdXQgbm90aGluZyBvdGhlciB0aGFuIElEcy5cbiAqIEBwYXJhbSAge1N0cmluZ30gaWQgIEVsZW1lbnQgSURcbiAqIEByZXR1cm4ge0VsZW1lbnR9ICAgIEVsZW1lbnQgd2l0aCBzdXBwbGllZCBJRFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGVsID0gZnVuY3Rpb24oaWQpe1xuICBpZiAoaWQuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgaWQgPSBpZC5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxuICogQHBhcmFtICB7U3RyaW5nPX0gdGFnTmFtZSAgICBOYW1lIG9mIHRhZyB0byBiZSBjcmVhdGVkLlxuICogQHBhcmFtICB7T2JqZWN0PX0gcHJvcGVydGllcyBFbGVtZW50IHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRWwgPSBmdW5jdGlvbih0YWdOYW1lPSdkaXYnLCBwcm9wZXJ0aWVzPXt9KXtcbiAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BOYW1lKXtcbiAgICAgIGxldCB2YWwgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgLy8gTm90IHJlbWVtYmVyaW5nIHdoeSB3ZSB3ZXJlIGNoZWNraW5nIGZvciBkYXNoXG4gICAgICAvLyBidXQgdXNpbmcgc2V0QXR0cmlidXRlIG1lYW5zIHlvdSBoYXZlIHRvIHVzZSBnZXRBdHRyaWJ1dGVcblxuICAgICAgLy8gVGhlIGNoZWNrIGZvciBkYXNoIGNoZWNrcyBmb3IgdGhlIGFyaWEtKiBhdHRyaWJ1dGVzLCBsaWtlIGFyaWEtbGFiZWwsIGFyaWEtdmFsdWVtaW4uXG4gICAgICAvLyBUaGUgYWRkaXRpb25hbCBjaGVjayBmb3IgXCJyb2xlXCIgaXMgYmVjYXVzZSB0aGUgZGVmYXVsdCBtZXRob2QgZm9yIGFkZGluZyBhdHRyaWJ1dGVzIGRvZXMgbm90XG4gICAgICAvLyBhZGQgdGhlIGF0dHJpYnV0ZSBcInJvbGVcIi4gTXkgZ3Vlc3MgaXMgYmVjYXVzZSBpdCdzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBpbiBzb21lIG5hbWVzcGFjZXMsIGFsdGhvdWdoXG4gICAgICAvLyBicm93c2VycyBoYW5kbGUgdGhlIGF0dHJpYnV0ZSBqdXN0IGZpbmUuIFRoZSBXM0MgYWxsb3dzIGZvciBhcmlhLSogYXR0cmlidXRlcyB0byBiZSB1c2VkIGluIHByZS1IVE1MNSBkb2NzLlxuICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJpbWVyLyNhcmlhaHRtbC4gVXNpbmcgc2V0QXR0cmlidXRlIGdldHMgYXJvdW5kIHRoaXMgcHJvYmxlbS5cbiAgICAgIGlmIChwcm9wTmFtZS5pbmRleE9mKCdhcmlhLScpICE9PSAtMSB8fCBwcm9wTmFtZSA9PT0gJ3JvbGUnKSB7XG4gICAgICAgZWwuc2V0QXR0cmlidXRlKHByb3BOYW1lLCB2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICBlbFtwcm9wTmFtZV0gPSB2YWw7XG4gICAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbDtcbn07XG5cbi8qKlxuICogSW5zZXJ0IGFuIGVsZW1lbnQgYXMgdGhlIGZpcnN0IGNoaWxkIG5vZGUgb2YgYW5vdGhlclxuICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgICBFbGVtZW50IHRvIGluc2VydFxuICogQHBhcmFtICB7W3R5cGVdfSBwYXJlbnQgRWxlbWVudCB0byBpbnNlcnQgY2hpbGQgaW50b1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGluc2VydEZpcnN0ID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCl7XG4gIGlmIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59O1xuXG4vKipcbiAqIEVsZW1lbnQgRGF0YSBTdG9yZS4gQWxsb3dzIGZvciBiaW5kaW5nIGRhdGEgdG8gYW4gZWxlbWVudCB3aXRob3V0IHB1dHRpbmcgaXQgZGlyZWN0bHkgb24gdGhlIGVsZW1lbnQuXG4gKiBFeC4gRXZlbnQgbGlzdGVuZXJzIGFyZSBzdG9yZWQgaGVyZS5cbiAqIChhbHNvIGZyb20ganNuaW5qYS5jb20sIHNsaWdodGx5IG1vZGlmaWVkIGFuZCB1cGRhdGVkIGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBjYWNoZSA9IHt9O1xuXG4vKipcbiAqIFVuaXF1ZSBhdHRyaWJ1dGUgbmFtZSB0byBzdG9yZSBhbiBlbGVtZW50J3MgZ3VpZCBpblxuICogQHR5cGUge1N0cmluZ31cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGFuZG8gPSAndmRhdGEnICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgd2hlcmUgZGF0YSBmb3IgYW4gZWxlbWVudCBpcyBzdG9yZWRcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsIEVsZW1lbnQgdG8gc3RvcmUgZGF0YSBmb3IuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0RGF0YSA9IGZ1bmN0aW9uKGVsKXtcbiAgdmFyIGlkID0gZWxbZXhwYW5kb107XG4gIGlmICghaWQpIHtcbiAgICBpZCA9IGVsW2V4cGFuZG9dID0gR3VpZC5uZXdHVUlEKCk7XG4gIH1cbiAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICBjYWNoZVtpZF0gPSB7fTtcbiAgfVxuICByZXR1cm4gY2FjaGVbaWRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbCBBIGRvbSBlbGVtZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0RhdGEgPSBmdW5jdGlvbihlbCl7XG4gIGNvbnN0IGlkID0gZWxbZXhwYW5kb107XG5cbiAgaWYgKCFpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNhY2hlW2lkXSkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBEZWxldGUgZGF0YSBmb3IgdGhlIGVsZW1lbnQgZnJvbSB0aGUgY2FjaGUgYW5kIHRoZSBndWlkIGF0dHIgZnJvbSBnZXRFbGVtZW50QnlJZFxuICogQHBhcmFtICB7RWxlbWVudH0gZWwgUmVtb3ZlIGRhdGEgZm9yIGFuIGVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVEYXRhID0gZnVuY3Rpb24oZWwpe1xuICB2YXIgaWQgPSBlbFtleHBhbmRvXTtcbiAgaWYgKCFpZCkgeyByZXR1cm47IH1cbiAgLy8gUmVtb3ZlIGFsbCBzdG9yZWQgZGF0YVxuICAvLyBDaGFuZ2VkIHRvID0gbnVsbFxuICAvLyBodHRwOi8vY29kaW5nLnNtYXNoaW5nbWFnYXppbmUuY29tLzIwMTIvMTEvMDUvd3JpdGluZy1mYXN0LW1lbW9yeS1lZmZpY2llbnQtamF2YXNjcmlwdC9cbiAgLy8gY2FjaGVbaWRdID0gbnVsbDtcbiAgZGVsZXRlIGNhY2hlW2lkXTtcblxuICAvLyBSZW1vdmUgdGhlIGV4cGFuZG8gcHJvcGVydHkgZnJvbSB0aGUgRE9NIG5vZGVcbiAgdHJ5IHtcbiAgICBkZWxldGUgZWxbZXhwYW5kb107XG4gIH0gY2F0Y2goZSkge1xuICAgIGlmIChlbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShleHBhbmRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgZG9lc24ndCBhcHBlYXIgdG8gc3VwcG9ydCByZW1vdmVBdHRyaWJ1dGUgb24gdGhlIGRvY3VtZW50IGVsZW1lbnRcbiAgICAgIGVsW2V4cGFuZG9dID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb0NoZWNrIENsYXNzbmFtZSB0byBjaGVja1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0NsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NUb0NoZWNrKXtcbiAgcmV0dXJuICgoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NUb0NoZWNrICsgJyAnKSAhPT0gLTEpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICAgRWxlbWVudCB0byBhZGQgY2xhc3MgbmFtZSB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9BZGQgQ2xhc3NuYW1lIHRvIGFkZFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZENsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NUb0FkZCl7XG4gIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lID09PSAnJyA/IGNsYXNzVG9BZGQgOiBlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzVG9BZGQ7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICAgRWxlbWVudCB0byByZW1vdmUgZnJvbSBjbGFzcyBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb0FkZCBDbGFzc25hbWUgdG8gcmVtb3ZlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbGVtZW50LCBjbGFzc1RvUmVtb3ZlKXtcbiAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBjbGFzc1RvUmVtb3ZlKSkge3JldHVybjt9XG5cbiAgbGV0IGNsYXNzTmFtZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gIC8vIG5vIGFyci5pbmRleE9mIGluIGllOCwgYW5kIHdlIGRvbid0IHdhbnQgdG8gYWRkIGEgYmlnIHNoaW1cbiAgZm9yIChsZXQgaSA9IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoY2xhc3NOYW1lc1tpXSA9PT0gY2xhc3NUb1JlbW92ZSkge1xuICAgICAgY2xhc3NOYW1lcy5zcGxpY2UoaSwxKTtcbiAgICB9XG4gIH1cblxuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBBcHBseSBhdHRyaWJ1dGVzIHRvIGFuIEhUTUwgZWxlbWVudC5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsICAgICAgICAgVGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBhdHRyaWJ1dGVzIEVsZW1lbnQgYXR0cmlidXRlcyB0byBiZSBhcHBsaWVkLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEVsZW1lbnRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWwsIGF0dHJpYnV0ZXMpe1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJOYW1lKXtcbiAgICBsZXQgYXR0clZhbHVlID0gYXR0cmlidXRlc1thdHRyTmFtZV07XG5cbiAgICBpZiAoYXR0clZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBhdHRyVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IGF0dHJWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgKGF0dHJWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYXR0clZhbHVlKSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWVzLCBhcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRhZ1xuICogQXR0cmlidXRlcyBhcmUgbm90IHRoZSBzYW1lIGFzIHByb3BlcnRpZXMuIFRoZXkncmUgZGVmaW5lZCBvbiB0aGUgdGFnXG4gKiBvciB3aXRoIHNldEF0dHJpYnV0ZSAod2hpY2ggc2hvdWxkbid0IGJlIHVzZWQgd2l0aCBIVE1MKVxuICogVGhpcyB3aWxsIHJldHVybiB0cnVlIG9yIGZhbHNlIGZvciBib29sZWFuIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSB0YWcgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCB0YWcgYXR0cmlidXRlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRBdHRyaWJ1dGVzID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIG9iaiwga25vd25Cb29sZWFucywgYXR0cnMsIGF0dHJOYW1lLCBhdHRyVmFsO1xuXG4gIG9iaiA9IHt9O1xuXG4gIC8vIGtub3duIGJvb2xlYW4gYXR0cmlidXRlc1xuICAvLyB3ZSBjYW4gY2hlY2sgZm9yIG1hdGNoaW5nIGJvb2xlYW4gcHJvcGVydGllcywgYnV0IG9sZGVyIGJyb3dzZXJzXG4gIC8vIHdvbid0IGtub3cgYWJvdXQgSFRNTDUgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgd2Ugc3RpbGwgcmVhZCBmcm9tXG4gIGtub3duQm9vbGVhbnMgPSAnLCcrJ2F1dG9wbGF5LGNvbnRyb2xzLGxvb3AsbXV0ZWQsZGVmYXVsdCcrJywnO1xuXG4gIGlmICh0YWcgJiYgdGFnLmF0dHJpYnV0ZXMgJiYgdGFnLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIGF0dHJzID0gdGFnLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGF0dHJOYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgIGF0dHJWYWwgPSBhdHRyc1tpXS52YWx1ZTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGtub3duIGJvb2xlYW5zXG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgZWxlbWVudCBwcm9wZXJ0eSB3aWxsIHJldHVybiBhIHZhbHVlIGZvciB0eXBlb2ZcbiAgICAgIGlmICh0eXBlb2YgdGFnW2F0dHJOYW1lXSA9PT0gJ2Jvb2xlYW4nIHx8IGtub3duQm9vbGVhbnMuaW5kZXhPZignLCcrYXR0ck5hbWUrJywnKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIGFuIGluY2x1ZGVkIGJvb2xlYW4gYXR0cmlidXRlIGlzIHR5cGljYWxseSBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcgKCcnKSB3aGljaCB3b3VsZCBlcXVhbCBmYWxzZSBpZiB3ZSBqdXN0IGNoZWNrIGZvciBhIGZhbHNlIHZhbHVlLlxuICAgICAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgc3VwcG9ydCBiYWQgY29kZSBsaWtlIGF1dG9wbGF5PSdmYWxzZSdcbiAgICAgICAgYXR0clZhbCA9IChhdHRyVmFsICE9PSBudWxsKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2JqW2F0dHJOYW1lXSA9IGF0dHJWYWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb21wdXRlZCBzdHlsZSB2YWx1ZSBmb3IgYW4gZWxlbWVudFxuICogRnJvbSBodHRwOi8vcm9iZXJ0bnltYW4uY29tLzIwMDYvMDQvMjQvZ2V0LXRoZS1yZW5kZXJlZC1zdHlsZS1vZi1hbi1lbGVtZW50L1xuICogQHBhcmFtICB7RWxlbWVudH0gZWwgICAgICAgIEVsZW1lbnQgdG8gZ2V0IHN0eWxlIHZhbHVlIGZvclxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJDc3NSdWxlIFN0eWxlIG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICBTdHlsZSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldENvbXB1dGVkRGltZW5zaW9uID0gZnVuY3Rpb24oZWwsIHN0ckNzc1J1bGUpe1xuICB2YXIgc3RyVmFsdWUgPSAnJztcbiAgaWYoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSl7XG4gICAgc3RyVmFsdWUgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJykuZ2V0UHJvcGVydHlWYWx1ZShzdHJDc3NSdWxlKTtcblxuICB9IGVsc2UgaWYoZWwuY3VycmVudFN0eWxlKXtcbiAgICAvLyBJRTggV2lkdGgvSGVpZ2h0IHN1cHBvcnRcbiAgICBsZXQgdXBwZXJDYXNlZFJ1bGUgPSBzdHJDc3NSdWxlLnN1YnN0cigwLDEpLnRvVXBwZXJDYXNlKCkgKyBzdHJDc3NSdWxlLnN1YnN0cigxKTtcbiAgICBzdHJWYWx1ZSA9IGVsW2BjbGllbnQke3VwcGVyQ2FzZWRSdWxlfWBdICsgJ3B4JztcbiAgfVxuICByZXR1cm4gc3RyVmFsdWU7XG59O1xuXG4vLyBBdHRlbXB0IHRvIGJsb2NrIHRoZSBhYmlsaXR5IHRvIHNlbGVjdCB0ZXh0IHdoaWxlIGRyYWdnaW5nIGNvbnRyb2xzXG5leHBvcnQgY29uc3QgYmxvY2tUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24oKXtcbiAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG59O1xuLy8gVHVybiBvZmYgdGV4dCBzZWxlY3Rpb24gYmxvY2tpbmdcbmV4cG9ydCBjb25zdCB1bmJsb2NrVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCl7IGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9OyB9O1xuXG4vLyBPZmZzZXQgTGVmdFxuLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRlY2huaXF1ZSBmcm9tIEpvaG4gUmVzaWcgaHR0cDovL2Vqb2huLm9yZy9ibG9nL2dldGJvdW5kaW5nY2xpZW50cmVjdC1pcy1hd2Vzb21lL1xuZXhwb3J0IGNvbnN0IGZpbmRQb3NpdGlvbiA9IGZ1bmN0aW9uKGVsKSB7XG4gIGxldCBib3g7XG5cbiAgaWYgKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBpZiAoIWJveCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICBjb25zdCBjbGllbnRMZWZ0ID0gZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgY29uc3Qgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBib2R5LnNjcm9sbExlZnQ7XG4gIGNvbnN0IGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xuXG4gIGNvbnN0IGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgYm9keS5zY3JvbGxUb3A7XG4gIGNvbnN0IHRvcCA9IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3A7XG5cbiAgLy8gQW5kcm9pZCBzb21ldGltZXMgcmV0dXJucyBzbGlnaHRseSBvZmYgZGVjaW1hbCB2YWx1ZXMsIHNvIG5lZWQgdG8gcm91bmRcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiByb3VuZEZsb2F0KGxlZnQpLFxuICAgIHRvcDogcm91bmRGbG9hdCh0b3ApXG4gIH07XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV2ZW50IFN5c3RlbSAoSm9obiBSZXNpZyAtIFNlY3JldHMgb2YgYSBKUyBOaW5qYSBodHRwOi8vanNuaW5qYS5jb20vKVxuICogKE9yaWdpbmFsIGJvb2sgdmVyc2lvbiB3YXNuJ3QgY29tcGxldGVseSB1c2FibGUsIHNvIGZpeGVkIHNvbWUgdGhpbmdzIGFuZCBtYWRlIENsb3N1cmUgQ29tcGlsZXIgY29tcGF0aWJsZSlcbiAqIFRoaXMgc2hvdWxkIHdvcmsgdmVyeSBzaW1pbGFybHkgdG8galF1ZXJ5J3MgZXZlbnRzLCBob3dldmVyIGl0J3MgYmFzZWQgb2ZmIHRoZSBib29rIHZlcnNpb24gd2hpY2ggaXNuJ3QgYXNcbiAqIHJvYnVzdCBhcyBqcXVlcnkncywgc28gdGhlcmUncyBwcm9iYWJseSBzb21lIGRpZmZlcmVuY2VzLlxuICovXG5cbmltcG9ydCAqIGFzIERvbSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgKiBhcyBHdWlkIGZyb20gJy4vZ3VpZC5qcyc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9ICAgZWxlbSBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSAgIHR5cGUgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgRXZlbnQgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbihlbGVtLCB0eXBlLCBmbil7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvbiwgZWxlbSwgdHlwZSwgZm4pO1xuICB9XG5cbiAgbGV0IGRhdGEgPSBEb20uZ2V0RGF0YShlbGVtKTtcblxuICAvLyBXZSBuZWVkIGEgcGxhY2UgdG8gc3RvcmUgYWxsIG91ciBoYW5kbGVyIGRhdGFcbiAgaWYgKCFkYXRhLmhhbmRsZXJzKSBkYXRhLmhhbmRsZXJzID0ge307XG5cbiAgaWYgKCFkYXRhLmhhbmRsZXJzW3R5cGVdKSBkYXRhLmhhbmRsZXJzW3R5cGVdID0gW107XG5cbiAgaWYgKCFmbi5ndWlkKSBmbi5ndWlkID0gR3VpZC5uZXdHVUlEKCk7XG5cbiAgZGF0YS5oYW5kbGVyc1t0eXBlXS5wdXNoKGZuKTtcblxuICBpZiAoIWRhdGEuZGlzcGF0Y2hlcikge1xuICAgIGRhdGEuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIGRhdGEuZGlzcGF0Y2hlciA9IGZ1bmN0aW9uIChldmVudCl7XG5cbiAgICAgIGlmIChkYXRhLmRpc2FibGVkKSByZXR1cm47XG4gICAgICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICAgICAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1tldmVudC50eXBlXTtcblxuICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIC8vIENvcHkgaGFuZGxlcnMgc28gaWYgaGFuZGxlcnMgYXJlIGFkZGVkL3JlbW92ZWQgZHVyaW5nIHRoZSBwcm9jZXNzIGl0IGRvZXNuJ3QgdGhyb3cgZXZlcnl0aGluZyBvZmYuXG4gICAgICAgIHZhciBoYW5kbGVyc0NvcHkgPSBoYW5kbGVycy5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKHZhciBtID0gMCwgbiA9IGhhbmRsZXJzQ29weS5sZW5ndGg7IG0gPCBuOyBtKyspIHtcbiAgICAgICAgICBpZiAoZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZXJzQ29weVttXS5jYWxsKGVsZW0sIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKGRhdGEuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGRhdGEuZGlzcGF0Y2hlciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZGF0YS5kaXNwYXRjaGVyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgIGVsZW0gT2JqZWN0IHRvIHJlbW92ZSBsaXN0ZW5lcnMgZnJvbVxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5PX0gICB0eXBlIFR5cGUgb2YgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBhbGwgZXZlbnRzIGZyb20gZWxlbWVudC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgIFNwZWNpZmljIGxpc3RlbmVyIHRvIHJlbW92ZS4gRG9uJ3QgaW5jbHVkZSB0byByZW1vdmUgbGlzdGVuZXJzIGZvciBhbiBldmVudCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZmKGVsZW0sIHR5cGUsIGZuKSB7XG4gIC8vIERvbid0IHdhbnQgdG8gYWRkIGEgY2FjaGUgb2JqZWN0IHRocm91Z2ggZ2V0RGF0YSBpZiBub3QgbmVlZGVkXG4gIGlmICghRG9tLmhhc0RhdGEoZWxlbSkpIHJldHVybjtcblxuICBsZXQgZGF0YSA9IERvbS5nZXREYXRhKGVsZW0pO1xuXG4gIC8vIElmIG5vIGV2ZW50cyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcbiAgaWYgKCFkYXRhLmhhbmRsZXJzKSB7IHJldHVybjsgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvZmYsIGVsZW0sIHR5cGUsIGZuKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25cbiAgdmFyIHJlbW92ZVR5cGUgPSBmdW5jdGlvbih0KXtcbiAgICAgZGF0YS5oYW5kbGVyc1t0XSA9IFtdO1xuICAgICBfY2xlYW5VcEV2ZW50cyhlbGVtLHQpO1xuICB9O1xuXG4gIC8vIEFyZSB3ZSByZW1vdmluZyBhbGwgYm91bmQgZXZlbnRzP1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKGxldCB0IGluIGRhdGEuaGFuZGxlcnMpIHJlbW92ZVR5cGUodCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1t0eXBlXTtcblxuICAvLyBJZiBubyBoYW5kbGVycyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuO1xuXG4gIC8vIElmIG5vIGxpc3RlbmVyIHdhcyBwcm92aWRlZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHR5cGVcbiAgaWYgKCFmbikge1xuICAgIHJlbW92ZVR5cGUodHlwZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UncmUgb25seSByZW1vdmluZyBhIHNpbmdsZSBoYW5kbGVyXG4gIGlmIChmbi5ndWlkKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoYW5kbGVycy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKGhhbmRsZXJzW25dLmd1aWQgPT09IGZuLmd1aWQpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKG4tLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NsZWFuVXBFdmVudHMoZWxlbSwgdHlwZSk7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBmb3IgYW4gZWxlbWVudFxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9ICAgICAgZWxlbSAgRWxlbWVudCB0byB0cmlnZ2VyIGFuIGV2ZW50IG9uXG4gKiBAcGFyYW0gIHtFdmVudHxPYmplY3R8U3RyaW5nfSBldmVudCBBIHN0cmluZyAodGhlIHR5cGUpIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaWdnZXIoZWxlbSwgZXZlbnQpIHtcbiAgLy8gRmV0Y2hlcyBlbGVtZW50IGRhdGEgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgKGZvciBidWJibGluZykuXG4gIC8vIERvbid0IHdhbnQgdG8gYWRkIGEgZGF0YSBvYmplY3QgdG8gY2FjaGUgZm9yIGV2ZXJ5IHBhcmVudCxcbiAgLy8gc28gY2hlY2tpbmcgaGFzRGF0YSBmaXJzdC5cbiAgdmFyIGVsZW1EYXRhID0gKERvbS5oYXNEYXRhKGVsZW0pKSA/IERvbS5nZXREYXRhKGVsZW0pIDoge307XG4gIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUgfHwgZWxlbS5vd25lckRvY3VtZW50O1xuICAgICAgLy8gdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQsXG4gICAgICAvLyBoYW5kbGVyO1xuXG4gIC8vIElmIGFuIGV2ZW50IG5hbWUgd2FzIHBhc3NlZCBhcyBhIHN0cmluZywgY3JlYXRlcyBhbiBldmVudCBvdXQgb2YgaXRcbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBldmVudCA9IHsgdHlwZTpldmVudCwgdGFyZ2V0OmVsZW0gfTtcbiAgfVxuICAvLyBOb3JtYWxpemVzIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxuICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICAvLyBJZiB0aGUgcGFzc2VkIGVsZW1lbnQgaGFzIGEgZGlzcGF0Y2hlciwgZXhlY3V0ZXMgdGhlIGVzdGFibGlzaGVkIGhhbmRsZXJzLlxuICBpZiAoZWxlbURhdGEuZGlzcGF0Y2hlcikge1xuICAgIGVsZW1EYXRhLmRpc3BhdGNoZXIuY2FsbChlbGVtLCBldmVudCk7XG4gIH1cblxuICAvLyBVbmxlc3MgZXhwbGljaXRseSBzdG9wcGVkIG9yIHRoZSBldmVudCBkb2VzIG5vdCBidWJibGUgKGUuZy4gbWVkaWEgZXZlbnRzKVxuICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGxzIHRoaXMgZnVuY3Rpb24gdG8gYnViYmxlIHRoZSBldmVudCB1cCB0aGUgRE9NLlxuICAgIGlmIChwYXJlbnQgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZXZlbnQuYnViYmxlcyAhPT0gZmFsc2UpIHtcbiAgICB0cmlnZ2VyKHBhcmVudCwgZXZlbnQpO1xuXG4gIC8vIElmIGF0IHRoZSB0b3Agb2YgdGhlIERPTSwgdHJpZ2dlcnMgdGhlIGRlZmF1bHQgYWN0aW9uIHVubGVzcyBkaXNhYmxlZC5cbiAgfSBlbHNlIGlmICghcGFyZW50ICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdmFyIHRhcmdldERhdGEgPSBEb20uZ2V0RGF0YShldmVudC50YXJnZXQpO1xuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSB0YXJnZXQgaGFzIGEgZGVmYXVsdCBhY3Rpb24gZm9yIHRoaXMgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnRhcmdldFtldmVudC50eXBlXSkge1xuICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcgb24gdGhlIHRhcmdldCBhcyB3ZSBoYXZlIGFscmVhZHkgZXhlY3V0ZWQgdGhlIGhhbmRsZXIuXG4gICAgICB0YXJnZXREYXRhLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIC8vIEV4ZWN1dGVzIHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAgICAgIGlmICh0eXBlb2YgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV2ZW50LnRhcmdldFtldmVudC50eXBlXSgpO1xuICAgICAgfVxuICAgICAgLy8gUmUtZW5hYmxlcyBldmVudCBkaXNwYXRjaGluZy5cbiAgICAgIHRhcmdldERhdGEuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBJbmZvcm0gdGhlIHRyaWdnZXJlciBpZiB0aGUgZGVmYXVsdCB3YXMgcHJldmVudGVkIGJ5IHJldHVybmluZyBmYWxzZVxuICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhIGxpc3RlbmVyIG9ubHkgb25jZSBmb3IgYW4gZXZlbnRcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgIGVsZW0gRWxlbWVudCBvciBvYmplY3QgdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gICB0eXBlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uZShlbGVtLCB0eXBlLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob25lLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbigpe1xuICAgIG9mZihlbGVtLCB0eXBlLCBmdW5jKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICAvLyBjb3B5IHRoZSBndWlkIHRvIHRoZSBuZXcgZnVuY3Rpb24gc28gaXQgY2FuIHJlbW92ZWQgdXNpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uJ3MgSURcbiAgZnVuYy5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgR3VpZC5uZXdHVUlEKCk7XG4gIG9uKGVsZW0sIHR5cGUsIGZ1bmMpO1xufVxuXG4vKipcbiAqIEZpeCBhIG5hdGl2ZSBldmVudCB0byBoYXZlIHN0YW5kYXJkIHByb3BlcnR5IHZhbHVlc1xuICogQHBhcmFtICB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3QgdG8gZml4XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml4RXZlbnQoZXZlbnQpIHtcblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gVGVzdCBpZiBmaXhpbmcgdXAgaXMgbmVlZGVkXG4gIC8vIFVzZWQgdG8gY2hlY2sgaWYgIWV2ZW50LnN0b3BQcm9wYWdhdGlvbiBpbnN0ZWFkIG9mIGlzUHJvcGFnYXRpb25TdG9wcGVkXG4gIC8vIEJ1dCBuYXRpdmUgZXZlbnRzIHJldHVybiB0cnVlIGZvciBzdG9wUHJvcGFnYXRpb24sIGJ1dCBkb24ndCBoYXZlXG4gIC8vIG90aGVyIGV4cGVjdGVkIG1ldGhvZHMgbGlrZSBpc1Byb3BhZ2F0aW9uU3RvcHBlZC4gU2VlbXMgdG8gYmUgYSBwcm9ibGVtXG4gIC8vIHdpdGggdGhlIEphdmFzY3JpcHQgTmluamEgY29kZS4gU28gd2UncmUganVzdCBvdmVycmlkaW5nIGFsbCBldmVudHMgbm93LlxuICBpZiAoIWV2ZW50IHx8ICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgIHZhciBvbGQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICBldmVudCA9IHt9O1xuICAgIC8vIENsb25lIHRoZSBvbGQgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIG1vZGlmeSB0aGUgdmFsdWVzIGV2ZW50ID0ge307XG4gICAgLy8gSUU4IERvZXNuJ3QgbGlrZSB3aGVuIHlvdSBtZXNzIHdpdGggbmF0aXZlIGV2ZW50IHByb3BlcnRpZXNcbiAgICAvLyBGaXJlZm94IHJldHVybnMgZmFsc2UgZm9yIGV2ZW50Lmhhc093blByb3BlcnR5KCd0eXBlJykgYW5kIG90aGVyIHByb3BzXG4gICAgLy8gIHdoaWNoIG1ha2VzIGNvcHlpbmcgbW9yZSBkaWZmaWN1bHQuXG4gICAgLy8gVE9ETzogUHJvYmFibHkgYmVzdCB0byBjcmVhdGUgYSB3aGl0ZWxpc3Qgb2YgZXZlbnQgcHJvcHNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2xkKSB7XG4gICAgICAvLyBTYWZhcmkgNi4wLjMgd2FybnMgeW91IGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIGxheWVyWC9ZXG4gICAgICAvLyBDaHJvbWUgd2FybnMgeW91IGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIGtleWJvYXJkRXZlbnQua2V5TG9jYXRpb25cbiAgICAgIGlmIChrZXkgIT09ICdsYXllclgnICYmIGtleSAhPT0gJ2xheWVyWScgJiYga2V5ICE9PSAna2V5TG9jYXRpb24nKSB7XG4gICAgICAgIC8vIENocm9tZSAzMisgd2FybnMgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQgcmV0dXJuVmFsdWUsIGJ1dFxuICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIGlmIHByZXZlbnREZWZhdWx0IGlzbid0IHN1cHBvcnRlZCAoSUU4KS5cbiAgICAgICAgaWYgKCEoa2V5ID09PSAncmV0dXJuVmFsdWUnICYmIG9sZC5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgICAgICBldmVudFtrZXldID0gb2xkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgZXZlbnQgb2NjdXJyZWQgb24gdGhpcyBlbGVtZW50XG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHdoaWNoIG90aGVyIGVsZW1lbnQgdGhlIGV2ZW50IGlzIHJlbGF0ZWQgdG9cbiAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/XG4gICAgICBldmVudC50b0VsZW1lbnQgOlxuICAgICAgZXZlbnQuZnJvbUVsZW1lbnQ7XG5cbiAgICAvLyBTdG9wIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIG9sZC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgb2xkLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB9O1xuXG4gICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmcgYW5kIGV4ZWN1dGluZyBvdGhlciBoYW5kbGVyc1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG4gICAgICAgIG9sZC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG5cbiAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVybkZhbHNlO1xuXG4gICAgLy8gSGFuZGxlIG1vdXNlIHBvc2l0aW9uXG4gICAgaWYgKGV2ZW50LmNsaWVudFggIT0gbnVsbCkge1xuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgIGV2ZW50LnBhZ2VYID0gZXZlbnQuY2xpZW50WCArXG4gICAgICAgIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLVxuICAgICAgICAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgZXZlbnQucGFnZVkgPSBldmVudC5jbGllbnRZICtcbiAgICAgICAgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLVxuICAgICAgICAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUga2V5IHByZXNzZXNcbiAgICBldmVudC53aGljaCA9IGV2ZW50LmNoYXJDb2RlIHx8IGV2ZW50LmtleUNvZGU7XG5cbiAgICAvLyBGaXggYnV0dG9uIGZvciBtb3VzZSBjbGlja3M6XG4gICAgLy8gMCA9PSBsZWZ0OyAxID09IG1pZGRsZTsgMiA9PSByaWdodFxuICAgIGlmIChldmVudC5idXR0b24gIT0gbnVsbCkge1xuICAgICAgZXZlbnQuYnV0dG9uID0gKGV2ZW50LmJ1dHRvbiAmIDEgPyAwIDpcbiAgICAgICAgKGV2ZW50LmJ1dHRvbiAmIDQgPyAxIDpcbiAgICAgICAgICAoZXZlbnQuYnV0dG9uICYgMiA/IDIgOiAwKSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgZml4ZWQtdXAgaW5zdGFuY2VcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBsaXN0ZW5lciBjYWNoZSBhbmQgZGlzcGF0Y2hlcnNcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEVsZW1lbnQgdG8gY2xlYW4gdXBcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSBUeXBlIG9mIGV2ZW50IHRvIGNsZWFuIHVwXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKSB7XG4gIHZhciBkYXRhID0gRG9tLmdldERhdGEoZWxlbSk7XG5cbiAgLy8gUmVtb3ZlIHRoZSBldmVudHMgb2YgYSBwYXJ0aWN1bGFyIHR5cGUgaWYgdGhlcmUgYXJlIG5vbmUgbGVmdFxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgZGF0YS5oYW5kbGVyc1t0eXBlXTtcbiAgICAvLyBkYXRhLmhhbmRsZXJzW3R5cGVdID0gbnVsbDtcbiAgICAvLyBTZXR0aW5nIHRvIG51bGwgd2FzIGNhdXNpbmcgYW4gZXJyb3Igd2l0aCBkYXRhLmhhbmRsZXJzXG5cbiAgICAvLyBSZW1vdmUgdGhlIG1ldGEtaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGRhdGEuZGlzcGF0Y2hlciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudCkge1xuICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZGF0YS5kaXNwYXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvYmplY3QgaWYgdGhlcmUgYXJlIG5vIHR5cGVzIGxlZnRcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEuaGFuZGxlcnMpLmxlbmd0aCA8PSAwKSB7XG4gICAgZGVsZXRlIGRhdGEuaGFuZGxlcnM7XG4gICAgZGVsZXRlIGRhdGEuZGlzcGF0Y2hlcjtcbiAgICBkZWxldGUgZGF0YS5kaXNhYmxlZDtcblxuICAgIC8vIGRhdGEuaGFuZGxlcnMgPSBudWxsO1xuICAgIC8vIGRhdGEuZGlzcGF0Y2hlciA9IG51bGw7XG4gICAgLy8gZGF0YS5kaXNhYmxlZCA9IG51bGw7XG4gIH1cblxuICAvLyBGaW5hbGx5IHJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSBpcyBubyBkYXRhIGxlZnRcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEpLmxlbmd0aCA8PSAwKSB7XG4gICAgRG9tLnJlbW92ZURhdGEoZWxlbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFuZCBjYWxscyB0aGUgcmVxdWVzdGVkIG1ldGhvZCBmb3IgZWFjaCB0eXBlLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgVGhlIGV2ZW50IG1ldGhvZCB3ZSB3YW50IHRvIHVzZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgbGlzdGVuZXJzIHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgdHlwZSBUeXBlIG9mIGV2ZW50IHRvIGJpbmQgdG8uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBFdmVudCBsaXN0ZW5lci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhmbiwgZWxlbSwgdHlwZXMsIGNhbGxiYWNrKSB7XG4gIHR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIC8vQ2FsbCB0aGUgZXZlbnQgbWV0aG9kIGZvciBlYWNoIG9uZSBvZiB0aGUgdHlwZXNcbiAgICBmbihlbGVtLCB0eXBlLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgbmV3R1VJRCB9IGZyb20gJy4vZ3VpZC5qcyc7XG5cbi8qKlxuICogQmluZCAoYS5rLmEgcHJveHkgb3IgQ29udGV4dCkuIEEgc2ltcGxlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGNvbnRleHQgb2YgYSBmdW5jdGlvblxuICAgSXQgYWxzbyBzdG9yZXMgYSB1bmlxdWUgaWQgb24gdGhlIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBlYXNpbHkgcmVtb3ZlZCBmcm9tIGV2ZW50c1xuICogQHBhcmFtICB7Kn0gICBjb250ZXh0IFRoZSBvYmplY3QgdG8gYmluZCBhcyBzY29wZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGJvdW5kIHRvIGEgc2NvcGVcbiAqIEBwYXJhbSAge051bWJlcj19ICAgdWlkICAgICBBbiBvcHRpb25hbCB1bmlxdWUgSUQgZm9yIHRoZSBmdW5jdGlvbiB0byBiZSBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmQgPSBmdW5jdGlvbihjb250ZXh0LCBmbiwgdWlkKSB7XG4gIC8vIE1ha2Ugc3VyZSB0aGUgZnVuY3Rpb24gaGFzIGEgdW5pcXVlIElEXG4gIGlmICghZm4uZ3VpZCkgeyBmbi5ndWlkID0gbmV3R1VJRCgpOyB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBuZXcgZnVuY3Rpb24gdGhhdCBjaGFuZ2VzIHRoZSBjb250ZXh0XG4gIGxldCByZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBBbGxvdyBmb3IgdGhlIGFiaWxpdHkgdG8gaW5kaXZpZHVhbGl6ZSB0aGlzIGZ1bmN0aW9uXG4gIC8vIE5lZWRlZCBpbiB0aGUgY2FzZSB3aGVyZSBtdWx0aXBsZSBvYmplY3RzIG1pZ2h0IHNoYXJlIHRoZSBzYW1lIHByb3RvdHlwZVxuICAvLyBJRiBib3RoIGl0ZW1zIGFkZCBhbiBldmVudCBsaXN0ZW5lciB3aXRoIHRoZSBzYW1lIGZ1bmN0aW9uLCB0aGVuIHlvdSB0cnkgdG8gcmVtb3ZlIGp1c3Qgb25lXG4gIC8vIGl0IHdpbGwgcmVtb3ZlIGJvdGggYmVjYXVzZSB0aGV5IGJvdGggaGF2ZSB0aGUgc2FtZSBndWlkLlxuICAvLyB3aGVuIHVzaW5nIHRoaXMsIHlvdSBuZWVkIHRvIHVzZSB0aGUgYmluZCBtZXRob2Qgd2hlbiB5b3UgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhcyB3ZWxsLlxuICAvLyBjdXJyZW50bHkgdXNlZCBpbiB0ZXh0IHRyYWNrc1xuICByZXQuZ3VpZCA9ICh1aWQpID8gdWlkICsgJ18nICsgZm4uZ3VpZCA6IGZuLmd1aWQ7XG5cbiAgcmV0dXJuIHJldDtcbn07XG4iLCIvKipcbiAqIEZvcm1hdCBzZWNvbmRzIGFzIGEgdGltZSBzdHJpbmcsIEg6TU06U1Mgb3IgTTpTU1xuICogU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpIHdpbGwgZm9yY2UgYSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvc1xuICogdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZ3VpZGVcbiAqIEBwYXJhbSAge051bWJlcn0gc2Vjb25kcyBOdW1iZXIgb2Ygc2Vjb25kcyB0byBiZSB0dXJuZWQgaW50byBhIHN0cmluZ1xuICogQHBhcmFtICB7TnVtYmVyfSBndWlkZSAgIE51bWJlciAoaW4gc2Vjb25kcykgdG8gbW9kZWwgdGhlIHN0cmluZyBhZnRlclxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIFRpbWUgZm9ybWF0dGVkIGFzIEg6TU06U1Mgb3IgTTpTU1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0VGltZShzZWNvbmRzLCBndWlkZT1zZWNvbmRzKSB7XG4gIGxldCBzID0gTWF0aC5mbG9vcihzZWNvbmRzICUgNjApO1xuICBsZXQgbSA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwICUgNjApO1xuICBsZXQgaCA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICBjb25zdCBnbSA9IE1hdGguZmxvb3IoZ3VpZGUgLyA2MCAlIDYwKTtcbiAgY29uc3QgZ2ggPSBNYXRoLmZsb29yKGd1aWRlIC8gMzYwMCk7XG5cbiAgLy8gaGFuZGxlIGludmFsaWQgdGltZXNcbiAgaWYgKGlzTmFOKHNlY29uZHMpIHx8IHNlY29uZHMgPT09IEluZmluaXR5KSB7XG4gICAgLy8gJy0nIGlzIGZhbHNlIGZvciBhbGwgcmVsYXRpb25hbCBvcGVyYXRvcnMgKGUuZy4gPCwgPj0pIHNvIHRoaXMgc2V0dGluZ1xuICAgIC8vIHdpbGwgYWRkIHRoZSBtaW5pbXVtIG51bWJlciBvZiBmaWVsZHMgc3BlY2lmaWVkIGJ5IHRoZSBndWlkZVxuICAgIGggPSBtID0gcyA9ICctJztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gc2hvdyBob3Vyc1xuICBoID0gKGggPiAwIHx8IGdoID4gMCkgPyBoICsgJzonIDogJyc7XG5cbiAgLy8gSWYgaG91cnMgYXJlIHNob3dpbmcsIHdlIG1heSBuZWVkIHRvIGFkZCBhIGxlYWRpbmcgemVyby5cbiAgLy8gQWx3YXlzIHNob3cgYXQgbGVhc3Qgb25lIGRpZ2l0IG9mIG1pbnV0ZXMuXG4gIG0gPSAoKChoIHx8IGdtID49IDEwKSAmJiBtIDwgMTApID8gJzAnICsgbSA6IG0pICsgJzonO1xuXG4gIC8vIENoZWNrIGlmIGxlYWRpbmcgemVybyBpcyBuZWVkIGZvciBzZWNvbmRzXG4gIHMgPSAocyA8IDEwKSA/ICcwJyArIHMgOiBzO1xuXG4gIHJldHVybiBoICsgbSArIHM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdFRpbWU7XG4iLCIvKipcbiAqIFVuaXF1ZSBJRCBmb3IgYW4gZWxlbWVudCBvciBmdW5jdGlvblxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCBfZ3VpZCA9IDE7XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHVuaXF1ZSBJRFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmV3R1VJRCgpIHtcbiAgcmV0dXJuIF9ndWlkKys7XG59XG4iLCJpbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG4vKipcbiAqIExvZyBwbGFpbiBkZWJ1ZyBtZXNzYWdlc1xuICovXG5jb25zdCBsb2cgPSBmdW5jdGlvbigpe1xuICBfbG9nVHlwZShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBLZWVwIGEgaGlzdG9yeSBvZiBsb2cgbWVzc2FnZXNcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xubG9nLmhpc3RvcnkgPSBbXTtcblxuLyoqXG4gKiBMb2cgZXJyb3IgbWVzc2FnZXNcbiAqL1xubG9nLmVycm9yID0gZnVuY3Rpb24oKXtcbiAgX2xvZ1R5cGUoJ2Vycm9yJywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogTG9nIHdhcm5pbmcgbWVzc2FnZXNcbiAqL1xubG9nLndhcm4gPSBmdW5jdGlvbigpe1xuICBfbG9nVHlwZSgnd2FybicsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIExvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZSBhbmQgaGlzdG9yeSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBtZXNzYWdlXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIG1lc3NhZ2UsIG9yIGBudWxsYCBmb3IgYGxvZ2BcbiAqIEBwYXJhbSAge1t0eXBlXX0gYXJncyBUaGUgYXJncyB0byBiZSBwYXNzZWQgdG8gdGhlIGxvZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2xvZ1R5cGUodHlwZSwgYXJncyl7XG4gIC8vIGNvbnZlcnQgYXJncyB0byBhbiBhcnJheSB0byBnZXQgYXJyYXkgZnVuY3Rpb25zXG4gIGxldCBhcmdzQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgLy8gaWYgdGhlcmUncyBubyBjb25zb2xlIHRoZW4gZG9uJ3QgdHJ5IHRvIG91dHB1dCBtZXNzYWdlc1xuICAvLyB0aGV5IHdpbGwgc3RpbGwgYmUgc3RvcmVkIGluIGxvZy5oaXN0b3J5XG4gIC8vIFdhcyBzZXR0aW5nIHRoZXNlIG9uY2Ugb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLCBidXQgY29udGFpbmluZyB0aGVtXG4gIC8vIGluIHRoZSBmdW5jdGlvbiBtYWtlcyBpdCBlYXNpZXIgdG8gdGVzdCBjYXNlcyB3aGVyZSBjb25zb2xlIGRvZXNuJ3QgZXhpc3RcbiAgbGV0IG5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgbGV0IGNvbnNvbGUgPSB3aW5kb3dbJ2NvbnNvbGUnXSB8fCB7XG4gICAgJ2xvZyc6IG5vb3AsXG4gICAgJ3dhcm4nOiBub29wLFxuICAgICdlcnJvcic6IG5vb3BcbiAgfTtcblxuICBpZiAodHlwZSkge1xuICAgIC8vIGFkZCB0aGUgdHlwZSB0byB0aGUgZnJvbnQgb2YgdGhlIG1lc3NhZ2VcbiAgICBhcmdzQXJyYXkudW5zaGlmdCh0eXBlLnRvVXBwZXJDYXNlKCkrJzonKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZhdWx0IHRvIGxvZyB3aXRoIG5vIHByZWZpeFxuICAgIHR5cGUgPSAnbG9nJztcbiAgfVxuXG4gIC8vIGFkZCB0byBoaXN0b3J5XG4gIGxvZy5oaXN0b3J5LnB1c2goYXJnc0FycmF5KTtcblxuICAvLyBhZGQgY29uc29sZSBwcmVmaXggYWZ0ZXIgYWRkaW5nIHRvIGhpc3RvcnlcbiAgYXJnc0FycmF5LnVuc2hpZnQoJ1ZJREVPSlM6Jyk7XG5cbiAgLy8gY2FsbCBhcHByb3ByaWF0ZSBsb2cgZnVuY3Rpb25cbiAgaWYgKGNvbnNvbGVbdHlwZV0uYXBwbHkpIHtcbiAgICBjb25zb2xlW3R5cGVdLmFwcGx5KGNvbnNvbGUsIGFyZ3NBcnJheSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWU4IGRvZXNuJ3QgYWxsb3cgZXJyb3IuYXBwbHksIGJ1dCBpdCB3aWxsIGp1c3Qgam9pbigpIHRoZSBhcnJheSBhbnl3YXlcbiAgICBjb25zb2xlW3R5cGVdKGFyZ3NBcnJheS5qb2luKCcgJykpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxvZztcbiIsImltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gubWVyZ2UnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLmlzcGxhaW5vYmplY3QnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2guY2xvbmVkZWVwJztcblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9ucyBvYmplY3RzLCByZWN1cnNpdmVseSBtZXJnaW5nIGFueSBwbGFpbiBvYmplY3QgcHJvcGVydGllcyBhc1xuICogd2VsbC4gIFByZXZpb3VzbHkgYGRlZXBNZXJnZWBcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG92ZXJyaWRlIHZhbHVlcyBpblxuICogQHBhcmFtICB7T2JqZWN0fSBvYmoyIE92ZXJyaWRpbmcgb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgTmV3IG9iamVjdCAtLSBvYmoxIGFuZCBvYmoyIHdpbGwgYmUgdW50b3VjaGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvYmoxKXtcbiAgLy8gQ29weSB0byBlbnN1cmUgd2UncmUgbm90IG1vZGlmeWluZyB0aGUgZGVmYXVsdHMgc29tZXdoZXJlXG4gIG9iajEgPSBjbG9uZURlZXAob2JqMSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBBbGxvdyBmb3IgaW5maW5pdGUgYWRkaXRpb25hbCBvYmplY3QgYXJncyB0byBtZXJnZVxuICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLmZvckVhY2goZnVuY3Rpb24oYXJnT2JqKXtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvbmx5IHBsYWluIG9iamVjdHNcbiAgICAvLyBBbGwgb3RoZXIgdmFsdWVzIHdpbGwgYmUgZGlyZWN0bHkgY29waWVkXG4gICAgbWVyZ2Uob2JqMSwgYXJnT2JqLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoYSkgfHwgIWlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmoxO1xufVxuIiwiLyoqXG4gKiBTaG91bGQgcm91bmQgb2ZmIGEgbnVtYmVyIHRvIGEgZGVjaW1hbCBwbGFjZVxuICogQHBhcmFtICB7TnVtYmVyfSBudW0gTnVtYmVyIHRvIHJvdW5kXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlYyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG9cbiAqIEByZXR1cm4ge051bWJlcn0gICAgIFJvdW5kZWQgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCByb3VuZEZsb2F0ID0gZnVuY3Rpb24obnVtLCBkZWM9MCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0qTWF0aC5wb3coMTAsZGVjKSkvTWF0aC5wb3coMTAsZGVjKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJvdW5kRmxvYXQ7XG4iLCIvKipcbiAqIFNob3VsZCBjcmVhdGUgYSBmYWtlIFRpbWVSYW5nZSBvYmplY3RcbiAqIE1pbWljcyBhbiBIVE1MNSB0aW1lIHJhbmdlIGluc3RhbmNlLCB3aGljaCBoYXMgZnVuY3Rpb25zIHRoYXRcbiAqIHJldHVybiB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lcyBmb3IgYSByYW5nZVxuICogVGltZVJhbmdlcyBhcmUgcmV0dXJuZWQgYnkgdGhlIGJ1ZmZlcmVkKCkgbWV0aG9kXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IHRpbWUgaW4gc2Vjb25kc1xuICogQHBhcmFtICB7TnVtYmVyfSBlbmQgICBFbmQgdGltZSBpbiBzZWNvbmRzXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIEZha2UgVGltZVJhbmdlIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZShzdGFydCwgZW5kKXtcbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IDEsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhcnQ7IH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHsgcmV0dXJuIGVuZDsgfVxuICB9O1xufVxuIiwiLyoqXG4gKiBVcHBlcmNhc2UgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZ1xuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGJlIHVwcGVyY2FzZWRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvVGl0bGVDYXNlKHN0cmluZyl7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvVGl0bGVDYXNlO1xuIiwiaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogUmVzb2x2ZSBhbmQgcGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgVVJMXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHVybCBUaGUgdXJsIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBBbiBvYmplY3Qgb2YgdXJsIGRldGFpbHNcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIGNvbnN0IHByb3BzID0gWydwcm90b2NvbCcsICdob3N0bmFtZScsICdwb3J0JywgJ3BhdGhuYW1lJywgJ3NlYXJjaCcsICdoYXNoJywgJ2hvc3QnXTtcblxuICAvLyBhZGQgdGhlIHVybCB0byBhbiBhbmNob3IgYW5kIGxldCB0aGUgYnJvd3NlciBwYXJzZSB0aGUgVVJMXG4gIGxldCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhLmhyZWYgPSB1cmw7XG5cbiAgLy8gSUU4IChhbmQgOT8pIEZpeFxuICAvLyBpZTggZG9lc24ndCBwYXJzZSB0aGUgVVJMIGNvcnJlY3RseSB1bnRpbCB0aGUgYW5jaG9yIGlzIGFjdHVhbGx5XG4gIC8vIGFkZGVkIHRvIHRoZSBib2R5LCBhbmQgYW4gaW5uZXJIVE1MIGlzIG5lZWRlZCB0byB0cmlnZ2VyIHRoZSBwYXJzaW5nXG4gIGxldCBhZGRUb0JvZHkgPSAoYS5ob3N0ID09PSAnJyAmJiBhLnByb3RvY29sICE9PSAnZmlsZTonKTtcbiAgbGV0IGRpdjtcbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pbm5lckhUTUwgPSBgPGEgaHJlZj1cIiR7dXJsfVwiPjwvYT5gO1xuICAgIGEgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAvLyBwcmV2ZW50IHRoZSBkaXYgZnJvbSBhZmZlY3RpbmcgbGF5b3V0XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lOyBwb3NpdGlvbjphYnNvbHV0ZTsnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIH1cblxuICAvLyBDb3B5IHRoZSBzcGVjaWZpYyBVUkwgcHJvcGVydGllcyB0byBhIG5ldyBvYmplY3RcbiAgLy8gVGhpcyBpcyBhbHNvIG5lZWRlZCBmb3IgSUU4IGJlY2F1c2UgdGhlIGFuY2hvciBsb3NlcyBpdHNcbiAgLy8gcHJvcGVydGllcyB3aGVuIGl0J3MgcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgbGV0IGRldGFpbHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGRldGFpbHNbcHJvcHNbaV1dID0gYVtwcm9wc1tpXV07XG4gIH1cblxuICAvLyBJRTkgYWRkcyB0aGUgcG9ydCB0byB0aGUgaG9zdCBwcm9wZXJ0eSB1bmxpa2UgZXZlcnlvbmUgZWxzZS4gSWZcbiAgLy8gYSBwb3J0IGlkZW50aWZpZXIgaXMgYWRkZWQgZm9yIHN0YW5kYXJkIHBvcnRzLCBzdHJpcCBpdC5cbiAgaWYgKGRldGFpbHMucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICBkZXRhaWxzLmhvc3QgPSBkZXRhaWxzLmhvc3QucmVwbGFjZSgvOjgwJC8sICcnKTtcbiAgfVxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBkZXRhaWxzLmhvc3QgPSBkZXRhaWxzLmhvc3QucmVwbGFjZSgvOjQ0MyQvLCAnJyk7XG4gIH1cblxuICBpZiAoYWRkVG9Cb2R5KSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG5cbiAgcmV0dXJuIGRldGFpbHM7XG59O1xuXG4vKipcbiAqIEdldCBhYnNvbHV0ZSB2ZXJzaW9uIG9mIHJlbGF0aXZlIFVSTC4gVXNlZCB0byB0ZWxsIGZsYXNoIGNvcnJlY3QgVVJMLlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NzA4MzIvZ2V0dGluZy1hbi1hYnNvbHV0ZS11cmwtZnJvbS1hLXJlbGF0aXZlLW9uZS1pZTYtaXNzdWVcbiAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFVSTCB0byBtYWtlIGFic29sdXRlXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBBYnNvbHV0ZSBVUkxcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBYnNvbHV0ZVVSTCA9IGZ1bmN0aW9uKHVybCl7XG4gIC8vIENoZWNrIGlmIGFic29sdXRlIFVSTFxuICBpZiAoIXVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSkge1xuICAgIC8vIENvbnZlcnQgdG8gYWJzb2x1dGUgVVJMLiBGbGFzaCBob3N0ZWQgb2ZmLXNpdGUgbmVlZHMgYW4gYWJzb2x1dGUgVVJMLlxuICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gYDxhIGhyZWY9XCIke3VybH1cIj54PC9hPmA7XG4gICAgdXJsID0gZGl2LmZpcnN0Q2hpbGQuaHJlZjtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGFzc2VkIGZpbGUgbmFtZS4gSXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgc3RyaW5nIGlmIHlvdSBwYXNzIGFuIGludmFsaWQgcGF0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgICBwYXRoICAgIFRoZSBmaWxlTmFtZSBwYXRoIGxpa2UgJy9wYXRoL3RvL2ZpbGUubXA0J1xuICogQHJldHVybnMge1N0cmluZ30gICAgICAgICAgVGhlIGV4dGVuc2lvbiBpbiBsb3dlciBjYXNlIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBubyBleHRlbnNpb24gY291bGQgYmUgZm91bmQuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZih0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpe1xuICAgIGxldCBzcGxpdFBhdGhSZSA9IC9eKFxcLz8pKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/KShcXC4oW15cXC5cXC9cXD9dKykpKSg/OltcXC9dKnxbXFw/XS4qKSQvaTtcbiAgICBsZXQgcGF0aFBhcnRzID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKTtcblxuICAgIGlmIChwYXRoUGFydHMpIHtcbiAgICAgIHJldHVybiBwYXRoUGFydHMucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuIiwiaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5pbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC5hc3NpZ24nO1xuaW1wb3J0IE1lZGlhTG9hZGVyIGZyb20gJy4vdGVjaC9sb2FkZXIuanMnO1xuaW1wb3J0IEh0bWw1IGZyb20gJy4vdGVjaC9odG1sNS5qcyc7XG5pbXBvcnQgRmxhc2ggZnJvbSAnLi90ZWNoL2ZsYXNoLmpzJztcbmltcG9ydCBQb3N0ZXJJbWFnZSBmcm9tICcuL3Bvc3Rlci1pbWFnZS5qcyc7XG5pbXBvcnQgVGV4dFRyYWNrRGlzcGxheSBmcm9tICcuL3RyYWNrcy90ZXh0LXRyYWNrLWRpc3BsYXkuanMnO1xuaW1wb3J0IExvYWRpbmdTcGlubmVyIGZyb20gJy4vbG9hZGluZy1zcGlubmVyLmpzJztcbmltcG9ydCBCaWdQbGF5QnV0dG9uIGZyb20gJy4vYmlnLXBsYXktYnV0dG9uLmpzJztcbmltcG9ydCBDb250cm9sQmFyIGZyb20gJy4vY29udHJvbC1iYXIvY29udHJvbC1iYXIuanMnO1xuaW1wb3J0IEVycm9yRGlzcGxheSBmcm9tICcuL2Vycm9yLWRpc3BsYXkuanMnO1xuaW1wb3J0ICogYXMgc2V0dXAgZnJvbSAnLi9zZXR1cCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50JztcbmltcG9ydCBPcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgKiBhcyBEb20gZnJvbSAnLi91dGlscy9kb20uanMnO1xuaW1wb3J0IGxvZyBmcm9tICcuL3V0aWxzL2xvZy5qcyc7XG5pbXBvcnQgKiBhcyBicm93c2VyIGZyb20gJy4vdXRpbHMvYnJvd3Nlci5qcyc7XG5pbXBvcnQgUGxheWVyIGZyb20gJy4vcGxheWVyJztcbmltcG9ydCBleHRlbmRzRm4gZnJvbSAnLi9leHRlbmRzLmpzJztcbmltcG9ydCBwbHVnaW4gZnJvbSAnLi9wbHVnaW5zLmpzJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgbWVyZ2VPcHRpb25zIGZyb20gJy4uLy4uL3NyYy9qcy91dGlscy9tZXJnZS1vcHRpb25zLmpzJztcblxuLy8gSFRNTDUgRWxlbWVudCBTaGltIGZvciBJRThcbmlmICh0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcbn1cblxuLyoqXG4gKiBEb3VibGVzIGFzIHRoZSBtYWluIGZ1bmN0aW9uIGZvciB1c2VycyB0byBjcmVhdGUgYSBwbGF5ZXIgaW5zdGFuY2UgYW5kIGFsc29cbiAqIHRoZSBtYWluIGxpYnJhcnkgb2JqZWN0LlxuICpcbiAqICoqQUxJQVNFUyoqIHZpZGVvanMsIF9WXyAoZGVwcmVjYXRlZClcbiAqXG4gKiBUaGUgYHZqc2AgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBvciByZXRyaWV2ZSBhIHBsYXllci5cbiAqXG4gKiAgICAgdmFyIG15UGxheWVyID0gdmpzKCdteV92aWRlb19pZCcpO1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xFbGVtZW50fSBpZCAgICAgIFZpZGVvIGVsZW1lbnQgb3IgdmlkZW8gZWxlbWVudCBJRFxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9ucyAgICAgICAgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgZm9yIGNvbmZpZy9zZXR0aW5nc1xuICogQHBhcmFtICB7RnVuY3Rpb249fSByZWFkeSAgICAgICAgT3B0aW9uYWwgcmVhZHkgY2FsbGJhY2tcbiAqIEByZXR1cm4ge1BsYXllcn0gICAgICAgICAgICAgQSBwbGF5ZXIgaW5zdGFuY2VcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHZpZGVvanMgPSBmdW5jdGlvbihpZCwgb3B0aW9ucywgcmVhZHkpe1xuICB2YXIgdGFnOyAvLyBFbGVtZW50IG9mIElEXG5cbiAgLy8gQWxsb3cgZm9yIGVsZW1lbnQgb3IgSUQgdG8gYmUgcGFzc2VkIGluXG4gIC8vIFN0cmluZyBJRFxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuXG4gICAgLy8gQWRqdXN0IGZvciBqUXVlcnkgSUQgc3ludGF4XG4gICAgaWYgKGlkLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgaWQgPSBpZC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHBsYXllciBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHRoaXMgSUQgcmV0dXJuIGl0LlxuICAgIGlmIChQbGF5ZXIucGxheWVyc1tpZF0pIHtcblxuICAgICAgLy8gSWYgb3B0aW9ucyBvciByZWFkeSBmdW50aW9uIGFyZSBwYXNzZWQsIHdhcm5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGxvZy53YXJuKGBQbGF5ZXIgXCIke2lkfVwiIGlzIGFscmVhZHkgaW5pdGlhbGlzZWQuIE9wdGlvbnMgd2lsbCBub3QgYmUgYXBwbGllZC5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5KSB7XG4gICAgICAgIFBsYXllci5wbGF5ZXJzW2lkXS5yZWFkeShyZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQbGF5ZXIucGxheWVyc1tpZF07XG5cbiAgICAvLyBPdGhlcndpc2UgZ2V0IGVsZW1lbnQgZm9yIElEXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZyA9IERvbS5lbChpZCk7XG4gICAgfVxuXG4gIC8vIElEIGlzIGEgbWVkaWEgZWxlbWVudFxuICB9IGVsc2Uge1xuICAgIHRhZyA9IGlkO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGEgdXNlYWJsZSBlbGVtZW50XG4gIGlmICghdGFnIHx8ICF0YWcubm9kZU5hbWUpIHsgLy8gcmU6IG5vZGVOYW1lLCBjb3VsZCBiZSBhIGJveCBkaXYgYWxzb1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBlbGVtZW50IG9yIElEIHN1cHBsaWVkIGlzIG5vdCB2YWxpZC4gKHZpZGVvanMpJyk7IC8vIFJldHVybnNcbiAgfVxuXG4gIC8vIEVsZW1lbnQgbWF5IGhhdmUgYSBwbGF5ZXIgYXR0ciByZWZlcnJpbmcgdG8gYW4gYWxyZWFkeSBjcmVhdGVkIHBsYXllciBpbnN0YW5jZS5cbiAgLy8gSWYgbm90LCBzZXQgdXAgYSBuZXcgcGxheWVyIGFuZCByZXR1cm4gdGhlIGluc3RhbmNlLlxuICByZXR1cm4gdGFnWydwbGF5ZXInXSB8fCBuZXcgUGxheWVyKHRhZywgb3B0aW9ucywgcmVhZHkpO1xufTtcblxuLy8gQ0ROIFZlcnNpb24uIFVzZWQgdG8gdGFyZ2V0IHJpZ2h0IGZsYXNoIHN3Zi5cbnZpZGVvanMuQ0ROX1ZFUlNJT04gPSAnX19WRVJTSU9OX05PX1BBVENIX18nO1xudmlkZW9qcy5BQ0NFU1NfUFJPVE9DT0wgPSAoJ2h0dHBzOicgPT09IGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJyk7XG5cbi8qKlxuKiBGdWxsIHBsYXllciB2ZXJzaW9uXG4qIEB0eXBlIHtzdHJpbmd9XG4qL1xudmlkZW9qc1snVkVSU0lPTiddID0gJ19fVkVSU0lPTl9fJztcblxuLy8gU2V0IENETiBWZXJzaW9uIG9mIHN3ZlxuLy8gVGhlIGFkZGVkICgrKSBibG9ja3MgdGhlIHJlcGxhY2UgZnJvbSBjaGFuZ2luZyB0aGlzIF9WRVJTSU9OX05PX1BBVENIXyBzdHJpbmdcbmlmICh2aWRlb2pzLkNETl9WRVJTSU9OICE9PSAnX19WRVJTSU9OXycrJ05PX1BBVENIX18nKSB7XG4gIE9wdGlvbnNbJ2ZsYXNoJ11bJ3N3ZiddID0gYCR7dmlkZW9qcy5BQ0NFU1NfUFJPVE9DT0x9dmpzLnplbmNkbi5uZXQvJHt2aWRlb2pzLkNETl9WRVJTSU9OfS92aWRlby1qcy5zd2ZgO1xufVxuXG4vLyBSdW4gQXV0by1sb2FkIHBsYXllcnNcbi8vIFlvdSBoYXZlIHRvIHdhaXQgYXQgbGVhc3Qgb25jZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCBhZnRlciB5b3VyIHZpZGVvIGluIHRoZSBET00gKHdlaXJkIGJlaGF2aW9yIG9ubHkgd2l0aCBtaW5pZmllZCB2ZXJzaW9uKVxuc2V0dXAuYXV0b1NldHVwVGltZW91dCgxLCB2aWRlb2pzKTtcblxudmlkZW9qcy5nZXRDb21wb25lbnQgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50O1xudmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudCA9IENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudDtcblxuLy8gQVBJcyB0aGF0IHdpbGwgYmUgcmVtb3ZlZCB3aXRoIDUuMCwgYnV0IG5lZWQgdGhlbSB0byBnZXQgdGVzdHMgcGFzc2luZ1xuLy8gaW4gRVM2IHRyYW5zaXRpb25cbnZpZGVvanMuVE9VQ0hfRU5BQkxFRCA9IGJyb3dzZXIuVE9VQ0hfRU5BQkxFRDtcblxuLy8gUHJvYmFibHkgd2FudCB0byBrZWVwIHRoaXMgb25lIGZvciA1LjA/XG52aWRlb2pzLnBsYXllcnMgPSBQbGF5ZXIucGxheWVycztcblxudmlkZW9qcy5leHRlbmRzID0gZXh0ZW5kc0ZuO1xuXG52aWRlb2pzLm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcblxudmlkZW9qcy5nZXRHbG9iYWxPcHRpb25zID0gKCkgPT4gb3B0aW9ucztcbnZpZGVvanMuc2V0R2xvYmFsT3B0aW9ucyA9IGZ1bmN0aW9uKG5ld09wdGlvbnMpIHtcbiAgbWVyZ2VPcHRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xufTtcblxudmlkZW9qcy5wbHVnaW4gPSBwbHVnaW47XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYWRkaW5nIGxhbmd1YWdlcyB0byB0aGUgZGVmYXVsdCBvcHRpb25zLiBVc2VmdWwgZm9yXG4gKiBhbWVuZGluZyBtdWx0aXBsZSBsYW5ndWFnZSBzdXBwb3J0IGF0IHJ1bnRpbWUuXG4gKlxuICogRXhhbXBsZTogdmlkZW9qcy5hZGRMYW5ndWFnZSgnZXMnLCB7J0hlbGxvJzonSG9sYSd9KTtcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNvZGUgVGhlIGxhbmd1YWdlIGNvZGUgb3IgZGljdGlvbmFyeSBwcm9wZXJ0eVxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIHZhbHVlcyB0byBiZSB0cmFuc2xhdGVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgZ2xvYmFsIGxhbmd1YWdlcyBkaWN0aW9uYXJ5IG9iamVjdFxuICovXG52aWRlb2pzLmFkZExhbmd1YWdlID0gZnVuY3Rpb24oY29kZSwgZGF0YSl7XG4gIGlmKE9wdGlvbnNbJ2xhbmd1YWdlcyddW2NvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICBPcHRpb25zWydsYW5ndWFnZXMnXVtjb2RlXSA9IG1lcmdlT3B0aW9ucyhPcHRpb25zWydsYW5ndWFnZXMnXVtjb2RlXSwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgT3B0aW9uc1snbGFuZ3VhZ2VzJ11bY29kZV0gPSBkYXRhO1xuICB9XG4gIHJldHVybiBPcHRpb25zWydsYW5ndWFnZXMnXTtcbn07XG5cbi8vIFJFTU9WSU5HOiBXZSBwcm9iYWJseSBzaG91bGQgYWRkIHRoaXMgdG8gdGhlIG1pZ3JhdGlvbiBwbHVnaW5cbi8vIC8vIEV4cG9zZSBidXQgZGVwcmVjYXRlIHRoZSB3aW5kb3dbY29tcG9uZW50TmFtZV0gbWV0aG9kIGZvciBhY2Nlc3NpbmcgY29tcG9uZW50c1xuLy8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoQ29tcG9uZW50LmNvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG4vLyAgIGxldCBjb21wb25lbnQgPSBDb21wb25lbnQuY29tcG9uZW50c1tuYW1lXTtcbi8vXG4vLyAgIC8vIEEgZGVwcmVjYXRpb24gd2FybmluZyBhcyB0aGUgY29uc3R1Y3RvclxuLy8gICBtb2R1bGUuZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpe1xuLy8gICAgIGxvZy53YXJuKCdVc2luZyB2aWRlb2pzLicrbmFtZSsnIHRvIGFjY2VzcyB0aGUgJytuYW1lKycgY29tcG9uZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdmlkZW9qcy5nZXRDb21wb25lbnQoXCJjb21wb25lbnROYW1lXCIpJyk7XG4vL1xuLy8gICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucywgcmVhZHkpO1xuLy8gICB9O1xuLy9cbi8vICAgLy8gQWxsb3cgdGhlIHByb3RvdHlwZSBhbmQgY2xhc3MgbWV0aG9kcyB0byBiZSBhY2Nlc3NpYmxlIHN0aWxsIHRoaXMgd2F5XG4vLyAgIC8vIFRob3VnaCBhbnl0aGluZyB0aGF0IGF0dGVtcHRzIHRvIG92ZXJyaWRlIGNsYXNzIG1ldGhvZHMgd2lsbCBubyBsb25nZXIgd29ya1xuLy8gICBhc3NpZ24obW9kdWxlLmV4cG9ydHNbbmFtZV0sIGNvbXBvbmVudCk7XG4vLyB9KTtcblxuLyoqXG4gKiBDdXN0b20gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpXG4gKlxuICogVmlkZW8uanMgd2lsbCBuZXZlciBiZSBhIG5vbi1icm93c2VyIGxpYiBzbyB3ZSBjYW4gc2ltcGxpZnkgVU1EIGEgYnVuY2ggYW5kXG4gKiBzdGlsbCBzdXBwb3J0IHJlcXVpcmVqcyBhbmQgYnJvd3NlcmlmeS4gVGhpcyBhbHNvIG5lZWRzIHRvIGJlIGNsb3N1cmVcbiAqIGNvbXBpbGVyIGNvbXBhdGlibGUsIHNvIHN0cmluZyBrZXlzIGFyZSB1c2VkLlxuICovXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKSB7XG4gIGRlZmluZSgndmlkZW9qcycsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gdmlkZW9qczsgfSk7XG5cbi8vIGNoZWNraW5nIHRoYXQgbW9kdWxlIGlzIGFuIG9iamVjdCB0b28gYmVjYXVzZSBvZiB1bWRqcy91bWQjMzVcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZVsnZXhwb3J0cyddID0gdmlkZW9qcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmlkZW9qcztcbiIsImltcG9ydCAqIGFzIFVybCBmcm9tICcuL3V0aWxzL3VybC5qcyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vdXRpbHMvbG9nLmpzJztcbmltcG9ydCBtZXJnZU9wdGlvbnMgZnJvbSAnLi91dGlscy9tZXJnZS1vcHRpb25zLmpzJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbi8qKlxuICogU2ltcGxlIGh0dHAgcmVxdWVzdCBmb3IgcmV0cmlldmluZyBleHRlcm5hbCBmaWxlcyAoZS5nLiB0ZXh0IHRyYWNrcylcbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogICAgIC8vIHVzaW5nIHVybCBzdHJpbmdcbiAqICAgICB2aWRlb2pzLnhocignaHR0cDovL2V4YW1wbGUuY29tL215ZmlsZS52dHQnLCBmdW5jdGlvbihlcnJvciwgcmVzcG9uc2UsIHJlc3BvbnNlQm9keSl7fSk7XG4gKlxuICogICAgIC8vIG9yIG9wdGlvbnMgYmxvY2tcbiAqICAgICB2aWRlb2pzLnhocih7XG4gKiAgICAgICB1cmk6ICdodHRwOi8vZXhhbXBsZS5jb20vbXlmaWxlLnZ0dCcsXG4gKiAgICAgICBtZXRob2Q6ICdHRVQnLFxuICogICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCdcbiAqICAgICB9LCBmdW5jdGlvbihlcnJvciwgcmVzcG9uc2UsIHJlc3BvbnNlQm9keSl7XG4gKiAgICAgICBpZiAoZXJyb3IpIHtcbiAqICAgICAgICAgLy8gbG9nIHRoZSBlcnJvclxuICogICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgLy8gc3VjY2Vzc2Z1bCwgZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIEFQSSBpcyBtb2RlbGVkIGFmdGVyIHRoZSBSYXlub3MveGhyLCB3aGljaCB3ZSBob3BlIHRvIHVzZSBhZnRlclxuICogZ2V0dGluZyBicm93c2VyaWZ5IGltcGxlbWVudGVkLlxuICogaHR0cHM6Ly9naXRodWIuY29tL1JheW5vcy94aHIvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8U3RyaW5nfSAgb3B0aW9ucyAgIE9wdGlvbnMgYmxvY2sgb3IgVVJMIHN0cmluZ1xuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgVGhlIHJlcXVlc3RcbiAqL1xudmFyIHhociA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKXtcbiAgbGV0IGFib3J0VGltZW91dDtcblxuICAvLyBJZiBvcHRpb25zIGlzIGEgc3RyaW5nIGl0J3MgdGhlIHVybFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogb3B0aW9uc1xuICAgIH07XG4gIH1cblxuICAvLyBNZXJnZSB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICBtZXJnZU9wdGlvbnMoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdGltZW91dDogNDUgKiAxMDAwXG4gIH0sIG9wdGlvbnMpO1xuXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKXt9O1xuXG4gIGxldCBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7XG5cbiAgaWYgKHR5cGVvZiBYSFIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gU2hpbSBYTUxIdHRwUmVxdWVzdCBmb3Igb2xkZXIgSUVzXG4gICAgWEhSID0gZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHsgcmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2ggKGUpIHt9XG4gICAgICB0cnkgeyByZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSBjYXRjaCAoZikge31cbiAgICAgIHRyeSB7IHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2ggKGcpIHt9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LicpO1xuICAgIH07XG4gIH1cblxuICBsZXQgcmVxdWVzdCA9IG5ldyBYSFIoKTtcbiAgLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIHVybCBvbiB0aGUgcmVxdWVzdCBpbnN0YW5jZVxuICByZXF1ZXN0LnVyaSA9IG9wdGlvbnMudXJpO1xuXG4gIGxldCB1cmxJbmZvID0gVXJsLnBhcnNlVXJsKG9wdGlvbnMudXJpKTtcbiAgbGV0IHdpbkxvYyA9IHdpbmRvdy5sb2NhdGlvbjtcblxuICBsZXQgc3VjY2Vzc0hhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KTtcbiAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LCByZXF1ZXN0LnJlc3BvbnNlIHx8IHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfTtcblxuICBsZXQgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKXtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dCk7XG5cbiAgICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyID0gbmV3IEVycm9yKGVycik7XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyLCByZXF1ZXN0KTtcbiAgfTtcblxuICAvLyBDaGVjayBpZiB1cmwgaXMgZm9yIGFub3RoZXIgZG9tYWluL29yaWdpblxuICAvLyBJRTggZG9lc24ndCBrbm93IGxvY2F0aW9uLm9yaWdpbiwgc28gd2Ugd29uJ3QgcmVseSBvbiBpdCBoZXJlXG4gIGNvbnN0IGNyb3NzT3JpZ2luID0gKHVybEluZm8ucHJvdG9jb2wgKyB1cmxJbmZvLmhvc3QpICE9PSAod2luTG9jLnByb3RvY29sICsgd2luTG9jLmhvc3QpO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IC0tIFVzZSBmb3IgSUUgaWYgWE1MSFRUUFJlcXVlc3QyIGlzbid0IGF2YWlsYWJsZVxuICAvLyAnd2l0aENyZWRlbnRpYWxzJyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBYTUxIVFRQUmVxdWVzdDJcbiAgLy8gQWxzbyBYRG9tYWluUmVxdWVzdCBoYXMgYSBsb3Qgb2YgZ290Y2hhcywgc28gb25seSB1c2UgaWYgY3Jvc3MgZG9tYWluXG4gIGlmIChjcm9zc09yaWdpbiAmJiB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSkge1xuICAgIHJlcXVlc3QgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSBzdWNjZXNzSGFuZGxlcjtcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgLy8gVGhlc2UgYmxhbmsgaGFuZGxlcnMgbmVlZCB0byBiZSBzZXQgdG8gZml4IGllOVxuICAgIC8vIGh0dHA6Ly9jeXByZXNzbm9ydGguY29tL3Byb2dyYW1taW5nL2ludGVybmV0LWV4cGxvcmVyLWFib3J0aW5nLWFqYXgtcmVxdWVzdHMtZml4ZWQvXG4gICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24oKXt9O1xuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIFhNTEhUVFBSZXF1ZXN0XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlsZVVybCA9ICh1cmxJbmZvLnByb3RvY29sID09PSAnZmlsZTonIHx8IHdpbkxvYy5wcm90b2NvbCA9PT0gJ2ZpbGU6Jyk7XG5cbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAocmVxdWVzdC50aW1lZG91dCkge1xuICAgICAgICAgIHJldHVybiBlcnJvckhhbmRsZXIoJ3RpbWVvdXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IGZpbGVVcmwgJiYgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICBzdWNjZXNzSGFuZGxlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9ySGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgIGFib3J0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmVxdWVzdC50aW1lZG91dCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG9wZW4gdGhlIGNvbm5lY3Rpb25cbiAgdHJ5IHtcbiAgICAvLyBUaGlyZCBhcmcgaXMgYXN5bmMsIG9yIGlnbm9yZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgICByZXF1ZXN0Lm9wZW4ob3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsIG9wdGlvbnMudXJpLCB0cnVlKTtcbiAgfSBjYXRjaChlcnIpIHtcbiAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGVycik7XG4gIH1cblxuICAvLyB3aXRoQ3JlZGVudGlhbHMgb25seSBzdXBwb3J0ZWQgYnkgWE1MSHR0cFJlcXVlc3QyXG4gIGlmKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVzcG9uc2VUeXBlKSB7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8vIHNlbmQgdGhlIHJlcXVlc3RcbiAgdHJ5IHtcbiAgICByZXF1ZXN0LnNlbmQoKTtcbiAgfSBjYXRjaChlcnIpIHtcbiAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGVycik7XG4gIH1cblxuICByZXR1cm4gcmVxdWVzdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHhocjtcbiJdfQ==
